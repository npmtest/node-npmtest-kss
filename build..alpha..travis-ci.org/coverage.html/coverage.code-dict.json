{"/home/travis/build/npmtest/node-npmtest-kss/test.js":"/* istanbul instrument in package npmtest_kss */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-kss/lib.npmtest_kss.js":"/* istanbul instrument in package npmtest_kss */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_kss = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_kss = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-kss/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-kss && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_kss */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_kss\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_kss.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_kss.rollup.js'] =\n            local.assetsDict['/assets.npmtest_kss.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_kss.__dirname + '/lib.npmtest_kss.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-kss/node_modules/kss/index.js":"'use strict';\n\nmodule.exports = require('./lib/kss.js');\n","/home/travis/build/npmtest/node-npmtest-kss/node_modules/kss/lib/kss.js":"/* eslint-disable key-spacing */\n\n'use strict';\n\n/**\n * The core kss API can be imported with:\n * ```\n * var kss = require('kss');\n * ```\n *\n * The main object is a function that will generate a style guide given the\n * correct options.\n * ```\n * kss(opts, callback);\n * ```\n * The various constructors and methods can then be accessed with:\n * ```\n * var kssStyleguide = new kss.KssStyleguide();\n * var kssSection    = new kss.KssSection();\n * var kssModifier   = new kss.KssModifier();\n * var kssParameter  = new kss.KssParameter();\n * var kssConfig     = new kss.KssConfig();\n * kss.parse();\n * kss.traverse();\n * ```\n * @module kss\n */\n\nvar cli = require('./cli.js');\n\n/**\n * Generates a style guide given the proper options.\n *\n * @param {object} options A collection of configuration options.\n * @param {Function} done Callback function\n * @returns {*} null\n */\nvar kss = function(options, done) {\n  var stdout, stderr, argv,\n    flag, values, i;\n\n  // Allow options to provide an alternative to the process' stdout/stderr.\n  stdout = (options.pipes && options.pipes.stdout) ? options.pipes.stdout : process.stdout;\n  stderr = (options.pipes && options.pipes.stderr) ? options.pipes.stderr : process.stderr;\n\n  // Create an argv-like Array from the options.\n  argv = ['node', 'bin/kss-node'];\n  for (flag in options) {\n    if (options.hasOwnProperty(flag)) {\n      values = options[flag];\n      if (!Array.isArray(values)) {\n        values = [values];\n      }\n      for (i = 0; i < values.length; i++) {\n        if (values[i] === null\n          || typeof values[i] === 'boolean'\n          || typeof values[i] === 'undefined'\n        ) {\n          argv.push('--' + flag);\n        } else {\n          argv.push('--' + flag, values[i]);\n        }\n      }\n    }\n  }\n\n  // @TODO: This is a bit backwards, but our CLI came first. So now our \"pure\"\n  // JavaScript API is calling the cli module. In 3.x, swap this around.\n  return cli({\n    stdout: stdout,\n    stderr: stderr,\n    argv: argv\n  }, done);\n};\n\nmodule.exports = kss;\nmodule.exports.KssConfig = require('./kss_config.js');\nmodule.exports.KssStyleguide = require('./kss_styleguide.js');\nmodule.exports.KssSection = require('./kss_section.js');\nmodule.exports.KssModifier = require('./kss_modifier.js');\nmodule.exports.KssParameter = require('./kss_parameter.js');\nmodule.exports.parse = require('./parse.js');\nmodule.exports.traverse = require('./traverse.js');\n","/home/travis/build/npmtest/node-npmtest-kss/node_modules/kss/lib/cli.js":"'use strict';\n\n// var Promise = require('bluebird'),\nvar fs = require('fs-extra'),\n  KssConfig = require('./kss_config.js'),\n  path = require('path'),\n  version = require('../package.json').version,\n  yargs = require('yargs');\n\nvar cli;\n\ncli = function(opts, done) {\n  var generator,\n    kssConfig = new KssConfig(),\n    logError,\n    positionalParams,\n    stdout,\n    stderr,\n    argv;\n\n  stdout = opts.stdout;\n  stderr = opts.stderr;\n  argv = opts.argv || [];\n\n  // Add options only needed by the CLI or yargs.\n  kssConfig.addOptions({\n    // @TODO: Add stdin option.\n    // 'stdin': {\n    //   group: 'File locations:',\n    //   multiple: false,\n    //   boolean: true,\n    //   describe: 'Reads the source from standard input',\n    //  default: false\n    // },\n    'xdemo': {\n      multiple: false,\n      boolean: true,\n      describe: 'Builds a KSS demo.',\n      default: false\n    },\n    // Prevent yargs from complaining about JSON comments in the config file.\n    '//': {\n      describe: 'JSON configurations will ignore comments.'\n    }\n  });\n\n  // The interaction between Yargs and KssConfig is persnickety, so we extend\n  // both objects to add convenience methods to handle the details.\n  yargs.parseKssOptions = function() {\n    // First 2 args are \"node\" and path to kss-node script; we don't need them.\n    return yargs(argv.slice(2))\n      // Yargs needs the options that kssConfig has collected.\n      .options(kssConfig.options);\n  };\n  kssConfig.setFromYargs = function() {\n    this.set(yargs.parseKssOptions().argv);\n  };\n\n  // Get the config passed from CLI's argv.\n  kssConfig.setFromYargs();\n\n  // If the demo is requested, load the settings from its config file.\n  if (kssConfig.get('xdemo')) {\n    // Add the configuration file to the raw arguments list; otherwise, Yargs\n    // won't read the config from the JSON file.\n    argv.push('--config', path.join(__dirname, '../demo/kss-config.json'));\n    kssConfig.setFromYargs();\n    stdout.write('WELCOME to the kss-node demo! We\\'ve turned on the --verbose flag so you can see what kss-node is doing.' + '\\n');\n\n  } else {\n    // Check if there are unnamed parameters.\n    positionalParams = kssConfig.get('_');\n    if (positionalParams.length > 0) {\n      // Check if the destination is the second unnamed parameter.\n      if (positionalParams.length > 1) {\n        argv.push('--destination', positionalParams[1]);\n      }\n\n      // The source directory is the first unnamed parameter.\n      argv.push('--source', positionalParams[0]);\n\n      kssConfig.setFromYargs();\n    }\n  }\n\n  // Based on the template location specified in the kssConfig, load the\n  // requested template's generator.\n  generator = kssConfig.loadGenerator();\n\n  // Set the logging function of the generator.\n  generator.setLogFunction(function() {\n    var message = '';\n    for (var i = 0; i < arguments.length; i++) {\n      message += arguments[i];\n    }\n    stdout.write(message + '\\n');\n  });\n\n  // Set up an error handling function.\n  logError = function(error) {\n    // Show the full error stack if the verbose flag is used.\n    if (kssConfig.get('verbose')) {\n      stderr.write(error + '\\n');\n    } else {\n      stderr.write('Error: ' + error.message + '\\n');\n    }\n    return done(error);\n  };\n\n  // After the generator is loaded, kssConfig finally knows all the options, so\n  // we tell yargs to ensure strictness (i.e. complain if the user tries to\n  // configure a non-existant option.\n  kssConfig.set(yargs\n    .parseKssOptions()\n    // And make a help option available.\n    .usage('Usage: kss-node [options]')\n    .help('help')\n      .alias('help', 'h')\n      .alias('help', '?')\n    .version(version, 'version')\n    .strict()\n    .wrap(yargs.terminalWidth())\n    .argv\n  );\n\n  // If no settings given, display help and exit.\n  if (argv.slice(2).length === 0) {\n    generator.log(yargs.help());\n    return done(null);\n  }\n\n  // Clean up paths and massage settings to expected types.\n  kssConfig.normalize();\n\n  // If we are building the demo, copy the styles.css file to the destination.\n  if (kssConfig.get('xdemo')) {\n    fs.copy(path.resolve(__dirname, '../demo/styles.css'), path.resolve(kssConfig.get('destination'), 'styles.css'), {clobber: true}, function(error) {\n      if (error) {\n        return logError(error);\n      }\n    });\n  }\n\n  // If requested, clone a template and exit.\n  if (kssConfig.get('clone')) {\n    generator.log('Creating a new style guide template...');\n\n    generator.clone(kssConfig.get('template'), kssConfig.get('clone'), function(error) {\n      if (error) {\n        return logError(error);\n      }\n\n      generator.log('You can change it as you like, and use it with your style guide like so:');\n      generator.log('kss-node [sourcedir] --template ' + kssConfig.get('clone'));\n\n      // We're done early!\n      return done(null);\n    });\n\n    // generator.clone() is async and we don't want cli() to continue.\n    return;\n  }\n\n  // If no source is specified, display help and exit.\n  if (!kssConfig.get('source').length) {\n    return logError(new Error('No --source specified. Use --help for instructions on proper usage.'));\n  }\n\n  // Initialize the generator.\n  /* eslint-disable max-nested-callbacks */\n  generator.init(kssConfig.config, function(error) {\n    if (error) {\n      return logError(error);\n    }\n\n    // Then traverse the source and parse the files found.\n    generator.parse(function(error, styleguide) {\n      if (error) {\n        return logError(error);\n      }\n\n      // Then allow the template to prepare itself and the KssStyleguide object.\n      generator.prepare(styleguide, function(error, styleguide) {\n        if (error) {\n          return logError(error);\n        }\n\n        // Then generate the style guide.\n        generator.generate(styleguide, function(error) {\n          if (error) {\n            return logError(error);\n          }\n          if (kssConfig.get('verbose')) {\n            generator.log('');\n          }\n          generator.log('Style guide generation completed successfully!');\n\n          return done(null);\n        });\n      });\n    });\n  });\n};\n\nmodule.exports = cli;\n","/home/travis/build/npmtest/node-npmtest-kss/node_modules/kss/lib/kss_config.js":"'use strict';\n\n/**\n * The `kss/lib/kss_config` module is normally accessed via the\n * [`KssConfig()`]{@link module:kss.KssConfig} constructor of the `kss`\n * module:\n * ```\n * var kss = require('kss');\n * var kssConfig = new kss.KssConfig(data);\n * ```\n * @private\n * @module kss/lib/kss_config\n */\n\nvar path = require('path');\n\nvar KssConfig,\n  coreOptions,\n  resolveArray;\n\n/* eslint-disable key-spacing */\ncoreOptions = {\n  source: {\n    group:    'File locations:',\n    string:   true,\n    path:     true,\n    describe: 'Source directory to parse for KSS comments'\n  },\n  destination: {\n    group:    'File locations:',\n    string:   true,\n    path:     true,\n    multiple: false,\n    describe: 'Destination directory of generated style guide',\n    default:  'styleguide'\n  },\n  mask: {\n    group:    'File locations:',\n    alias:    'm',\n    string:   true,\n    multiple: false,\n    describe: 'Use a mask for detecting files containing KSS comments',\n    default:  '*.css|*.less|*.sass|*.scss|*.styl|*.stylus'\n  },\n  config: {\n    group:    'File locations:',\n    alias:    'c',\n    config:   true,\n    multiple: false,\n    describe: 'Load the kss-node configuration from a json file'\n  },\n\n  clone: {\n    group:    'Template:',\n    alias:    ['init', 'i'],\n    string:   true,\n    path:     true,\n    multiple: false,\n    describe: 'Clone a style guide template to customize'\n  },\n  template: {\n    group:    'Template:',\n    alias:    't',\n    string:   true,\n    path:     true,\n    multiple: false,\n    describe: 'Use a custom template to build your style guide',\n    default:  path.relative(process.cwd(), path.join(__dirname, '../generator/handlebars/template'))\n  },\n  css: {\n    group:    'Style guide:',\n    string:   true,\n    describe: 'URL of a CSS file to include in the style guide'\n  },\n  js: {\n    group:    'Style guide:',\n    string:   true,\n    describe: 'URL of a JavaScript file to include in the style guide'\n  },\n  custom: {\n    group:    'Style guide:',\n    string:   true,\n    describe: 'Process a custom property name when parsing KSS comments'\n  },\n\n  verbose: {\n    count:    true,\n    multiple: false,\n    describe: 'Display verbose details while generating'\n  }\n};\n/* eslint-enable key-spacing */\n\n/**\n * A KssConfig object stores configuration settings needed when generating a KSS\n * style guide.\n *\n * It also validates the settings against the known set of options for the\n * configured template and its generator. And makes it easy to load the template\n * and its generator.\n *\n * @constructor\n * @alias module:kss.KssConfig\n * @param {Object} config An object of config settings to store.\n */\nKssConfig = function(config) {\n  if (!(this instanceof KssConfig)) {\n    return new KssConfig();\n  }\n  this.options = coreOptions;\n  this.config = {};\n  if (config) {\n    this.set(config);\n  }\n};\n\n/**\n * Stores the given config settings.\n *\n * @param {Object} config An object of config settings to store.\n */\nKssConfig.prototype.set = function(config) {\n  var key;\n  for (key in config) {\n    // istanbul ignore else\n    if (config.hasOwnProperty(key)) {\n      this.config[key] = config[key];\n    }\n  }\n};\n\n/**\n * Returns the requested configuration setting or, if no key is specified, an\n * object containing all settings.\n *\n * @param {string} key Optional name of config setting to return.\n * @returns {string|Object} The specified setting or an object of all settings.\n */\nKssConfig.prototype.get = function(key) {\n  return key ? this.config[key] : this.config;\n};\n\n/**\n * Adds additional configuration options to the core kss-node options.\n *\n * Since kss-node is extendable, generators and templates can provide their own\n * options for configuration.\n *\n * @param {object} options An object of configuration options.\n */\nKssConfig.prototype.addOptions = function(options) {\n  var key;\n  for (key in options) {\n    // istanbul ignore else\n    if (options.hasOwnProperty(key)) {\n      this.options[key] = options[key];\n    }\n  }\n};\n\n/**\n * Adds the configuration settings from the given JSON file.\n *\n * @param {string} filename The path to the JSON file.\n */\nKssConfig.prototype.loadJSON = function(filename) {\n  filename = path.resolve(filename);\n  var config = require(filename);\n\n  this.set({\n    // Save the full path to the config file.\n    config: filename,\n    // Store the list of config file keys for later.\n    configFileKeys: Object.keys(config)\n  });\n  this.set(config);\n};\n\n/**\n * Normalizes the configuration object so that it is easy to use inside KSS.\n *\n * The options specified in the KssConfig object will determine how its\n * configuration will be normalized.\n *\n * If an option object has a:\n * - `multiple` property: if set to `false`, the corresponding configuration\n *   will be normalized to a single value. Otherwise, it will be normalized to\n *   an array of values.\n * - `path` property: if set to `true`, the corresponding configuration will be\n *   normalized to a path, relative to the current working directory or, if\n *   given, the location of the JSON config file.\n */\nKssConfig.prototype.normalize = function() {\n  var key;\n\n  // If some of the options were specified in a JSON config file, determine\n  // which ones by loading the keys from the config file.\n  if (typeof this.config.configFileKeys === 'undefined') {\n    if (this.config.config) {\n      // Save the full path to the config file.\n      this.config.config = path.resolve(this.config.config);\n      // Store the list of config file keys for later.\n      this.config.configFileKeys = Object.keys(require(this.config.config));\n    } else {\n      this.config.configFileKeys = [];\n    }\n  }\n\n  // Allow --clone to be used without a path. We can't specify this default path\n  // in coreOptions or the clone flag would always be \"on\".\n  if (this.config['clone'] === '') {\n    this.config['clone'] = 'custom-template';\n  }\n\n  // Normalize all the configuration settings.\n  for (key in this.config) {\n    if (typeof this.options[key] !== 'undefined') {\n      // \"multiple\" defaults to true.\n      if (typeof this.options[key].multiple === 'undefined') {\n        this.options[key].multiple = true;\n      }\n      // \"path\" defaults to false.\n      if (typeof this.options[key].path === 'undefined') {\n        this.options[key].path = false;\n      }\n      // If an option is specified multiple times, yargs will convert it into an\n      // array, but leave it as a string otherwise. This makes accessing the\n      // values of options inconsistent, so make all other options an array.\n      if (this.options[key].multiple) {\n        if (!(this.config[key] instanceof Array)) {\n          if (typeof this.config[key] === 'undefined') {\n            this.config[key] = [];\n          } else {\n            this.config[key] = [this.config[key]];\n          }\n        }\n      } else {\n        // For options marked as \"multiple: false\", use the last value\n        // specified, ignoring the others.\n        if (this.config[key] instanceof Array) {\n          this.config[key] = this.config[key].pop();\n        }\n      }\n      // Resolve any paths relative to the config file or to the working\n      // directory.\n      if (this.options[key].path && (typeof this.config[key] === 'string' || this.config[key] instanceof Array)) {\n        if (this.config.configFileKeys.indexOf(key) > -1) {\n          this.config[key] = resolveArray(path.dirname(this.config.config), this.config[key]);\n        } else {\n          this.config[key] = resolveArray(this.config[key]);\n        }\n      }\n    }\n  }\n};\n\n/**\n * Loads a generator object based on the previously-set configuration.\n *\n * @returns {object} The generator object\n */\nKssConfig.prototype.loadGenerator = function() {\n  var template,\n    generator,\n    self = this;\n\n  // Clean up paths and massage options to expected types.\n  this.normalize();\n\n  // Load the template's generator.\n  try {\n    template = require(this.config.template);\n    generator = template.generator;\n  } catch (e) {\n    // Templates don't have to load their own generator. If the template fails\n    // to load a generator, we assume it wanted the default generator.\n    generator = require('../generator/handlebars');\n  }\n\n  // Confirm this is a compatible generator.\n  return generator.checkGenerator(function(error) {\n    if (error) {\n      return error;\n    }\n\n    // Load the generator's and the template's CLI options.\n    // istanbul ignore else\n    if (Object.keys(generator.options).length) {\n      self.addOptions(generator.options);\n    }\n    if (template && template.options && Object.keys(template.options).length) {\n      self.addOptions(template.options);\n    }\n\n    return generator;\n  });\n};\n\n/**\n * Applies path.resolve() to the given path or array of paths.\n *\n * Helper function for KssConfig.normalize().\n *\n * @private\n * @param {string}        from  Optional path to resolve the \"to\" path\n * @param {string|array}  to    Relative path(s) to resolve.\n * @returns {string|array} The absolute path(s).\n */\nresolveArray = function(from, to) {\n  var paths = [];\n  // \"from\" is optional.\n  if (typeof to === 'undefined') {\n    to = from;\n    from = '';\n  }\n  if (to instanceof Array) {\n    to.forEach(function(value, index) {\n      paths[index] = path.resolve(from, value);\n    });\n  } else {\n    paths = path.resolve(from, to);\n  }\n  return paths;\n};\n\nmodule.exports = KssConfig;\n","/home/travis/build/npmtest/node-npmtest-kss/node_modules/kss/bin/kss-node":"#!/usr/bin/env node\n\n/* eslint-disable no-process-exit */\n\n'use strict';\n\nvar cli = require('../lib/cli');\n\ncli({\n  stdin: process.stdin,\n  stdout: process.stdout,\n  stderr: process.stderr,\n  argv: process.argv\n}, function(error) {\n  process.exit(error ? 1 : 0);\n});\n","/home/travis/build/npmtest/node-npmtest-kss/node_modules/kss/generator/kss_generator.js":"'use strict';\n\n/**\n * The `kss/generator` module loads the {@link KssGenerator} class constructor.\n * ```\n * var KssGenerator = require('kss/generator');\n * ```\n * @module kss/generator\n */\n\n/* **************************************************************\n   See kss_example_generator.js for how to implement a generator.\n   ************************************************************** */\n\nvar Kss = require('../lib/kss.js'),\n  wrench = require('wrench');\n\nvar KssGenerator;\n\n/**\n * Create a KssGenerator object.\n *\n * This is the base object used by all kss-node generators. Implementations of\n * KssGenerator MUST pass the version parameter. kss-node will use this to\n * ensure that only compatible generators are used.\n *\n * ```\n * var KssGenerator = require('kss/generator');\n * var customGenerator = new KssGenerator('2.1');\n * ```\n *\n * @constructor\n * @alias KssGenerator\n * @param {string} version The generator API version implemented.\n * @param {object} options The Yargs-like options this generator has.\n *   See https://github.com/bcoe/yargs/blob/master/README.md#optionskey-opt\n */\nmodule.exports = KssGenerator = function(version, options) {\n  if (!(this instanceof KssGenerator)) {\n    return new KssGenerator();\n  }\n\n  // Tell generators which generator API version is currently running.\n  this.API = '2.1';\n\n  // Store the version of the generator API that the generator instance is\n  // expecting; we will verify this in checkGenerator().\n  this.implementsAPI = typeof version === 'undefined' ? 'undefined' : version;\n\n  // Tell kss-node which Yargs-like options this generator has.\n  this.options = options || {};\n\n  // The log function defaults to console.log.\n  this.setLogFunction(console.log);\n};\n\n/**\n * Logs a message to be reported to the user.\n *\n * Since a generator can be used in places other than the console, using\n * console.log() is inappropriate. The log() method should be used to pass\n * messages to the KSS system so it can report them to the user.\n *\n * @param {string} message The message to log.\n */\nKssGenerator.prototype.log = function() {\n  this.logFunction.apply(null, arguments);\n};\n\n/**\n * The log() method logs a message for the user. This method allows the system\n * to define the underlying function used by the log method to report the\n * message to the user. The default log function is a wrapper around\n * console.log().\n *\n * @param {Function} logFunction Function to log a message to the user.\n */\nKssGenerator.prototype.setLogFunction = function(logFunction) {\n  this.logFunction = logFunction;\n};\n\n/**\n * Checks the generator configuration.\n *\n * An instance of KssGenerator MUST NOT override this method. A process\n * controlling the generator should call this method to verify the\n * specified generator has been configured correctly.\n *\n * @alias KssGenerator.prototype.checkGenerator\n * @param {Function} cb Callback that will be given an Error as its first\n *                      parameter, if one occurs.\n * @returns {*} The callback's return value.\n */\nKssGenerator.prototype.checkGenerator = function(cb) {\n  var isCompatible = true,\n    version,\n    apiMajor,\n    apiMinor,\n    thisMajor,\n    thisMinor,\n    error;\n\n  cb = cb || /* istanbul ignore next */ function() {};\n\n  if (!(this instanceof KssGenerator)) {\n    error = new Error('The loaded generator is not a KssGenerator object.');\n    // istanbul ignore if: API 2.0 is deprecated; remove in 3.x\n    if (this.implementsAPI === '2.0') {\n      throw error;\n    } else {\n      return cb(error);\n    }\n  }\n\n  if (this.implementsAPI === 'undefined') {\n    isCompatible = false;\n  } else {\n    version = this.API.split('.');\n    apiMajor = parseInt(version[0]);\n    apiMinor = parseInt(version[1]);\n\n    version = this.implementsAPI.split('.');\n    thisMajor = parseInt(version[0]);\n    thisMinor = parseInt(version[1]);\n\n    if (thisMajor !== apiMajor || thisMinor > apiMinor) {\n      isCompatible = false;\n    }\n  }\n\n  if (!isCompatible) {\n    error = new Error('kss-node expected the template\\'s generator to implement KssGenerator API version ' + this.API + '; version \"' + this.implementsAPI + '\" is being used instead.');\n    // istanbul ignore if: API 2.0 is deprecated; remove in 3.x\n    if (this.implementsAPI === '2.0') {\n      throw error;\n    } else {\n      return cb(error);\n    }\n  }\n\n  return cb(null);\n};\n\n/**\n * Clone a template's files.\n *\n * This method is fairly simple; it copies one directory to the specified\n * location. An instance of KssGenerator does not need to override this method,\n * but it can if it needs to do something more complicated.\n *\n * @alias KssGenerator.prototype.clone\n * @param {string} templatePath    Path to the template to clone.\n * @param {string} destinationPath Path to the destination of the newly cloned\n *                                 template.\n * @param {Function} cb Callback that will be given an Error as its first\n *                      parameter, if one occurs.\n * @returns {*} The callback's return value.\n */\nKssGenerator.prototype.clone = function(templatePath, destinationPath, cb) {\n  var self = this;\n\n  cb = cb || /* istanbul ignore next */ function() {};\n\n  return wrench.copyDirRecursive(\n    templatePath,\n    destinationPath,\n    {\n      forceDelete: false,\n      excludeHiddenUnix: true\n    },\n    function(error) {\n      if (error) {\n        // istanbul ignore else\n        if (error.message === 'You are trying to delete a directory that already exists. Specify forceDelete in an options object to override this.') {\n          error = new Error('This folder already exists: ' + destinationPath);\n        }\n        // istanbul ignore if: API 2.0 is deprecated; remove in 3.x\n        if (self.implementsAPI === '2.0') {\n          // istanbul ignore next: API 2.0 is deprecated; remove in 3.x\n          throw error;\n        } else {\n          return cb(error);\n        }\n      }\n      return cb(null);\n    }\n  );\n};\n\n/**\n * Initialize the style guide creation process.\n *\n * This method is given a configuration JSON object with the details of the\n * requested style guide generation. The generator can use this information for\n * any necessary tasks before the KSS parsing of the source files.\n *\n * @alias KssGenerator.prototype.init\n * @param {Object} config Configuration object for the requested generation.\n * @param {Function} cb Callback that will be given an Error as its first\n *                      parameter, if one occurs.\n * @returns {*} The callback's return value.\n */\nKssGenerator.prototype.init = function(config, cb) {\n  cb = cb || /* istanbul ignore next */ function() {};\n\n  // At the very least, generators MUST save the configuration parameters.\n  this.config = config;\n\n  return cb(null);\n};\n\n/**\n * Parse the source files for KSS comments and create a KssStyleguide object.\n *\n * When finished, it passes the completed KssStyleguide to the given callback.\n *\n * @alias KssGenerator.prototype.parse\n * @param {Function} cb Callback that will be given an Error as its first\n *                      parameter, if one occurs, and a fully-populated\n *                      KssStyleguide as its second parameter.\n * @returns {*} The callback's return value.\n */\nKssGenerator.prototype.parse = function(cb) {\n  var traverseCallback;\n\n  // istanbul ignore if: API 2.0 is deprecated; remove in 3.x\n  if (this.implementsAPI === '2.0') {\n    // For API 2.0, the callback did pass errors to the callback.\n    traverseCallback = function(err, styleguide) {\n      if (err) {\n        throw err;\n      }\n      return cb(styleguide);\n    };\n  } else {\n    traverseCallback = cb;\n  }\n\n  if (this.config.verbose) {\n    this.log('...Parsing your style guide:');\n  }\n\n  // The default parse() method looks at the paths to the source folders and\n  // uses KSS' traverse method to load, read and parse the source files. Other\n  // generators may want to use KSS' parse method if they have already loaded\n  // the source files through some other mechanism.\n  return Kss.traverse(this.config.source, {\n    multiline: true,\n    markdown: true,\n    markup: true,\n    mask: this.config.mask,\n    custom: this.config.custom\n  }, traverseCallback);\n};\n\n/**\n * Allow the template to prepare itself or modify the KssStyleguide object.\n *\n * @alias KssGenerator.prototype.prepare\n * @param {KssStyleguide} styleguide The KSS style guide in object format.\n * @param {Function} cb Callback that will be given an Error as its first\n *                      parameter, if one occurs, and a fully-populated\n *                      KssStyleguide as its second parameter.\n * @returns {*} The callback's return value.\n */\nKssGenerator.prototype.prepare = function(styleguide, cb) {\n  return cb(null, styleguide);\n};\n\n/**\n * Generate the HTML files of the style guide given a KssStyleguide object.\n *\n * @alias KssGenerator.prototype.generate\n * @param {KssStyleguide} styleguide The KSS style guide in object format.\n * @param {Function} cb Callback that will be given an Error as its first\n *                      parameter, if one occurs.\n * @returns {*} The callback's return value.\n */\nKssGenerator.prototype.generate = function(styleguide, cb) {\n  cb = cb || /* istanbul ignore next */ function() {};\n\n  return cb(null);\n};\n","/home/travis/build/npmtest/node-npmtest-kss/node_modules/kss/lib/kss_modifier.js":"'use strict';\n\n/**\n * The `kss/lib/kss_modifier` module is normally accessed via the\n * [`KssModifier()`]{@link module:kss.KssModifier} constructor of the `kss`\n * module:\n * ```\n * var kss = require('kss');\n * var modifier = new kss.KssModifier(data);\n * ```\n * @private\n * @module kss/lib/kss_modifier\n */\n\nvar KssModifier;\n\n/**\n * An instance of this class is returned on calling `KssSection.modifier`.\n * Exposes convenience methods for interpreting data.\n *\n * @constructor\n * @alias module:kss.KssModifier\n * @param {Object} data A part of the data object passed on by `KssSection`.\n */\nKssModifier = function(data) {\n  if (!(this instanceof KssModifier)) {\n    return new KssModifier();\n  }\n  this.data = data || {};\n  this.init();\n};\n\n/**\n * Initializes the object and data passed to the constructor. Called\n * automatically from the KssModifier() constructor; should not be called\n * directly.\n * @private\n */\nKssModifier.prototype.init = function() {\n  this.data.section = this.data.section || null;\n  this.data.name = this.data.name || '';\n  this.data.description = this.data.description || '';\n  this.data.className = this.data.className || false;\n};\n\n/**\n * Returns the `KssSection` object this modifier is associated with.\n * @returns {KssSection} The style guide section the modifier belongs to.\n */\nKssModifier.prototype.section = function() {\n  return this.data.section;\n};\n\n/**\n * Returns the name of the modifier, e.g. `:hover`, `.primary`, etc.\n * @returns {string} The name of the modifier.\n */\nKssModifier.prototype.name = function() {\n  return this.data.name;\n};\n\n/**\n * Returns the description of the modifier.\n * @returns {string} The description of the modifier.\n */\nKssModifier.prototype.description = function() {\n  return this.data.description;\n};\n\n/**\n * Returns the class name of the modifier.\n * @returns {string} The class name of the modifier.\n */\nKssModifier.prototype.className = function() {\n  var className = this.data.className;\n\n  if (!className) {\n    return false;\n  }\n\n  // Only get the first class combination -\n  // Markup should not be multiple elements deep at this stage.\n  className = className.split(/\\s/);\n\n  // Split into space-separated classes for inclusion\n  // in templates etc.\n  className = className[0]\n    .replace(/\\./g, ' ')\n    .replace(/^\\s*/g, '');\n\n  return className;\n};\n\n/**\n * Returns the HTML markup used to render this modifier.\n * @returns {string} The markup of the modifier.\n */\nKssModifier.prototype.markup = function() {\n  if (!this.data.section) {\n    return '';\n  }\n\n  return (this.data.section.markup() || '');\n};\n\nmodule.exports = KssModifier;\n","/home/travis/build/npmtest/node-npmtest-kss/node_modules/kss/lib/kss_parameter.js":"'use strict';\n\n/**\n * The `kss/lib/kss_parameter` module is normally accessed via the\n * [`KssParameter()`]{@link module:kss.KssParameter} constructor of the `kss`\n * module:\n * ```\n * var kss = require('kss');\n * var parameter = new kss.KssParameter(data);\n * ```\n * @private\n * @module kss/lib/kss_parameter\n */\n\nvar KssParameter;\n\n/**\n * An instance of this class is returned on calling `KssSection.parameter`.\n * Exposes convenience methods for interpreting data.\n *\n * @constructor\n * @alias module:kss.KssParameter\n * @param {Object} data A part of the data object passed on by `KssSection`.\n */\nKssParameter = function(data) {\n  if (!(this instanceof KssParameter)) {\n    return new KssParameter();\n  }\n  this.data = data || {};\n  this.init();\n};\n\n/**\n * Initializes the object and data passed to the constructor. Called\n * automatically from the KssParameter() constructor; should not be called\n * directly.\n * @private\n */\nKssParameter.prototype.init = function() {\n  this.data.section = this.data.section || null;\n  this.data.name = this.data.name || '';\n  this.data.description = this.data.description || '';\n};\n\n/**\n * Returns the KssSection object this parameter is associated with.\n * @returns {KssSection} The style guide section the parameter belongs to.\n */\nKssParameter.prototype.section = function() {\n  return this.data.section;\n};\n\n/**\n * Returns the name of the parameter.\n * @returns {string} The name of the parameter.\n */\nKssParameter.prototype.name = function() {\n  return this.data.name;\n};\n\n/**\n * Returns the description of the parameter.\n * @returns {string} The description of the parameter.\n */\nKssParameter.prototype.description = function() {\n  return this.data.description;\n};\n\nmodule.exports = KssParameter;\n","/home/travis/build/npmtest/node-npmtest-kss/node_modules/kss/lib/kss_section.js":"'use strict';\n\n/**\n * The `kss/lib/kss_section` module is normally accessed via the\n * [`KssSection()`]{@link module:kss.KssSection} constructor of the `kss`\n * module:\n * ```\n * var kss = require('kss');\n * var section = new kss.KssSection(data);\n * ```\n * @private\n * @module kss/lib/kss_section\n */\n\nvar KssSection;\n\n/**\n * An instance of this class is returned on calling `KssStyleguide.section`.\n * Exposes convenience methods for interpreting data.\n *\n * @constructor\n * @alias module:kss.KssSection\n * @param {Object} data A part of the data object passed on by `KssStyleguide`.\n */\nKssSection = function(data) {\n  if (!(this instanceof KssSection)) {\n    return new KssSection();\n  }\n  this.data = data || {};\n  this.init();\n};\n\n/**\n * Initializes the object and data passed to the constructor. Called\n * automatically from the KssSection() constructor; should not be called\n * directly.\n * @private\n */\nKssSection.prototype.init = function() {\n  var self = this;\n\n  this.styleguide = this.data.styleguide || null;\n\n  this.data.header = this.data.header || '';\n  this.data.description = this.data.description || '';\n  this.data.deprecated = this.data.deprecated || false;\n  this.data.experimental = this.data.experimental || false;\n  this.data.reference = this.data.reference || '';\n  this.data.depth = this.data.depth || 0;\n  this.data.weight = this.data.weight || 0;\n  this.data.referenceURI = this.data.referenceURI || '';\n  this.data.markup = this.data.markup || '';\n\n  if (this.data.modifiers) {\n    this.data.modifiers = this.data.modifiers.map(function(modifier) {\n      modifier.data.section = self;\n      return modifier;\n    });\n  } else {\n    this.data.modifiers = [];\n  }\n\n  if (this.data.parameters) {\n    this.data.parameters = this.data.parameters.map(function(parameter) {\n      parameter.data.section = self;\n      return parameter;\n    });\n  } else {\n    this.data.parameters = [];\n  }\n};\n\n/**\n * Return `KssSection` as a JSON object.\n *\n * @param {Array} customProperties A list of custom properties to include in the JSON.\n * @returns {Object} A JSON object representation of the KssSection.\n */\nKssSection.prototype.toJSON = function(customProperties) {\n  var returnObject;\n\n  customProperties = customProperties || [];\n\n  /* eslint-disable key-spacing */\n  returnObject = {\n    header:       this.header(),\n    description:  this.description(),\n    deprecated:   this.deprecated(),\n    experimental: this.experimental(),\n    reference:    this.reference(),\n    depth:        this.depth(),\n    weight:       this.weight(),\n    referenceURI: this.referenceURI(),\n    markup:       this.markup()\n  };\n  /* eslint-enable key-spacing */\n\n  returnObject.modifiers = this.data.modifiers.map(function(modifier) {\n    return {\n      name: modifier.name(),\n      description: modifier.description(),\n      className: modifier.className()\n    };\n  });\n  returnObject.parameters = this.data.parameters.map(function(modifier) {\n    return {\n      name: modifier.name(),\n      description: modifier.description()\n    };\n  });\n\n  // Add custom properties to the JSON object.\n  for (var i = 0; i < customProperties.length; i++) {\n    if (this.data[customProperties[i]]) {\n      returnObject[customProperties[i]] = this.data[customProperties[i]];\n    }\n  }\n\n  return returnObject;\n};\n\n// DEPRECATED; use toJSON() instead.\n/* istanbul ignore next */\nKssSection.prototype.JSON = function(customProperties) {\n  return this.toJSON(customProperties);\n};\n\n/**\n * Returns the header of the section, i.e. the first line in the description.\n * @returns {string} The header of the section.\n */\nKssSection.prototype.header = function() {\n  return this.data.header;\n};\n\n/**\n * Returns the description of the section.\n *\n * Note: If the multiline option is disabled this will include the header also.\n *\n * @returns {string} The description of the section.\n */\nKssSection.prototype.description = function() {\n  return this.data.description;\n};\n\n/**\n * Returns whether the section is deprecated or not.\n * @returns {Boolean} Whether the section is deprecated or not.\n */\nKssSection.prototype.deprecated = function() {\n  return this.data.deprecated;\n};\n\n/**\n * Returns whether the section is experimental or not.\n * @returns {Boolean} Whether the section is experimental or not.\n */\nKssSection.prototype.experimental = function() {\n  return this.data.experimental;\n};\n\n/**\n * Returns the reference of the section.\n * @returns {string} The reference of the section.\n */\nKssSection.prototype.reference = function() {\n  return this.data.reference;\n};\n\n/**\n * Returns the depth of the section.\n * @returns {string} The depth of the section.\n */\nKssSection.prototype.depth = function() {\n  return this.data.depth;\n};\n\n/**\n * Returns the weight of the section.\n * @returns {string} The weight of the section.\n */\nKssSection.prototype.weight = function() {\n  return this.data.weight ? this.data.weight : 0;\n};\n\n/**\n * Encodes the given reference as a valid URI fragment.\n * @param {string} reference A style guide section reference.\n * @returns {string} The reference encoded as a URI.\n */\nKssSection.prototype.encodeReferenceURI = function(reference) {\n  return encodeURI(\n    reference\n      .replace(/ \\- /g, '-')\n      .replace(/[^\\w-]+/g, '-')\n      .toLowerCase()\n  );\n};\n\n/**\n * Returns the reference of the section, encoded as a valid URI fragment.\n * @returns {string} The description of the section.\n */\nKssSection.prototype.referenceURI = function() {\n  return this.data.referenceURI;\n};\n\n/**\n * Returns the markup of the section.\n * @returns {false|string} The markup of the section, or `false` if none.\n */\nKssSection.prototype.markup = function() {\n  return this.data.markup || false;\n};\n\n/**\n * Returns the requested modifier of the section.\n *\n * Different arguments will yield different results:\n *\n * - `modifiers()`: Pass nothing to return all of the section's modifiers in an\n *   array.\n * - `modifiers(n)`: Use a number to return the section's Nth modifier.\n * - `modifiers('name')`: Use a string to return a specific modifer by name.\n *\n * @param {string|int} query The name (string) or 0-based index (int) of the requested modifier.\n * @returns {false|Array} An Array of KssModifier objects, or `false` if none.\n */\nKssSection.prototype.modifiers = function(query) {\n  var number, i, l;\n\n  if (typeof query === 'string') {\n    number = parseFloat(query);\n\n    // If can be converted to a number, convert and search\n    // for the query by index (see below).\n    if (number.toString() === query) {\n      query = number;\n    } else {\n      // Otherwise, search for the modifier by name:\n      l = this.data.modifiers.length;\n      for (i = 0; i < l; i += 1) {\n        if (this.data.modifiers[i].data.name === query) {\n          return this.data.modifiers[i];\n        }\n      }\n      return false;\n    }\n  }\n\n  if (typeof query === 'number') {\n    return this.data.modifiers.length > query ? this.data.modifiers[query] : false;\n  }\n\n  return this.data.modifiers;\n};\n\n/**\n * Returns the first modifier of the section.\n * @returns {false|string} The first modifier of the section, or `false` if none.\n */\nKssSection.prototype.firstModifier = function() {\n  if (this.data.modifiers.length) {\n    return this.data.modifiers[0];\n  } else {\n    return false;\n  }\n};\n\n/**\n * Returns the parameters if the section is a CSS preprocessor function/mixin.\n * @returns {Array} The parameters of the section.\n */\nKssSection.prototype.parameters = function() {\n  return this.data.parameters;\n};\n\nmodule.exports = KssSection;\n","/home/travis/build/npmtest/node-npmtest-kss/node_modules/kss/lib/kss_styleguide.js":"'use strict';\n\n/**\n * The `kss/lib/kss_styleguide` module is normally accessed via the\n * [`KssStyleguide()`]{@link module:kss.KssStyleguide} constructor of the `kss`\n * module:\n * ```\n * var kss = require('kss');\n * var styleGuide = new kss.KssStyleguide(data);\n * ```\n * @private\n * @module kss/lib/kss_styleguide\n */\n\nvar KssStyleguide;\n\n/**\n * An instance of this class is returned on finishing `kss.traverse`. It has a\n * few convenience methods for interpreting data, the most important of which is\n * section() for searching for specific sections of the style guide.\n *\n * @constructor\n * @alias module:kss.KssStyleguide\n * @param {Object} data The data object generated by traverse.\n */\nKssStyleguide = function(data) {\n  if (!(this instanceof KssStyleguide)) {\n    return new KssStyleguide();\n  }\n  this.data = data || {};\n  this.init();\n};\n\n/**\n * Initializes the object and data passed to the constructor. Called\n * automatically from the KssStyleguide() constructor; should not be called\n * directly.\n * @private\n */\nKssStyleguide.prototype.init = function() {\n  var i, l, incrementIndex, autoIncrement = [0], ref, previousRef = [], index;\n\n  // The map of section weights is created on the fly in getWeight().\n  this.data.weightMap = false;\n\n  this.referenceDelimiter = '.';\n\n  if (!this.data.sections) {\n    this.data.sections = [];\n  }\n\n  if (this.data.sections.length) {\n    // Determine the separator used in references; e.g. 'a - b' or 'a.b'.\n    l = this.data.sections.length;\n    for (i = 0; i < l; i += 1) {\n      if (this.data.sections[i].reference().indexOf(' - ') > -1) {\n        this.referenceDelimiter = ' - ';\n        break;\n      }\n    }\n\n    // Set the depth of each section's reference.\n    for (i = 0; i < l; i += 1) {\n      this.data.sections[i].data.depth = this.data.sections[i].data.reference.split(this.referenceDelimiter).length;\n    }\n\n    // Sort all the sections.\n    this.sortSections();\n\n    // Loop through all the sections to initialize some computed values.\n    for (i = 0; i < l; i += 1) {\n      // Set the styleguide property on each KssSection object.\n      this.data.sections[i].styleguide = this;\n\n      ref = this.data.sections[i].reference();\n      // Set the referenceURI value.\n      this.data.sections[i].data.referenceURI = this.data.sections[i].encodeReferenceURI(ref);\n\n      // Compare the previous Ref to the new Ref.\n      ref = ref.split(this.referenceDelimiter);\n      // If they are already equal, we don't need to increment the section number.\n      if (previousRef.join(this.referenceDelimiter) !== ref.join(this.referenceDelimiter)) {\n        incrementIndex = 0;\n        for (index = 0; index < previousRef.length; index += 1) {\n          // Find the index where the refs differ.\n          if (index >= ref.length || previousRef[index] !== ref[index]) {\n            break;\n          }\n          incrementIndex = index + 1;\n        }\n        if (incrementIndex < autoIncrement.length) {\n          // Increment the part where the refs started to differ.\n          autoIncrement[incrementIndex]++;\n          // Trim off the extra parts of the autoincrement where the refs differed.\n          autoIncrement = autoIncrement.slice(0, incrementIndex + 1);\n        }\n        // Add parts to the autoincrement to ensure it is the same length as the new ref.\n        for (index = autoIncrement.length; index < ref.length; index += 1) {\n          autoIncrement[index] = 1;\n        }\n      }\n      this.data.sections[i].data.autoincrement = autoIncrement.join('.');\n      previousRef = ref;\n    }\n  }\n};\n\n/**\n * Search for sections within the style guide.\n *\n * There's a few ways to use this method:\n * - `section()` returns all of the sections.\n *\n * Using strings:\n * - `section('2')` returns Section 2.\n * - `section('2.*')` returns Section 2 and all of its descendants.\n * - `section('2.x')` returns Section 2's children only.\n * - `section('2.x.x')` returns Section 2's children, and their children too.\n *\n * Or Regular Expressions:\n * - `section(/2\\.[1-5]/)` returns Sections 2.1 through to 2.5.\n *\n * @param {string|Regexp} query A string or Regexp object to match a KssSection's style guide reference.\n * @returns {false|KssSection|Array} The exact KssSection requested, an array of KssSection objects matching the query, or false.\n */\nKssStyleguide.prototype.section = function(query) {\n  var i, l = this.data.sections.length,\n    current, isRegexSearch, delim,\n    sections = [],\n    match;\n\n  query = query || /.+/;\n\n  // Exact queries.\n  if (typeof query === 'string') {\n    // If the query is '*', 'x', or ends with '.*', ' - *', '.x', or ' - x',\n    // then it is not an exact query.\n    isRegexSearch = query.match(/(^[x\\*]$|\\s\\-\\s[x\\*]$|\\.[x\\*]$)/);\n    if (!isRegexSearch) {\n      if (this.data.section_refs && this.data.section_refs[query]) {\n        return this.data.section_refs[query];\n      } else {\n        return false;\n      }\n    }\n  }\n\n  // Convert regex strings into proper JavaScript RegExp objects.\n  if (!(query instanceof RegExp)) {\n    delim = this.referenceDelimiter === '.' ? '\\\\.' : '\\\\ \\\\-\\\\ ';\n    query = new RegExp(\n      query\n        // Convert '*' to a simple .+ regex.\n        .replace(/^\\*$/, '.+')\n        // Convert 'x' to a regex matching one level of reference.\n        .replace(/^x$/, '^.+?(?=($|' + delim + '))')\n        // Convert '.*' or ' - *' to a ([delim].+){0,1} regex.\n        .replace(/(\\.|\\s+\\-\\s+)\\*$/g, '(' + delim + '.+){0,1}')\n        // Convert the first '.x' or ' - x' to a regex matching one sub-level\n        // of a reference.\n        .replace(/(\\.|\\s+\\-\\s+)x\\b/, delim + '.+?(?=($|' + delim + '))')\n        // Convert any remaining '.x' or ' - x' to a regex matching zero or one\n        // sub-levels of a reference.\n        .replace(/(\\.|\\s+\\-\\s+)x\\b/g, '(' + delim + '.+?(?=($|' + delim + '))){0,1}')\n        // Convert any remaining '-' into '\\-'\n        .replace(/([^\\\\])\\-/g, '$1\\\\-')\n    );\n  }\n\n  // General (regex) search\n  for (i = 0; i < l; i += 1) {\n    current = this.data.sections[i];\n    match = current.data.reference.match(query);\n    if (match && match[0] === current.data.reference) {\n      sections.push(current);\n    }\n  }\n\n  /* @TODO An empty array is always true, so this code is never run.\n    Do we want to add it back (properly) in 3.x?\n  if (!sections) {\n    return false;\n  }\n  */\n\n  return sections;\n};\n\n/**\n * Sorts the sections of the style guide.\n *\n * This is called automatically when the {@link KssStyleguide} object is\n * created, but is publicly accessible as well.\n */\nKssStyleguide.prototype.sortSections = function() {\n  var self = this;\n\n  // Sort sections based on reference number.\n  this.data.sections.sort(function(a, b) {\n    // Split the 2 references into chunks by their period or dash seperators.\n    var refsA = a.data.reference.toLowerCase().split(self.referenceDelimiter),\n      refsB = b.data.reference.toLowerCase().split(self.referenceDelimiter),\n      weightA, weightB,\n      i, l = Math.max(refsA.length, refsB.length);\n\n    // Compare each set of chunks until we know which reference should be listed first.\n    for (i = 0; i < l; i += 1) {\n      if (refsA[i] && refsB[i]) {\n        // If the 2 chunks are unequal, compare them.\n        if (refsA[i] !== refsB[i]) {\n          // If the chunks have different weights, sort by weight.\n          weightA = self.getWeight(a.reference(), i);\n          weightB = self.getWeight(b.reference(), i);\n          if (weightA !== weightB) {\n            return weightA - weightB;\n          } else if (refsA[i].match(/^\\d+$/) && refsB[i].match(/^\\d+$/)) {\n            // If both chunks are digits, use numeric sorting.\n            return refsA[i] - refsB[i];\n          } else {\n            // Otherwise, use alphabetical string sorting.\n            return (refsA[i] > refsB[i]) ? 1 : -1;\n          }\n        }\n      } else {\n        // If 1 of the chunks is empty, it goes first.\n        return refsA[i] ? 1 : -1;\n      }\n    }\n\n    return 0;\n  });\n};\n\n/**\n * Helper function for `KssStyleguide.sortSections()` that gets the weight of\n * the given reference at the given depth.\n *\n * For example, `styleguide.getWeight('4.3.2.2', 2)` will return the weight for\n * section 4.3.\n *\n * @param {string} reference A section reference.\n * @param {int} depth The requested depth (optional).\n * @returns {int} The requested weight.\n */\nKssStyleguide.prototype.getWeight = function(reference, depth) {\n  // Initialize the map of weights.\n  if (this.data.weightMap === false) {\n    this.data.weightMap = {};\n    for (var key in this.data.sections) {\n      /* istanbul ignore else */\n      if (this.data.sections.hasOwnProperty(key)) {\n        this.data.weightMap[this.data.sections[key].reference().toLowerCase()] = this.data.sections[key].weight();\n      }\n    }\n  }\n\n  reference = reference.toLowerCase();\n  if (typeof depth !== 'undefined') {\n    reference = reference.split(this.referenceDelimiter, depth + 1).join(this.referenceDelimiter);\n  }\n\n  return this.data.weightMap[reference] ? this.data.weightMap[reference] : 0;\n};\n\nmodule.exports = KssStyleguide;\n","/home/travis/build/npmtest/node-npmtest-kss/node_modules/kss/lib/parse.js":"/* eslint-disable camelcase */\n\n'use strict';\n\n/**\n * The `kss/lib/parse` module is normally accessed via the\n * [`parse()`]{@link module:kss.parse} method of the `kss` module:\n * ```\n * var kss = require('kss');\n * kss.parse(input, options, callback);\n * ```\n * @private\n * @module kss/lib/parse\n */\n\nvar KssStyleguide = require('./kss_styleguide.js'),\n  KssSection = require('./kss_section.js'),\n  KssModifier = require('./kss_modifier.js'),\n  KssParameter = require('./kss_parameter.js'),\n  marked = require('marked'),\n  natural = require('natural');\n\nvar inlineRenderer,\n  parse, parseChunk, createModifiers, createParameters, checkReference, findBlocks, processProperty,\n  isDeprecated, isExperimental, hasPrefix;\n\n// Create a MarkDown renderer that does not output a wrapping paragraph.\ninlineRenderer = new marked.Renderer();\ninlineRenderer.paragraph = function(text) {\n  return text;\n};\n\n/**\n * Parse an array/string of documented CSS, or an object of files\n * and their content.\n *\n * File object formatted as `{ \"absolute filename\": content, ... }`.\n *\n * This is called automatically as part of `traverse` but is publicly\n * accessible as well.\n *\n * @alias module:kss.parse\n * @param  {Mixed}    input    The input to parse\n * @param  {Object}   options  Options to alter the output content. Same as the options in [`traverse()`]{@link module:kss.traverse}.\n * @param  {Function} callback Called when parsing is complete\n */\nparse = function(input, options, callback) {\n  var data = {}, fileName, files,\n    i, l;\n\n  // If supplied a string, just make it an Array.\n  if (typeof input === 'string') {\n    input = [input];\n  }\n\n  // Otherwise assume the input supplied is a JSON object, as specified above.\n  if (!Array.isArray(input)) {\n    files = input;\n    input = [];\n    data.files = [];\n    for (fileName in files) {\n      // istanbul ignore else\n      if (files.hasOwnProperty(fileName)) {\n        input.push(files[fileName]);\n        data.files.push(fileName);\n      }\n    }\n    data.files.sort();\n  }\n\n  // Default parsing options\n  if (typeof options.markdown === 'undefined') {\n    options.markdown = true;\n  }\n  if (typeof options.multiline === 'undefined') {\n    options.multiline = true;\n  }\n  options.typos = options.typos || false;\n  options.custom = options.custom || [];\n\n  // Actually parse the input (parseChunk is the key function here.)\n  l = input.length;\n  data.sections = [];\n  data.section_refs = {};\n\n  for (i = 0; i < l; i += 1) {\n    data = parseChunk(data, input[i], options);\n  }\n\n  callback(null, new KssStyleguide(data));\n};\n\n/**\n * Take a chunk of text and parse the comments. This is the primary parsing\n * function, and eventually returns a `data` variable to use to create a new\n * instance of `KssStyleguide`.\n *\n * @private\n * @param  {Object} data    JSON object containing all of the style guide data.\n * @param  {String} input   Text to be parsed, i.e. a single CSS/LESS/etc. file's content.\n * @param  {Object} options The options passed on from `traverse` or `parse`\n * @returns {Object} The raw style guide data from the newly parsed text.\n */\nparseChunk = function(data, input, options) {\n  /* jshint loopfunc: true */\n\n  var currSection, i, l, blocks = [], paragraphs, j, m, hasModifiers, lastModifier;\n\n  // Append the raw text to the body string.\n  data.body = data.body || '';\n  data.body += '\\n\\n';\n  data.body += input;\n\n  // Retrieve an array of \"comment block\" strings, and then evaluate each one.\n  blocks = findBlocks(input);\n  l = blocks.length;\n\n  for (i = 0; i < l; i += 1) {\n    // Create a new, temporary section object with some default values.\n    // \"raw\" is a comment block from the array above.\n    currSection = {\n      raw: blocks[i],\n      header: '',\n      description: '',\n      modifiers: [],\n      parameters: [],\n      markup: false\n    };\n\n    // Split the comment block into paragraphs.\n    paragraphs = currSection.raw\n      .replace(/\\r\\n/g, '\\n')      // Convert Windows CRLF linebreaks.\n      .replace(/\\r/g, '\\n')        // Convert Classic Mac CR linebreaks too.\n      .replace(/\\n\\s+\\n/g, '\\n\\n') // Trim whitespace-only lines.\n      .replace(/^\\s+|\\s+$/g, '')   // Trim the string of white space.\n      .split('\\n\\n');\n\n    // Before anything else, process the properties that are clearly labeled and\n    // can be found right away and then removed.\n    currSection = processProperty('Markup', paragraphs, options, currSection);\n    /* eslint-disable no-loop-func */\n    currSection = processProperty('Weight', paragraphs, options, currSection, function(value) {\n      return isNaN(value) ? 0 : parseFloat(value);\n    });\n    // Process custom properties.\n    options.custom.forEach(function(name) {\n      currSection = processProperty(name, paragraphs, options, currSection);\n    });\n    /* eslint-enable no-loop-func */\n\n    // Ignore this block if a styleguide reference number is not listed.\n    currSection.reference = checkReference(paragraphs, options) || '';\n    if (!currSection.reference) {\n      continue;\n    }\n\n    // If the block is 1 paragraph long, copy the reference into the header.\n    if (paragraphs.length === 1) {\n      currSection.header = currSection.reference;\n    // If the block is 2 paragraphs long, it is just a header and a reference.\n    } else if (paragraphs.length === 2) {\n      currSection.header = currSection.description = paragraphs[0];\n    // If it's 3+ paragraphs long, search for modifiers.\n    } else {\n\n      // Extract the approximate header, description and modifiers paragraphs.\n      // The modifiers will be split into an array of lines.\n      currSection.header = paragraphs[0];\n      currSection.description = paragraphs.slice(0, paragraphs.length - 2).join('\\n\\n');\n      currSection.modifiers = paragraphs[paragraphs.length - 2]\n        .split('\\n');\n\n      // Check the modifiers paragraph. Does it look like it's a list of\n      // modifiers, or just another paragraph of the description?\n      m = currSection.modifiers.length;\n      hasModifiers = true;\n      for (j = 0; j < m; j += 1) {\n        if (currSection.modifiers[j].match(/^\\s*.+?\\s+\\-\\s/g)) {\n          lastModifier = j;\n        } else if (j === 0) {\n          // The paragraph doesn't start with a modifier, so bail out.\n          hasModifiers = false;\n          j = m;\n        } else {\n          // If the current line doesn't match a modifier, it must be a\n          // multi-line modifier description.\n          currSection.modifiers[lastModifier] += ' ' + currSection.modifiers[j].replace(/^\\s+|\\s+$/g, '');\n          // We will strip this blank line later.\n          currSection.modifiers[j] = '';\n        }\n      }\n      // Remove any blank lines added.\n      /* eslint-disable no-loop-func */\n      currSection.modifiers = currSection.modifiers.filter(function(line) { return line !== ''; });\n      /* eslint-enable no-loop-func */\n\n      // If it's a modifiers paragraph, turn each one into a modifiers object.\n      // Otherwise, add it back to the description.\n      if (hasModifiers) {\n        // If the current section has markup, create proper KssModifier objects.\n        if (currSection.markup) {\n          currSection.modifiers = createModifiers(currSection.modifiers, options);\n        } else {\n          // If the current section has no markup, create KssParameter objects.\n          currSection.parameters = createParameters(currSection.modifiers, options);\n          currSection.modifiers = [];\n        }\n      } else {\n        currSection.description += '\\n\\n' + paragraphs[paragraphs.length - 2];\n        currSection.modifiers = [];\n      }\n    }\n\n    // Squash the header into a single line.\n    currSection.header = currSection.header.replace(/\\n/g, ' ');\n\n    // Check the section's status.\n    currSection.deprecated = isDeprecated(currSection.description, options);\n    currSection.experimental = isExperimental(currSection.description, options);\n\n    // If multi-line descriptions are allowed, remove the first paragraph (the\n    // header) from the description.\n    if (options.multiline) {\n      if (currSection.description.match(/\\n{2,}/)) {\n        currSection.description = currSection.description.replace(/^.*?\\n{2,}/, '');\n      } else {\n        currSection.description = '';\n      }\n    }\n\n    // Markdown Parsing.\n    if (options.markdown) {\n      currSection.description = marked(currSection.description);\n    }\n\n    // Add the new section instance to the sections array.\n    currSection = new KssSection(currSection);\n    data.sections.push(currSection);\n\n    // Store the reference for quick searching later.\n    data.section_refs[currSection.reference()] = currSection;\n  }\n\n  return data;\n};\n\n/**\n * Takes an array of modifier lines, and turns it into instances of KssModifier.\n *\n * @private\n * @param  {Array}  lines   Modifier lines, which should all be strings.\n * @param  {Object} options Any options passed on by the functions above.\n * @returns {Array} The modifier instances created.\n */\ncreateModifiers = function(lines, options) {\n  return lines.map(function(entry) {\n    var modifier, description, className;\n\n    // Split modifier name and the description.\n    modifier = entry.split(/\\s+\\-\\s+/, 1)[0];\n    description = entry.replace(modifier, '', 1).replace(/^\\s+\\-\\s+/, '');\n\n    className = modifier.replace(/\\:/g, '.pseudo-class-');\n\n    // Markdown parsing.\n    if (options.markdown) {\n      description = marked(description, {renderer: inlineRenderer});\n    }\n\n    return new KssModifier({\n      name: modifier,\n      description: description,\n      className: className\n    });\n  });\n};\n\n/**\n * Takes an array of parameter lines, and turns it into instances of KssParameter.\n *\n * @private\n * @param  {Array}  lines   Parameter lines, which should all be strings.\n * @param  {Object} options Any options passed on by the functions above.\n * @returns {Array} The parameter instances created.\n */\ncreateParameters = function(lines, options) {\n  return lines.map(function(entry) {\n    var parameter, description;\n\n    // Split parameter name and the description.\n    parameter = entry.split(/\\s+\\-\\s+/, 1)[0];\n    description = entry.replace(parameter, '', 1).replace(/^\\s+\\-\\s+/, '');\n\n    // Markdown parsing.\n    if (options.markdown) {\n      description = marked(description, {renderer: inlineRenderer});\n    }\n\n    return new KssParameter({\n      name: parameter,\n      description: description\n    });\n  });\n};\n\n/**\n * Returns an array of comment blocks found within a string.\n *\n * @private\n * @param  {String} input   The string to search.\n * @returns {Array} The blocks found.\n */\nfindBlocks = function(input) {\n  /* eslint-disable key-spacing */\n  var currentBlock = '',\n    insideSingleBlock = false, insideMultiBlock = false, insideDocblock = false,\n    indentAmount = false,\n    blocks = [],\n    lines, line, i, l,\n    commentExpressions = {\n      single:         /^\\s*\\/\\/.*$/,\n      docblockStart:  /^\\s*\\/\\*\\*\\s*$/,\n      multiStart:     /^\\s*\\/\\*+\\s*$/,\n      multiFinish:    /^\\s*\\*\\/\\s*$/\n    };\n  /* eslint-enable key-spacing */\n\n  input = input.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n  lines = input.split(/\\n|$/g);\n\n  l = lines.length;\n  for (i = 0; i < l; i += 1) {\n    line = lines[i];\n\n    // Remove trailing space.\n    line = line.replace(/\\s*$/, '');\n\n    // Single-line parsing.\n    if (!insideMultiBlock && !insideDocblock && line.match(commentExpressions.single)) {\n      if (insideSingleBlock && currentBlock !== '') {\n        currentBlock += '\\n';\n      }\n      currentBlock += line.replace(/^\\s*\\/\\/\\s?/, '');\n      insideSingleBlock = true;\n      continue;\n    }\n\n    // Since the current line is not a single line comment, save the current\n    // block and continue parsing the current line.\n    if (insideSingleBlock) {\n      blocks.push(currentBlock.replace(/^\\n+/, '').replace(/\\n+$/, ''));\n      insideSingleBlock = false;\n      currentBlock = '';\n    }\n\n    // Save the current multi-/docblock if we have reached the end of the block.\n    if ((insideMultiBlock || insideDocblock) && line.match(commentExpressions.multiFinish)) {\n      blocks.push(currentBlock.replace(/^\\n+/, '').replace(/\\n+$/, ''));\n      insideMultiBlock = insideDocblock = false;\n      currentBlock = '';\n      indentAmount = false;\n      continue;\n    }\n\n    // Docblock parsing.\n    if (line.match(commentExpressions.docblockStart)) {\n      insideDocblock = true;\n      currentBlock = '';\n      continue;\n    }\n    if (insideDocblock) {\n      currentBlock += '\\n';\n      currentBlock += line.replace(/^\\s*\\*\\s?/, '');\n      continue;\n    }\n\n    // Multi-line parsing.\n    if (line.match(commentExpressions.multiStart)) {\n      insideMultiBlock = true;\n      currentBlock = '';\n      continue;\n    }\n    if (insideMultiBlock) {\n      // If this is the first interior line, determine the indentation amount.\n      if (indentAmount === false) {\n        // Skip initial blank lines.\n        if (line === '') {\n          continue;\n        }\n        indentAmount = line.match(/^\\s*/)[0];\n      }\n      currentBlock += '\\n';\n      // Always strip same indentation amount from each line.\n      currentBlock += line.replace(new RegExp('^' + indentAmount), '', 1);\n      continue;\n    }\n  }\n\n  // Add the last comment block to our list of blocks.\n  if (currentBlock) {\n    blocks.push(currentBlock.replace(/^\\n+/, '').replace(/\\n+$/, ''));\n  }\n\n  return blocks;\n};\n\n/**\n * Check a section for the reference number it may or may not have.\n *\n * @private\n * @param  {Array}  paragraphs An array of the paragraphs in a single block.\n * @param  {Object} options    The options object passed on from the initial functions\n * @returns {Boolean|String} False if not found, otherwise returns the reference number as a string.\n */\ncheckReference = function(paragraphs, options) {\n  var lastParagraph = paragraphs[paragraphs.length - 1].trim(),\n    words = lastParagraph.split(/\\s+/),\n    keyword = false,\n    reference = false;\n\n  // If is only one word in the last paragraph, it can't be a styleguide ref.\n  if (words.length < 2) {\n    return false;\n  }\n\n  // Search for the \"styleguide\" (or \"style guide\") keyword at the start of the paragraph.\n  [words[0], words[0] + words[1]].forEach(function(value, index) {\n    if (!keyword) {\n      value = value.replace(/[-\\:]?$/, '');\n      if (value.toLowerCase() === 'styleguide' || options.typos && natural.Metaphone.compare('Styleguide', value.replace('-', ''))) {\n        keyword = words.shift();\n        if (index === 1) {\n          keyword += ' ' + words.shift();\n        }\n      }\n    }\n  });\n\n  if (keyword) {\n    reference = words.join(' ');\n\n    // Normalize any \" - \" delimeters.\n    reference = reference.replace(/\\s+\\-\\s+/g, ' - ');\n\n    // Remove trailing dot-zeros and periods.\n    reference = reference.replace(/\\.$|(\\.0){1,}$/g, '');\n  }\n\n  return reference;\n};\n\n/**\n * Checks if there is a specific property in the comment block and removes it from the original array.\n *\n * @private\n * @param  {String}   propertyName The name of the property to search for\n * @param  {Array}    paragraphs   An array of the paragraphs in a single block\n * @param  {Object}   options      The options object passed on from the initial functions\n * @param  {Object}   sectionData  The original data object of a section.\n * @param  {Function} processValue A function to massage the value before it is inserted into the sectionData.\n * @returns {Object} A new data object for the section.\n */\nprocessProperty = function(propertyName, paragraphs, options, sectionData, processValue) {\n  var indexToRemove = 'not found';\n\n  propertyName = propertyName.toLowerCase();\n\n  paragraphs.map(function(paragraph, index) {\n    if (hasPrefix(paragraph, options, propertyName)) {\n      sectionData[propertyName] = paragraph.replace(new RegExp('^\\\\s*' + propertyName + '\\\\:\\\\s+?', 'gmi'), '');\n      if (typeof processValue === 'function') {\n        sectionData[propertyName] = processValue(sectionData[propertyName]);\n      }\n      paragraph = '';\n      indexToRemove = index;\n    }\n    return paragraph;\n  });\n\n  if (indexToRemove !== 'not found') {\n    paragraphs.splice(indexToRemove, 1);\n  }\n\n  return sectionData;\n};\n\n/**\n * Check if the description indicates that a section is deprecated.\n *\n * @private\n * @param  {String}  description The description of that section\n * @param  {Object}  options     The options passed on from previous functions\n * @returns {Boolean} Whether the description indicates the section is deprecated.\n */\nisDeprecated = function(description, options) {\n  return hasPrefix(description, options, 'Deprecated');\n};\n\n/**\n * Check if the description indicates that a section is experimental.\n *\n * @private\n * @param  {String}  description The description of that section\n * @param  {Object}  options     The options passed on from previous functions\n * @returns {Boolean} Whether the description indicates the section is experimental.\n */\nisExperimental = function(description, options) {\n  return hasPrefix(description, options, 'Experimental');\n};\n\n/**\n * Essentially this function checks if a string is prefixed by a particular attribute,\n * e.g. 'Deprecated:' and 'Markup:'\n *\n * If `options.typos` is enabled it'll try check if the first word at least sounds like\n * the word we're checking for.\n *\n * @private\n * @param  {String}  description The string to check\n * @param  {Object}  options     The options passed on from previous functions\n * @param  {String}  prefix      The prefix to search for\n * @returns {Boolean} Whether the description contains the specified prefix.\n */\nhasPrefix = function(description, options, prefix) {\n  var words;\n  if (!options.typos) {\n    return !!description.match(new RegExp('^\\\\s*' + prefix + '\\\\:', 'gmi'));\n  }\n\n  words = description.replace(/^\\s*/, '').match(/^\\s*([a-z ]*)\\:/gmi);\n  if (!words) {\n    return false;\n  }\n\n  return natural.Metaphone.compare(words[0].replace(':', ''), prefix);\n};\n\nmodule.exports = parse;\n","/home/travis/build/npmtest/node-npmtest-kss/node_modules/kss/lib/traverse.js":"/* eslint-disable max-nested-callbacks */\n\n'use strict';\n\n/**\n * The `kss/lib/traverse` module is normally accessed via the\n * [`traverse()`]{@link module:kss.traverse} method of the `kss` module:\n * ```\n * var kss = require('kss');\n * kss.traverse(directory, options, callback);\n * ```\n * @private\n * @module kss/lib/traverse\n */\n\nvar parse = require('./parse.js'),\n  path = require('path'),\n  fs = require('fs');\n\nvar traverse;\n\n/**\n * Traverse a directory, parse its contents, and create a KssStyleguide.\n *\n * Callbacks receive an instance of `KssStyleguide`.\n *\n * If you want to parse anything other than css, less, sass, or stylus files\n * then you'll want to use options.mask to target a different set of file\n * extensions.\n *\n * ```\n * kss.traverse('./stylesheets', { mask: '*.css' }, function(err, styleguide) {\n *     if (err) throw err;\n *\n *     styleguide.section('2.1.1') // <KssSection>\n * });\n * ```\n *\n * There a few extra `options` you can pass to `kss.traverse` which will effect\n * the output generated:\n *\n * - mask: Use a regex or string (e.g. `*.less|*.css`) to only parse files\n *   matching this value. Defaults to:\n *   `*.css|*.less|*.sass|*.scss|*.styl|*.stylus`\n * - markdown: kss-node supports built-in Markdown formatting of its\n *   documentation, thanks to [marked](https://github.com/chjj/marked). It's\n *   enabled by default, but you can disable it by adding `markdown: false` to\n *   the `options` object.\n * - multiline: kss-node makes the header available separately from the\n *   description. To make kss-node behave like the Ruby KSS, disable this option\n *   and the title will remain a part of the description. This setting is\n *   enabled by default, but you can disable it by adding `multiline: false` to\n *   your options.\n * - typos: Thanks to [natural](https://github.com/NaturalNode/natural),\n *   kss-node can parse keywords phonetically rather then by their string value.\n *   In short: make a typo and the library will do its best to read it anyway.\n *   Enabled by default.\n *\n * @alias module:kss.traverse\n * @param {String|Array} directory The directory(s) to traverse\n * @param {Object}       options   Options to alter the output content (optional)\n * @param {Function}     callback  Called when traversal AND parsing is complete\n */\ntraverse = function(directory, options, callback) {\n  var fileNames = [],\n    fileCounter = 0,\n    filesRemaining = 0,\n    loopsRemaining = 0,\n    walkFinished,\n    walk;\n\n  options = options || {};\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  if (typeof callback !== 'function') {\n    throw new Error('No callback supplied for kss.traverse()!');\n  }\n\n  // Mask to search for particular file types - defaults to common precompilers.\n  options.mask = options.mask || /\\.css|\\.less|\\.sass|\\.scss|\\.styl|\\.stylus/;\n\n  // If the mask is a string, convert it into a RegExp.\n  if (!(options.mask instanceof RegExp)) {\n    options.mask = new RegExp(\n      '(?:' + options.mask.replace(/\\./g, '\\\\.').replace(/\\*/g, '.*') + ')$'\n    );\n  }\n\n  // Normalize all the directory paths.\n  if (!Array.isArray(directory)) {\n    directory = [directory];\n  }\n  for (var key in directory) {\n    // istanbul ignore else\n    if (directory.hasOwnProperty(key)) {\n      directory[key] = path.normalize(directory[key]);\n    }\n  }\n\n  // Callback for walk() when it has finished traversing all directories.\n  walkFinished = function() {\n    /* eslint-disable no-loop-func */\n    var i, l = fileNames.length, files = [], orderedObject = {};\n\n    fileNames.sort();\n    for (i = 0; i < l; i += 1) {\n      (function(j) {\n        fs.readFile(fileNames[j], 'utf8', function(err, contents) {\n          // istanbul ignore if\n          if (err) { callback(err); return; }\n\n          files[j] = contents;\n          fileCounter -= 1;\n\n          if (fileCounter === 0) {\n            files.map(function(fileContent, index) {\n              var filename = fileNames[index];\n              orderedObject[filename] = fileContent;\n              return '';\n            });\n            parse(orderedObject, options, callback);\n          }\n        });\n      }(i));\n    }\n  };\n\n  // Courtesy of [stygstra](https://gist.github.com/514983)\n  // istanbul ignore next\n  walk = function(directories, opts, cb) {\n    opts = opts || {};\n    if (typeof cb !== 'function') { cb = function() {}; }\n\n    if (!Array.isArray(directories)) {\n      directories = [directories];\n    }\n\n    // Loop through all the given directories.\n    loopsRemaining += directories.length;\n    directories.forEach(function(dir) {\n      loopsRemaining -= 1;\n\n      // Start an asynchronous search of the file system.\n      filesRemaining += 1;\n      fs.readdir(dir, function(err, relnames) {\n        if (err) {\n          cb(err);\n          return;\n        }\n\n        // About to start looping through the directory contents.\n        loopsRemaining += relnames.length;\n        // The fs.readdir() callback has returned.\n        filesRemaining -= 1;\n\n        // If there is no more file system to search, call .finished().\n        if (filesRemaining === 0 && loopsRemaining === 0) {\n          cb(null);\n        }\n\n        // Otherwise, if readdir() has results, loop through them.\n        relnames.forEach(function(relname) {\n          loopsRemaining -= 1;\n          var name = path.join(dir, relname);\n\n          // Start an asynchronous stat of this file system item.\n          filesRemaining += 1;\n          fs.stat(name, function(error, stat) {\n            if (error) {\n              cb(error);\n              return;\n            }\n\n            if (stat.isDirectory()) {\n              if (name !== '.svn' && name !== '.git') {\n                walk(name, opts, cb);\n              }\n            } else if (!opts.mask || name.match(opts.mask)) {\n              name = name.replace(/\\\\/g, '/');\n              fileNames.push(name);\n              fileCounter += 1;\n            }\n\n            // The fs.stat() callback has returned.\n            filesRemaining -= 1;\n\n            // If there is no more file system to search, call .finished().\n            if (filesRemaining === 0 && loopsRemaining === 0) {\n              cb(null);\n              return;\n            }\n          });\n        });\n      });\n    });\n  };\n\n  // Get each file in the target directory, order them alphabetically and then\n  // parse their output.\n  walk(directory, options, walkFinished);\n};\n\nmodule.exports = traverse;\n","/home/travis/build/npmtest/node-npmtest-kss/node_modules/kss/generator/handlebars/helpers.js":"// @TODO Re-enable this eslint rule.\n/* eslint-disable valid-jsdoc */\n\n'use strict';\n\nvar Kss = require('../../lib/kss.js');\n\nmodule.exports.register = function(handlebars, config) {\n  config = config || {};\n\n  /**\n   * Returns a single section, found by its reference number\n   * @param  {String|Number} reference The reference number to search for.\n   */\n  handlebars.registerHelper('section', function(reference, options) {\n    var section = options.data.root.styleguide.section(reference);\n\n    return section ? options.fn(section.data) : false;\n  });\n\n  /**\n   * Loop over a section query. If a number is supplied, will convert into\n   * a query for all children and descendants of that reference.\n   * @param  {Mixed} query The section query\n   */\n  handlebars.registerHelper('eachSection', function(query, options) {\n    var styleguide = options.data.root.styleguide,\n      buffer = '',\n      sections,\n      i, l;\n\n    if (!query.match(/\\bx\\b|\\*/g)) {\n      query = query + '.*';\n    }\n    sections = styleguide.section(query);\n    if (!sections) {\n      return '';\n    }\n\n    l = sections.length;\n    for (i = 0; i < l; i += 1) {\n      buffer += options.fn(sections[i].data);\n    }\n\n    return buffer;\n  });\n\n  /**\n   * Loop over each section root, i.e. each section only one level deep.\n   */\n  handlebars.registerHelper('eachRoot', function(options) {\n    var buffer = '',\n      sections = options.data.root.styleguide.section('x'),\n      i, l;\n\n    if (!sections) {\n      return '';\n    }\n\n    l = sections.length;\n    for (i = 0; i < l; i += 1) {\n      buffer += options.fn(sections[i].data);\n    }\n\n    return buffer;\n  });\n\n  /**\n   * Equivalent to \"if the given reference is numeric\". e.g:\n   *\n   * {{#ifNumeric reference}}\n   *    REFERENCES LIKE 4.0 OR 4.1.14\n   *   {{else}}\n   *    ANYTHING ELSE\n   * {{/ifNumeric}}\n   */\n  handlebars.registerHelper('ifNumeric', function(reference, options) {\n    return (typeof reference === 'number' || typeof reference === 'string' && reference.match(/^[\\.\\d]+$/)) ? options.fn(this) : options.inverse(this);\n  });\n\n  /**\n   * Equivalent to \"if the current reference is X\". e.g:\n   *\n   * {{#ifReference 'base.headings'}}\n   *    IF CURRENT REFERENCE IS base.headings ONLY\n   *   {{else}}\n   *    ANYTHING ELSE\n   * {{/ifReference}}\n   */\n  handlebars.registerHelper('ifReference', function(reference, options) {\n    return (this.reference && reference === this.reference) ? options.fn(this) : options.inverse(this);\n  });\n\n  /**\n   * Equivalent to \"unless the current reference is X\". e.g:\n   *\n   * {{#unlessReference 'base.headings'}}\n   *    ANYTHING ELSE\n   *   {{else}}\n   *    IF CURRENT REFERENCE IS base.headings ONLY\n   * {{/unlessReference}}\n   */\n  handlebars.registerHelper('unlessReference', function(reference, options) {\n    return (!this.reference || reference !== this.reference) ? options.fn(this) : options.inverse(this);\n  });\n\n  /**\n   * Takes a range of numbers that the current section's depth must be within.\n   *\n   * Equivalent to \"if the current section is X levels deep\". e.g:\n   *\n   * {{#ifDepth 1}}\n   *    ROOT ELEMENTS ONLY\n   *   {{else}}\n   *    ANYTHING ELSE\n   * {{/ifDepth}}\n   */\n  handlebars.registerHelper('ifDepth', function(lowerBound, upperBound, options) {\n    // If only 1 parameter is passed, upper bound is the same as lower bound.\n    if (typeof options === 'undefined' || options === null) {\n      options = upperBound;\n      upperBound = lowerBound;\n    }\n    return (this.depth && this.depth >= lowerBound && this.depth <= upperBound) ? options.fn(this) : options.inverse(this);\n  });\n\n  /**\n   * Equivalent to \"unless the current section is X levels deep\". e.g:\n   *\n   * {{#unlessDepth 1}}\n   *    ANYTHING ELSE\n   *   {{else}}\n   *    ROOT ELEMENTS ONLY\n   * {{/unlessDepth}}\n   */\n  handlebars.registerHelper('unlessDepth', function(depth, options) {\n    return (!this.depth || depth !== this.depth) ? options.fn(this) : options.inverse(this);\n  });\n\n  /**\n   * Similar to the {#eachSection} helper, however will loop over each modifier\n   * @param  {Object} section Supply a section object to loop over its modifiers. Defaults to the current section.\n   */\n  handlebars.registerHelper('eachModifier', function() {\n    var modifiers,\n      options = arguments[arguments.length - 1],\n      buffer = '',\n      i, l;\n\n    // Default to current modifiers, but allow supplying a custom section.\n    modifiers = (arguments.length > 1 && arguments[0].data) ? arguments[0].data.modifiers : this.modifiers;\n\n    if (!modifiers) {\n      return '';\n    }\n\n    l = modifiers.length;\n    for (i = 0; i < l; i++) {\n      buffer += options.fn(modifiers[i].data || '');\n    }\n    return buffer;\n  });\n\n  /**\n   * Similar to the {#eachSection} helper, however will loop over each parameter\n   * @param  {Object} section Supply a section object to loop over its parameters. Defaults to the current section.\n   */\n  handlebars.registerHelper('eachParameter', function() {\n    var parameters,\n      options = arguments[arguments.length - 1],\n      buffer = '',\n      i, l;\n\n    // Default to current parameters, but allow supplying a custom section.\n    parameters = (arguments.length > 1 && arguments[0].data) ? arguments[0].data.parameters : this.parameters;\n\n    if (!parameters) {\n      return '';\n    }\n\n    l = parameters.length;\n    for (i = 0; i < l; i++) {\n      buffer += options.fn(parameters[i].data || '');\n    }\n    return buffer;\n  });\n\n  /**\n   * Outputs the current section's or modifier's markup.\n   */\n  handlebars.registerHelper('markup', function(options) {\n    var partials = options.data.root.partials,\n      section,\n      modifier = false,\n      template,\n      partial,\n      data;\n\n    if (!this) {\n      return '';\n    }\n\n    // Determine if the element is a section object or a modifier object.\n    if (this.modifiers) {\n      // If this is the section object, use the default markup without a modifier class.\n      section = new Kss.KssSection(this);\n    } else {\n      // If this is the markup object, find the modifier class and the section object.\n      modifier = new Kss.KssModifier(this);\n      section = modifier.section();\n    }\n\n    // Load the information about this section's markup partial.\n    partial = partials[section.reference()];\n\n    // Prepare the sample data for the partial.\n    data = JSON.parse(JSON.stringify(partial.data));\n    /* eslint-disable camelcase */\n    if (data.modifier_class) {\n      data.modifier_class += ' ';\n    } else {\n      data.modifier_class = '';\n    }\n    // Display the modifier's classname or, if a section, the placeholder text\n    // if this section has modifiers.\n    if (modifier) {\n      data.modifier_class += modifier.className();\n    } else if (section.firstModifier() !== false) {\n      data.modifier_class += config.placeholder;\n    }\n    /* eslint-enable camelcase */\n\n    // Compile the section's markup partial into a template.\n    template = handlebars.compile('{{> \"' + partial.name + '\"}}');\n    // We don't wrap the rendered template in \"new handlebars.SafeString()\" since\n    // we want the ability to display it as a code sample with {{ }} and as\n    // rendered HTML with {{{ }}}.\n    return template(data);\n  });\n\n  /**\n   * Deprecated variable replaced with {{homepage}}.\n   */\n  handlebars.registerHelper('overview', /* istanbul ignore next */ function() {\n    throw new Error('The {{overview}} variable is deprecated; use {{homepage}} instead.');\n  });\n\n  /**\n   * Deprecated variable replaced with {{depth}}.\n   */\n  handlebars.registerHelper('refDepth', /* istanbul ignore next */ function() {\n    throw new Error('The {{refDepth}} variable is deprecated; use {{depth}} instead.');\n  });\n\n  /**\n   * Deprecated variable replaced with {{rootName}}.\n   */\n  handlebars.registerHelper('rootNumber', /* istanbul ignore next */ function() {\n    throw new Error('The {{rootNumber}} variable is deprecated; use {{rootName}} instead.');\n  });\n\n  /**\n   * Deprecated helper replaced with {{{expression}}}.\n   */\n  handlebars.registerHelper('html', /* istanbul ignore next */ function() {\n    throw new Error('{{html expression}} is deprecated; use HandleBars’ triple-stash instead: {{{expression}}}.');\n  });\n\n  /**\n   * Deprecated helper replaced with {{#if markup}}...{{/if}}.\n   */\n  handlebars.registerHelper('ifAny', /* istanbul ignore next */ function() {\n    throw new Error('IfAny is deprecated; in your template, replace {{#ifAny markup modifiers}}...{{/ifAny}} with {{#if markup}}...{{/if}}.');\n  });\n\n  /**\n   * Deprecated helper replaced with {{{markup}}}.\n   */\n  handlebars.registerHelper('modifierMarkup', /* istanbul ignore next */ function() {\n    throw new Error('The {{modifierMarkup}} Handlebars helper is deprecated; use {{{markup}}} instead.');\n  });\n\n  /**\n   * Deprecated helper replaced with {{ifDepth expression}}.\n   */\n  handlebars.registerHelper('whenDepth', /* istanbul ignore next */ function() {\n    throw new Error('{{whenDepth expression}} is deprecated; use {{ifDepth expression}} instead.');\n  });\n\n  /**\n   * Outputs console.log() debugging information for each parameter given.\n   *\n   * If no parameters are given, the entire context is output with\n   * `console.log(this)`.\n   */\n  handlebars.registerHelper('consoleLog', function() {\n    if (arguments.length > 1) {\n      // 'options' is automatically passed as the last argument, so skip it.\n      for (var i = 0; i < arguments.length - 1; i++) {\n        console.log(arguments[i]);\n      }\n    } else {\n      console.log('==================== Current Handlebars context:');\n      console.log(this);\n      console.log('====================');\n    }\n    return '';\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-kss/node_modules/kss/generator/handlebars/kss_handlebars_generator.js":"// Remove after https://github.com/Constellation/doctrine/issues/100 is fixed.\n/* eslint-disable valid-jsdoc */\n\n'use strict';\n\n/**\n * The `kss/generator/handlebars` module loads the kssHandlebarsGenerator\n * object, a `{@link KssGenerator}` object using Handlebars templating.\n * ```\n * var kssHandlebarsGenerator = require('kss/generator/handlebars');\n * ```\n * @module kss/generator/handlebars\n */\n\nvar KssGenerator = require('../kss_generator.js'),\n  KssSection = require('../../lib/kss_section.js'),\n  fs = require('fs'),\n  glob = require('glob'),\n  marked = require('marked'),\n  path = require('path'),\n  wrench = require('wrench'),\n  mkdirp = require('mkdirp');\n\n// Pass a string to KssGenerator() to tell the system which API version is\n// implemented by kssHandlebarsGenerator.\nvar kssHandlebarsGenerator = new KssGenerator('2.1', {\n  helpers: {\n    group: 'Style guide:',\n    string: true,\n    path: true,\n    describe: 'Location of custom handlebars helpers; see http://bit.ly/kss-wiki'\n  },\n  homepage: {\n    group: 'Style guide:',\n    string: true,\n    multiple: false,\n    describe: 'File name of the homepage\\'s Markdown file',\n    default: 'styleguide.md'\n  },\n  placeholder: {\n    group: 'Style guide:',\n    string: true,\n    multiple: false,\n    describe: 'Placeholder text to use for modifier classes',\n    default: '[modifier class]'\n  },\n  'nav-depth': {\n    group: 'Style guide:',\n    multiple: false,\n    describe: 'Limit the navigation to the depth specified',\n    default: 3\n  }\n});\n\n/**\n * Initialize the style guide creation process.\n *\n * This method is given a configuration JSON object with the details of the\n * requested style guide generation. The generator can use this information for\n * any necessary tasks before the KSS parsing of the source files.\n *\n * @alias module:kss/generator/handlebars.init\n * @param {Object} config Configuration object for the requested generation.\n * @param {Function} cb Callback that will be given an Error as its first\n *                      parameter, if one occurs.\n * @returns {*} The callback's return value.\n */\nkssHandlebarsGenerator.init = function(config, cb) {\n  var i, j, helper;\n\n  cb = cb || /* istanbul ignore next */ function() {};\n\n  // Save the configuration parameters.\n  this.config = config;\n  this.config.helpers = this.config.helpers || [];\n\n  // Store the global Handlebars object.\n  this.Handlebars = require('handlebars');\n\n  // Load the standard Handlebars helpers.\n  require('./helpers.js').register(this.Handlebars, this.config);\n\n  if (this.config.verbose) {\n    this.log('');\n    this.log('Generating your KSS style guide!');\n    this.log('');\n    this.log(' * KSS Source  : ' + this.config.source.join(', '));\n    this.log(' * Destination : ' + this.config.destination);\n    this.log(' * Template    : ' + this.config.template);\n    if (this.config.helpers.length) {\n      this.log(' * Helpers     : ' + this.config.helpers.join(', '));\n    }\n    this.log('');\n  }\n\n  // Create a new destination directory.\n  try {\n    mkdirp.sync(this.config.destination + '/public');\n  } catch (e) {\n    // empty\n  }\n\n  // Optionally, copy the contents of the template's \"public\" folder.\n  try {\n    wrench.copyDirSyncRecursive(\n      this.config.template + '/public',\n      this.config.destination + '/public',\n      {\n        forceDelete: true,\n        excludeHiddenUnix: true\n      }\n    );\n  } catch (e) {\n    // empty\n  }\n\n  // Load Handlebars helpers.\n  if (this.config.helpers.length > 0) {\n    for (i = 0; i < this.config.helpers.length; i++) {\n      if (fs.existsSync(this.config.helpers[i])) {\n        // Load custom Handlebars helpers.\n        var helperFiles = fs.readdirSync(this.config.helpers[i]);\n\n        for (j = 0; j < helperFiles.length; j++) {\n          if (path.extname(helperFiles[j]) === '.js') {\n            helper = require(this.config.helpers[i] + '/' + helperFiles[j]);\n            if (typeof helper.register === 'function') {\n              helper.register(this.Handlebars, this.config);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Compile the Handlebars template.\n  this.template = fs.readFileSync(this.config.template + '/index.html', 'utf8');\n  this.template = this.Handlebars.compile(this.template);\n\n  return cb(null);\n};\n\n/**\n * Generate the HTML files of the style guide given a KssStyleguide object.\n *\n * @alias module:kss/generator/handlebars.generate\n * @param {KssStyleguide} styleguide The KSS style guide in object format.\n */\nkssHandlebarsGenerator.generate = function(styleguide, cb) {\n  var sections = styleguide.section(),\n    sectionCount = sections.length,\n    sectionRoots = [],\n    rootCount,\n    currentRoot,\n    childSections = [],\n    partials = {},\n    partial,\n    files = [],\n    i,\n    key;\n\n  cb = cb || /* istanbul ignore next */ function() {};\n\n  if (this.config.verbose) {\n    this.log(styleguide.data.files.map(function(file) {\n      return ' - ' + file;\n    }).join('\\n'));\n  }\n\n  // Return an error if no KSS sections are found in the source files.\n  if (sectionCount === 0) {\n    return cb(Error('No KSS documentation discovered in source files.'));\n  }\n\n  if (this.config.verbose) {\n    this.log('...Determining section markup:');\n  }\n\n  for (i = 0; i < sectionCount; i += 1) {\n    // Register all the markup blocks as Handlebars partials.\n    if (sections[i].markup()) {\n      partial = {\n        name: sections[i].reference(),\n        reference: sections[i].reference(),\n        file: '',\n        markup: sections[i].markup(),\n        data: {}\n      };\n      // If the markup is a file path, attempt to load the file.\n      if (partial.markup.match(/^[^\\n]+\\.(html|hbs)$/)) {\n        partial.file = partial.markup;\n        partial.name = path.basename(partial.file, path.extname(partial.file));\n        files = [];\n        for (key in this.config.source) {\n          if (!files.length) {\n            files = glob.sync(this.config.source[key] + '/**/' + partial.file);\n          }\n        }\n        // If the markup file is not found, note that in the style guide.\n        if (!files.length) {\n          partial.markup += ' NOT FOUND!';\n          if (!this.config.verbose) {\n            this.log('WARNING: In section ' + partial.reference + ', ' + partial.markup);\n          }\n        }\n        if (this.config.verbose) {\n          this.log(' - ' + partial.reference + ': ' + partial.markup);\n        }\n        if (files.length) {\n          // Load the partial's markup from file.\n          partial.file = files[0];\n          partial.markup = fs.readFileSync(partial.file, 'utf8');\n          // Load sample data for the partial from the sample .json file.\n          if (fs.existsSync(path.dirname(partial.file) + '/' + partial.name + '.json')) {\n            try {\n              partial.data = require(path.dirname(partial.file) + '/' + partial.name + '.json');\n            } catch (e) {\n              partial.data = {};\n            }\n          }\n        }\n      } else if (this.config.verbose) {\n        this.log(' - ' + partial.reference + ': inline markup');\n      }\n      // Register the partial using the filename (without extension) or using\n      // the style guide reference.\n      this.Handlebars.registerPartial(partial.name, partial.markup);\n      // Save the name of the partial and its data for retrieval in the markup\n      // helper, where we only know the reference.\n      partials[partial.reference] = {\n        name: partial.name,\n        data: partial.data\n      };\n    }\n\n    // Accumulate all of the sections' first indexes.\n    currentRoot = sections[i].reference().split(/(?:\\.|\\ \\-\\ )/)[0];\n    if (sectionRoots.indexOf(currentRoot) === -1) {\n      sectionRoots.push(currentRoot);\n    }\n  }\n\n  // If a root element doesn't have an actual section, build one for it.\n  rootCount = sectionRoots.length;\n  key = false;\n  for (i = 0; i < rootCount; i += 1) {\n    currentRoot = styleguide.section(sectionRoots[i]);\n    if (currentRoot === false) {\n      key = sectionRoots[i];\n      styleguide.data.sections.push(new KssSection({\n        header: key,\n        reference: key\n      }));\n    }\n  }\n  if (key !== false) {\n    styleguide.init();\n  }\n\n  if (this.config.verbose) {\n    this.log('...Generating style guide pages:');\n  }\n\n  // Now, group all of the sections by their root\n  // reference, and make a page for each.\n  rootCount = sectionRoots.length;\n  for (i = 0; i < rootCount; i += 1) {\n    childSections = styleguide.section(sectionRoots[i] + '.*');\n\n    this.generatePage(styleguide, childSections, sectionRoots[i], sectionRoots, partials);\n  }\n\n  // Generate the homepage.\n  childSections = [];\n  this.generatePage(styleguide, childSections, 'styleguide.homepage', sectionRoots, partials);\n\n  cb(null);\n};\n\n/**\n * Renders the handlebars template for a section and saves it to a file.\n *\n * @alias module:kss/generator/handlebars.generatePage\n * @param {KssStyleguide} styleguide The KSS style guide in object format.\n * @param {Array} sections An array of KssSection objects.\n * @param {string} root The current section's reference.\n * @param {Array} sectionRoots An array of section references for all sections at the root of the style guide.\n * @param {Object} partials A hash of the names and data of the registered Handlebars partials.\n */\nkssHandlebarsGenerator.generatePage = function(styleguide, sections, root, sectionRoots, partials) {\n  var filename = '', files,\n    homepageText = false,\n    styles = '',\n    scripts = '',\n    customFields = this.config.custom,\n    key;\n\n  if (root === 'styleguide.homepage') {\n    filename = 'index.html';\n    if (this.config.verbose) {\n      this.log(' - homepage');\n    }\n    // Ensure homepageText is a non-false value.\n    for (key in this.config.source) {\n      if (!homepageText) {\n        try {\n          files = glob.sync(this.config.source[key] + '/**/' + this.config.homepage);\n          if (files.length) {\n            homepageText = ' ' + marked(fs.readFileSync(files[0], 'utf8'));\n          }\n        } catch (e) {\n          // empty\n        }\n      }\n    }\n    if (!homepageText) {\n      homepageText = ' ';\n      if (this.config.verbose) {\n        this.log('   ...no homepage content found in ' + this.config.homepage + '.');\n      } else {\n        this.log('WARNING: no homepage content found in ' + this.config.homepage + '.');\n      }\n    }\n  } else {\n    filename = 'section-' + KssSection.prototype.encodeReferenceURI(root) + '.html';\n    if (this.config.verbose) {\n      this.log(\n        ' - section ' + root + ' [',\n        styleguide.section(root) ? styleguide.section(root).header() : 'Unnamed',\n        ']'\n      );\n    }\n  }\n  // Create the HTML to load the optional CSS and JS.\n  for (key in this.config.css) {\n    if (this.config.css.hasOwnProperty(key)) {\n      styles = styles + '<link rel=\"stylesheet\" href=\"' + this.config.css[key] + '\">\\n';\n    }\n  }\n  for (key in this.config.js) {\n    if (this.config.js.hasOwnProperty(key)) {\n      scripts = scripts + '<script src=\"' + this.config.js[key] + '\"></script>\\n';\n    }\n  }\n\n  /* eslint-disable key-spacing */\n  fs.writeFileSync(this.config.destination + '/' + filename,\n    this.template({\n      partials:     partials,\n      styleguide:   styleguide,\n      sectionRoots: sectionRoots,\n      sections:     sections.map(function(section) {\n        return section.toJSON(customFields);\n      }),\n      rootName:     root,\n      options:      this.config || {},\n      homepage:     homepageText,\n      styles:       styles,\n      scripts:      scripts\n    })\n  );\n  /* eslint-enable key-spacing */\n};\n\nmodule.exports = kssHandlebarsGenerator;\n","/home/travis/build/npmtest/node-npmtest-kss/node_modules/kss/gh-pages/public/kss.js":"(function() {\n  var KssStateGenerator;\n\n  KssStateGenerator = (function() {\n    var pseudo_selectors;\n\n    pseudo_selectors = ['hover', 'enabled', 'disabled', 'active', 'visited', 'focus', 'target', 'checked', 'empty', 'first-of-type', 'last-of-type', 'first-child', 'last-child'];\n\n    function KssStateGenerator() {\n      var idx, idxs, pseudos, replaceRule, rule, stylesheet, _i, _len, _len2, _ref, _ref2;\n      pseudos = new RegExp(\"(\\\\:\" + (pseudo_selectors.join('|\\\\:')) + \")\", \"g\");\n      try {\n        _ref = document.styleSheets;\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          stylesheet = _ref[_i];\n          if (stylesheet.href && stylesheet.href.indexOf(document.domain) >= 0) {\n            idxs = [];\n            _ref2 = stylesheet.cssRules;\n            for (idx = 0, _len2 = _ref2.length; idx < _len2; idx++) {\n              rule = _ref2[idx];\n              if ((rule.type === CSSRule.STYLE_RULE) && pseudos.test(rule.selectorText)) {\n                replaceRule = function(matched, stuff) {\n                  return matched.replace(/\\:/g, '.pseudo-class-');\n                };\n                this.insertRule(rule.cssText.replace(pseudos, replaceRule));\n              }\n              pseudos.lastIndex = 0;\n            }\n          }\n        }\n      } catch (_error) {}\n    }\n\n    KssStateGenerator.prototype.insertRule = function(rule) {\n      var headEl, styleEl;\n      headEl = document.getElementsByTagName('head')[0];\n      styleEl = document.createElement('style');\n      styleEl.type = 'text/css';\n      if (styleEl.styleSheet) {\n        styleEl.styleSheet.cssText = rule;\n      } else {\n        styleEl.appendChild(document.createTextNode(rule));\n      }\n      return headEl.appendChild(styleEl);\n    };\n\n    return KssStateGenerator;\n\n  })();\n\n  new KssStateGenerator;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kss/node_modules/kss/gh-pages/public/less.js":"//\n// LESS - Leaner CSS v1.2.1\n// http://lesscss.org\n// \n// Copyright (c) 2009-2011, Alexis Sellier\n// Licensed under the Apache 2.0 License.\n//\n(function(a,b){function c(b){return a.less[b.split(\"/\")[1]]}function m(){var a=document.getElementsByTagName(\"style\");for(var b=0;b<a.length;b++)a[b].type.match(k)&&(new d.Parser).parse(a[b].innerHTML||\"\",function(c,d){var e=d.toCSS(),f=a[b];f.type=\"text/css\",f.styleSheet?f.styleSheet.cssText=e:f.innerHTML=e})}function n(a,b){for(var c=0;c<d.sheets.length;c++)o(d.sheets[c],a,b,d.sheets.length-(c+1))}function o(b,c,e,f){var g=a.location.href.replace(/[#?].*$/,\"\"),i=b.href.replace(/\\?.*$/,\"\"),j=h&&h.getItem(i),k=h&&h.getItem(i+\":timestamp\"),l={css:j,timestamp:k};/^(https?|file):/.test(i)||(i.charAt(0)==\"/\"?i=a.location.protocol+\"//\"+a.location.host+i:i=g.slice(0,g.lastIndexOf(\"/\")+1)+i);var m=i.match(/([^\\/]+)$/)[1];s(b.href,b.type,function(a,g){if(!e&&l&&g&&(new Date(g)).valueOf()===(new Date(l.timestamp)).valueOf())r(l.css,b),c(null,b,{local:!0,remaining:f});else try{(new d.Parser({optimization:d.optimization,paths:[i.replace(/[\\w\\.-]+$/,\"\")],mime:b.type,filename:m})).parse(a,function(d,e){if(d)return w(d,i);try{c(d,e,a,b,{local:!1,lastModified:g,remaining:f}),u(document.getElementById(\"less-error-message:\"+q(i)))}catch(d){w(d,i)}})}catch(h){w(h,i)}},function(a,b){throw new Error(\"Couldn't load \"+b+\" (\"+a+\")\")})}function q(a){return a.replace(/^[a-z]+:\\/\\/?[^\\/]+/,\"\").replace(/^\\//,\"\").replace(/\\?.*$/,\"\").replace(/\\.[^\\.\\/]+$/,\"\").replace(/[^\\.\\w-]+/g,\"-\").replace(/\\./g,\":\")}function r(a,b,c){var d,e=b.href?b.href.replace(/\\?.*$/,\"\"):\"\",f=\"less:\"+(b.title||q(e));(d=document.getElementById(f))===null&&(d=document.createElement(\"style\"),d.type=\"text/css\",d.media=b.media||\"screen\",d.id=f,document.getElementsByTagName(\"head\")[0].appendChild(d));if(d.styleSheet)try{d.styleSheet.cssText=a}catch(g){throw new Error(\"Couldn't reassign styleSheet.cssText.\")}else(function(a){d.childNodes.length>0?d.firstChild.nodeValue!==a.nodeValue&&d.replaceChild(a,d.firstChild):d.appendChild(a)})(document.createTextNode(a));c&&h&&(v(\"saving \"+e+\" to cache.\"),h.setItem(e,a),h.setItem(e+\":timestamp\",c))}function s(a,b,c,e){function i(b,c,d){b.status>=200&&b.status<300?c(b.responseText,b.getResponseHeader(\"Last-Modified\")):typeof d==\"function\"&&d(b.status,a)}var f=t(),h=g?!1:d.async;typeof f.overrideMimeType==\"function\"&&f.overrideMimeType(\"text/css\"),f.open(\"GET\",a,h),f.setRequestHeader(\"Accept\",b||\"text/x-less, text/css; q=0.9, */*; q=0.5\"),f.send(null),g?f.status===0||f.status>=200&&f.status<300?c(f.responseText):e(f.status,a):h?f.onreadystatechange=function(){f.readyState==4&&i(f,c,e)}:i(f,c,e)}function t(){if(a.XMLHttpRequest)return new XMLHttpRequest;try{return new ActiveXObject(\"MSXML2.XMLHTTP.3.0\")}catch(b){return v(\"browser doesn't support AJAX.\"),null}}function u(a){return a&&a.parentNode.removeChild(a)}function v(a){d.env==\"development\"&&typeof console!=\"undefined\"&&console.log(\"less: \"+a)}function w(a,b){var c=\"less-error-message:\"+q(b),e='<li><label>{line}</label><pre class=\"{class}\">{content}</pre></li>',f=document.createElement(\"div\"),g,h,i=[],j=a.filename||b;f.id=c,f.className=\"less-error-message\",h=\"<h3>\"+(a.message||\"There is an error in your .less file\")+\"</h3>\"+'<p>in <a href=\"'+j+'\">'+j+\"</a> \";var k=function(a,b,c){a.extract[b]&&i.push(e.replace(/\\{line\\}/,parseInt(a.line)+(b-1)).replace(/\\{class\\}/,c).replace(/\\{content\\}/,a.extract[b]))};a.stack?h+=\"<br/>\"+a.stack.split(\"\\n\").slice(1).join(\"<br/>\"):a.extract&&(k(a,0,\"\"),k(a,1,\"line\"),k(a,2,\"\"),h+=\"on line \"+a.line+\", column \"+(a.column+1)+\":</p>\"+\"<ul>\"+i.join(\"\")+\"</ul>\"),f.innerHTML=h,r([\".less-error-message ul, .less-error-message li {\",\"list-style-type: none;\",\"margin-right: 15px;\",\"padding: 4px 0;\",\"margin: 0;\",\"}\",\".less-error-message label {\",\"font-size: 12px;\",\"margin-right: 15px;\",\"padding: 4px 0;\",\"color: #cc7777;\",\"}\",\".less-error-message pre {\",\"color: #dd6666;\",\"padding: 4px 0;\",\"margin: 0;\",\"display: inline-block;\",\"}\",\".less-error-message pre.line {\",\"color: #ff0000;\",\"}\",\".less-error-message h3 {\",\"font-size: 20px;\",\"font-weight: bold;\",\"padding: 15px 0 5px 0;\",\"margin: 0;\",\"}\",\".less-error-message a {\",\"color: #10a\",\"}\",\".less-error-message .error {\",\"color: red;\",\"font-weight: bold;\",\"padding-bottom: 2px;\",\"border-bottom: 1px dashed red;\",\"}\"].join(\"\\n\"),{title:\"error-message\"}),f.style.cssText=[\"font-family: Arial, sans-serif\",\"border: 1px solid #e00\",\"background-color: #eee\",\"border-radius: 5px\",\"-webkit-border-radius: 5px\",\"-moz-border-radius: 5px\",\"color: #e00\",\"padding: 15px\",\"margin-bottom: 15px\"].join(\";\"),d.env==\"development\"&&(g=setInterval(function(){document.body&&(document.getElementById(c)?document.body.replaceChild(f,document.getElementById(c)):document.body.insertBefore(f,document.body.firstChild),clearInterval(g))},10))}Array.isArray||(Array.isArray=function(a){return Object.prototype.toString.call(a)===\"[object Array]\"||a instanceof Array}),Array.prototype.forEach||(Array.prototype.forEach=function(a,b){var c=this.length>>>0;for(var d=0;d<c;d++)d in this&&a.call(b,this[d],d,this)}),Array.prototype.map||(Array.prototype.map=function(a){var b=this.length>>>0,c=new Array(b),d=arguments[1];for(var e=0;e<b;e++)e in this&&(c[e]=a.call(d,this[e],e,this));return c}),Array.prototype.filter||(Array.prototype.filter=function(a){var b=[],c=arguments[1];for(var d=0;d<this.length;d++)a.call(c,this[d])&&b.push(this[d]);return b}),Array.prototype.reduce||(Array.prototype.reduce=function(a){var b=this.length>>>0,c=0;if(b===0&&arguments.length===1)throw new TypeError;if(arguments.length>=2)var d=arguments[1];else do{if(c in this){d=this[c++];break}if(++c>=b)throw new TypeError}while(!0);for(;c<b;c++)c in this&&(d=a.call(null,d,this[c],c,this));return d}),Array.prototype.indexOf||(Array.prototype.indexOf=function(a){var b=this.length,c=arguments[1]||0;if(!b)return-1;if(c>=b)return-1;c<0&&(c+=b);for(;c<b;c++){if(!Object.prototype.hasOwnProperty.call(this,c))continue;if(a===this[c])return c}return-1}),Object.keys||(Object.keys=function(a){var b=[];for(var c in a)Object.prototype.hasOwnProperty.call(a,c)&&b.push(c);return b}),String.prototype.trim||(String.prototype.trim=function(){return String(this).replace(/^\\s\\s*/,\"\").replace(/\\s\\s*$/,\"\")});var d,f;typeof environment==\"object\"&&{}.toString.call(environment)===\"[object Environment]\"?(typeof a==\"undefined\"?d={}:d=a.less={},f=d.tree={},d.mode=\"rhino\"):typeof a==\"undefined\"?(d=exports,f=c(\"./tree\"),d.mode=\"node\"):(typeof a.less==\"undefined\"&&(a.less={}),d=a.less,f=a.less.tree={},d.mode=\"browser\"),d.Parser=function(b){function t(){j=m[i],k=h,n=h}function u(){m[i]=j,h=k,n=h}function v(){h>n&&(m[i]=m[i].slice(h-n),n=h)}function w(a){var b,c,d,e,f,j,k,l;if(a instanceof Function)return a.call(o.parsers);if(typeof a==\"string\")b=g.charAt(h)===a?a:null,d=1,v();else{v();if(!(b=a.exec(m[i])))return null;d=b[0].length}if(b){l=h+=d,j=h+m[i].length-d;while(h<j){e=g.charCodeAt(h);if(e!==32&&e!==10&&e!==9)break;h++}return m[i]=m[i].slice(d+(h-l)),n=h,m[i].length===0&&i<m.length-1&&i++,typeof b==\"string\"?b:b.length===1?b[0]:b}}function x(a,b){var c=w(a);if(!!c)return c;y(b||(typeof a==\"string\"?\"expected '\"+a+\"' got '\"+g.charAt(h)+\"'\":\"unexpected token\"))}function y(a,b){throw{index:h,type:b||\"Syntax\",message:a}}function z(a){return typeof a==\"string\"?g.charAt(h)===a:a.test(m[i])?!0:!1}function A(a,b){return a.filename&&b.filename&&a.filename!==b.filename?o.imports.contents[a.filename]:g}function B(a,b){for(var c=a,d=-1;c>=0&&b.charAt(c)!==\"\\n\";c--)d++;return{line:typeof a==\"number\"?(b.slice(0,a).match(/\\n/g)||\"\").length:null,column:d}}function C(a,b){var c=A(a,b),d=B(a.index,c),e=d.line,f=d.column,g=c.split(\"\\n\");this.type=a.type||\"Syntax\",this.message=a.message,this.filename=a.filename||b.filename,this.index=a.index,this.line=typeof e==\"number\"?e+1:null,this.callLine=a.call&&B(a.call,c)+1,this.callExtract=g[B(a.call,c)],this.stack=a.stack,this.column=f,this.extract=[g[e-1],g[e],g[e+1]]}var g,h,i,j,k,l,m,n,o,q=this,r=function(){},s=this.imports={paths:b&&b.paths||[],queue:[],files:{},contents:{},mime:b&&b.mime,error:null,push:function(a,c){var e=this;this.queue.push(a),d.Parser.importer(a,this.paths,function(b,d,f){e.queue.splice(e.queue.indexOf(a),1),e.files[a]=d,e.contents[a]=f,b&&!e.error&&(e.error=b),c(b,d),e.queue.length===0&&r()},b)}};return this.env=b=b||{},this.optimization=\"optimization\"in this.env?this.env.optimization:1,this.env.filename=this.env.filename||null,o={imports:s,parse:function(a,e){var j,k,p,q,s,t,u=[],v,x=null;h=i=n=l=0,m=[],g=a.replace(/\\r\\n/g,\"\\n\"),m=function(a){var c=0,d=/[^\"'`\\{\\}\\/\\(\\)]+/g,e=/\\/\\*(?:[^*]|\\*+[^\\/*])*\\*+\\/|\\/\\/.*/g,f=0,h,i=a[0],j,k;for(var l=0,m,n;l<g.length;l++){d.lastIndex=l,(h=d.exec(g))&&h.index===l&&(l+=h[0].length,i.push(h[0])),m=g.charAt(l),e.lastIndex=l,!k&&!j&&m===\"/\"&&(n=g.charAt(l+1),(n===\"/\"||n===\"*\")&&(h=e.exec(g))&&h.index===l&&(l+=h[0].length,i.push(h[0]),m=g.charAt(l)));if(m===\"{\"&&!k&&!j)f++,i.push(m);else if(m===\"}\"&&!k&&!j)f--,i.push(m),a[++c]=i=[];else if(m===\"(\"&&!k&&!j)i.push(m),j=!0;else if(m===\")\"&&!k&&j)i.push(m),j=!1;else{if(m==='\"'||m===\"'\"||m===\"`\")k?k=k===m?!1:k:k=m;i.push(m)}}if(f>0)throw{type:\"Syntax\",message:\"Missing closing `}`\",filename:b.filename};return a.map(function(a){return a.join(\"\")})}([[]]);try{j=new f.Ruleset([],w(this.parsers.primary)),j.root=!0}catch(y){return e(new C(y,b))}j.toCSS=function(a){var e,g,h;return function(e,g){var h=[],i;e=e||{},typeof g==\"object\"&&!Array.isArray(g)&&(g=Object.keys(g).map(function(a){var b=g[a];return b instanceof f.Value||(b instanceof f.Expression||(b=new f.Expression([b])),b=new f.Value([b])),new f.Rule(\"@\"+a,b,!1,0)}),h=[new f.Ruleset(null,g)]);try{var j=a.call(this,{frames:h}).toCSS([],{compress:e.compress||!1})}catch(k){throw new C(k,b)}if(i=o.imports.error)throw i instanceof C?i:new C(i,b);return e.yuicompress&&d.mode===\"node\"?c(\"./cssmin\").compressor.cssmin(j):e.compress?j.replace(/(\\s)+/g,\"$1\"):j}}(j.eval);if(h<g.length-1){h=l,t=g.split(\"\\n\"),s=(g.slice(0,h).match(/\\n/g)||\"\").length+1;for(var z=h,A=-1;z>=0&&g.charAt(z)!==\"\\n\";z--)A++;x={type:\"Parse\",message:\"Syntax Error on line \"+s,index:h,filename:b.filename,line:s,column:A,extract:[t[s-2],t[s-1],t[s]]}}this.imports.queue.length>0?r=function(){e(x,j)}:e(x,j)},parsers:{primary:function(){var a,b=[];while((a=w(this.mixin.definition)||w(this.rule)||w(this.ruleset)||w(this.mixin.call)||w(this.comment)||w(this.directive))||w(/^[\\s\\n]+/))a&&b.push(a);return b},comment:function(){var a;if(g.charAt(h)!==\"/\")return;if(g.charAt(h+1)===\"/\")return new f.Comment(w(/^\\/\\/.*/),!0);if(a=w(/^\\/\\*(?:[^*]|\\*+[^\\/*])*\\*+\\/\\n?/))return new f.Comment(a)},entities:{quoted:function(){var a,b=h,c;g.charAt(b)===\"~\"&&(b++,c=!0);if(g.charAt(b)!=='\"'&&g.charAt(b)!==\"'\")return;c&&w(\"~\");if(a=w(/^\"((?:[^\"\\\\\\r\\n]|\\\\.)*)\"|'((?:[^'\\\\\\r\\n]|\\\\.)*)'/))return new f.Quoted(a[0],a[1]||a[2],c)},keyword:function(){var a;if(a=w(/^[_A-Za-z-][_A-Za-z0-9-]*/))return f.colors.hasOwnProperty(a)?new f.Color(f.colors[a].slice(1)):new f.Keyword(a)},call:function(){var a,c,d=h;if(!(a=/^([\\w-]+|%|progid:[\\w\\.]+)\\(/.exec(m[i])))return;a=a[1].toLowerCase();if(a===\"url\")return null;h+=a.length;if(a===\"alpha\")return w(this.alpha);w(\"(\"),c=w(this.entities.arguments);if(!w(\")\"))return;if(a)return new f.Call(a,c,d,b.filename)},arguments:function(){var a=[],b;while(b=w(this.entities.assignment)||w(this.expression)){a.push(b);if(!w(\",\"))break}return a},literal:function(){return w(this.entities.dimension)||w(this.entities.color)||w(this.entities.quoted)},assignment:function(){var a,b;if((a=w(/^\\w+(?=\\s?=)/i))&&w(\"=\")&&(b=w(this.entity)))return new f.Assignment(a,b)},url:function(){var a;if(g.charAt(h)!==\"u\"||!w(/^url\\(/))return;return a=w(this.entities.quoted)||w(this.entities.variable)||w(this.entities.dataURI)||w(/^[-\\w%@$\\/.&=:;#+?~]+/)||\"\",x(\")\"),new f.URL(a.value||a.data||a instanceof f.Variable?a:new f.Anonymous(a),s.paths)},dataURI:function(){var a;if(w(/^data:/)){a={},a.mime=w(/^[^\\/]+\\/[^,;)]+/)||\"\",a.charset=w(/^;\\s*charset=[^,;)]+/)||\"\",a.base64=w(/^;\\s*base64/)||\"\",a.data=w(/^,\\s*[^)]+/);if(a.data)return a}},variable:function(){var a,c=h;if(g.charAt(h)===\"@\"&&(a=w(/^@@?[\\w-]+/)))return new f.Variable(a,c,b.filename)},color:function(){var a;if(g.charAt(h)===\"#\"&&(a=w(/^#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})/)))return new f.Color(a[1])},dimension:function(){var a,b=g.charCodeAt(h);if(b>57||b<45||b===47)return;if(a=w(/^(-?\\d*\\.?\\d+)(px|%|em|rem|pc|ex|in|deg|s|ms|pt|cm|mm|rad|grad|turn)?/))return new f.Dimension(a[1],a[2])},javascript:function(){var a,b=h,c;g.charAt(b)===\"~\"&&(b++,c=!0);if(g.charAt(b)!==\"`\")return;c&&w(\"~\");if(a=w(/^`([^`]*)`/))return new f.JavaScript(a[1],h,c)}},variable:function(){var a;if(g.charAt(h)===\"@\"&&(a=w(/^(@[\\w-]+)\\s*:/)))return a[1]},shorthand:function(){var a,b;if(!z(/^[@\\w.%-]+\\/[@\\w.-]+/))return;if((a=w(this.entity))&&w(\"/\")&&(b=w(this.entity)))return new f.Shorthand(a,b)},mixin:{call:function(){var a=[],c,d,e,i=h,j=g.charAt(h),k=!1;if(j!==\".\"&&j!==\"#\")return;while(c=w(/^[#.](?:[\\w-]|\\\\(?:[a-fA-F0-9]{1,6} ?|[^a-fA-F0-9]))+/))a.push(new f.Element(d,c,h)),d=w(\">\");w(\"(\")&&(e=w(this.entities.arguments))&&w(\")\"),w(this.important)&&(k=!0);if(a.length>0&&(w(\";\")||z(\"}\")))return new f.mixin.Call(a,e,i,b.filename,k)},definition:function(){var a,b=[],c,d,e,i,j;if(g.charAt(h)!==\".\"&&g.charAt(h)!==\"#\"||z(/^[^{]*(;|})/))return;t();if(c=w(/^([#.](?:[\\w-]|\\\\(?:[a-fA-F0-9]{1,6} ?|[^a-fA-F0-9]))+)\\s*\\(/)){a=c[1];while(e=w(this.entities.variable)||w(this.entities.literal)||w(this.entities.keyword)){e instanceof f.Variable?w(\":\")?(i=x(this.expression,\"expected expression\"),b.push({name:e.name,value:i})):b.push({name:e.name}):b.push({value:e});if(!w(\",\"))break}x(\")\"),w(/^when/)&&(j=x(this.conditions,\"expected condition\")),d=w(this.block);if(d)return new f.mixin.Definition(a,b,d,j);u()}}},entity:function(){return w(this.entities.literal)||w(this.entities.variable)||w(this.entities.url)||w(this.entities.call)||w(this.entities.keyword)||w(this.entities.javascript)||w(this.comment)},end:function(){return w(\";\")||z(\"}\")},alpha:function(){var a;if(!w(/^\\(opacity=/i))return;if(a=w(/^\\d+/)||w(this.entities.variable))return x(\")\"),new f.Alpha(a)},element:function(){var a,b,c,d;c=w(this.combinator),a=w(/^(?:\\d+\\.\\d+|\\d+)%/)||w(/^(?:[.#]?|:*)(?:[\\w-]|\\\\(?:[a-fA-F0-9]{1,6} ?|[^a-fA-F0-9]))+/)||w(\"*\")||w(this.attribute)||w(/^\\([^)@]+\\)/),a||w(\"(\")&&(d=w(this.entities.variable))&&w(\")\")&&(a=new f.Paren(d));if(a)return new f.Element(c,a,h);if(c.value&&c.value.charAt(0)===\"&\")return new f.Element(c,null,h)},combinator:function(){var a,b=g.charAt(h);if(b===\">\"||b===\"+\"||b===\"~\"){h++;while(g.charAt(h)===\" \")h++;return new f.Combinator(b)}if(b===\"&\"){a=\"&\",h++,g.charAt(h)===\" \"&&(a=\"& \");while(g.charAt(h)===\" \")h++;return new f.Combinator(a)}if(b===\":\"&&g.charAt(h+1)===\":\"){h+=2;while(g.charAt(h)===\" \")h++;return new f.Combinator(\"::\")}return g.charAt(h-1)===\" \"?new f.Combinator(\" \"):new f.Combinator(null)},selector:function(){var a,b,c=[],d,e;while(b=w(this.element)){d=g.charAt(h),c.push(b);if(d===\"{\"||d===\"}\"||d===\";\"||d===\",\")break}if(c.length>0)return new f.Selector(c)},tag:function(){return w(/^[a-zA-Z][a-zA-Z-]*[0-9]?/)||w(\"*\")},attribute:function(){var a=\"\",b,c,d;if(!w(\"[\"))return;if(b=w(/^[a-zA-Z-]+/)||w(this.entities.quoted))(d=w(/^[|~*$^]?=/))&&(c=w(this.entities.quoted)||w(/^[\\w-]+/))?a=[b,d,c.toCSS?c.toCSS():c].join(\"\"):a=b;if(!w(\"]\"))return;if(a)return\"[\"+a+\"]\"},block:function(){var a;if(w(\"{\")&&(a=w(this.primary))&&w(\"}\"))return a},ruleset:function(){var a=[],b,c,d;t();while(b=w(this.selector)){a.push(b),w(this.comment);if(!w(\",\"))break;w(this.comment)}if(a.length>0&&(c=w(this.block)))return new f.Ruleset(a,c);l=h,u()},rule:function(){var a,b,c=g.charAt(h),d,e;t();if(c===\".\"||c===\"#\"||c===\"&\")return;if(a=w(this.variable)||w(this.property)){a.charAt(0)!=\"@\"&&(e=/^([^@+\\/'\"*`(;{}-]*);/.exec(m[i]))?(h+=e[0].length-1,b=new f.Anonymous(e[1])):a===\"font\"?b=w(this.font):b=w(this.value),d=w(this.important);if(b&&w(this.end))return new f.Rule(a,b,d,k);l=h,u()}},\"import\":function(){var a,b,c=h;if(w(/^@import\\s+/)&&(a=w(this.entities.quoted)||w(this.entities.url))){b=w(this.mediaFeatures);if(w(\";\"))return new f.Import(a,s,b,c)}},mediaFeature:function(){var a=[];do if(e=w(this.entities.keyword))a.push(e);else if(w(\"(\")){p=w(this.property),e=w(this.entity);if(!w(\")\"))return null;if(p&&e)a.push(new f.Paren(new f.Rule(p,e,null,h,!0)));else{if(!e)return null;a.push(new f.Paren(e))}}while(e);if(a.length>0)return new f.Expression(a)},mediaFeatures:function(){var a,b=[];while(a=w(this.mediaFeature)){b.push(a);if(!w(\",\"))break}return b.length>0?b:null},media:function(){var a;if(w(/^@media/)){a=w(this.mediaFeatures);if(rules=w(this.block))return new f.Directive(\"@media\",rules,a)}},directive:function(){var a,b,c,d,e,i;if(g.charAt(h)!==\"@\")return;if(b=w(this[\"import\"])||w(this.media))return b;if(a=w(/^@page|@keyframes/)||w(/^@(?:-webkit-|-moz-|-o-|-ms-)[a-z0-9-]+/)){d=(w(/^[^{]+/)||\"\").trim();if(c=w(this.block))return new f.Directive(a+\" \"+d,c)}else if(a=w(/^@[-a-z]+/))if(a===\"@font-face\"){if(c=w(this.block))return new f.Directive(a,c)}else if((b=w(this.entity))&&w(\";\"))return new f.Directive(a,b)},font:function(){var a=[],b=[],c,d,e,g;while(g=w(this.shorthand)||w(this.entity))b.push(g);a.push(new f.Expression(b));if(w(\",\"))while(g=w(this.expression)){a.push(g);if(!w(\",\"))break}return new f.Value(a)},value:function(){var a,b=[],c;while(a=w(this.expression)){b.push(a);if(!w(\",\"))break}if(b.length>0)return new f.Value(b)},important:function(){if(g.charAt(h)===\"!\")return w(/^! *important/)},sub:function(){var a;if(w(\"(\")&&(a=w(this.expression))&&w(\")\"))return a},multiplication:function(){var a,b,c,d;if(a=w(this.operand)){while(!z(/^\\/\\*/)&&(c=w(\"/\")||w(\"*\"))&&(b=w(this.operand)))d=new f.Operation(c,[d||a,b]);return d||a}},addition:function(){var a,b,c,d;if(a=w(this.multiplication)){while((c=w(/^[-+]\\s+/)||g.charAt(h-1)!=\" \"&&(w(\"+\")||w(\"-\")))&&(b=w(this.multiplication)))d=new f.Operation(c,[d||a,b]);return d||a}},conditions:function(){var a,b,c=h,d;if(a=w(this.condition)){while(w(\",\")&&(b=w(this.condition)))d=new f.Condition(\"or\",d||a,b,c);return d||a}},condition:function(){var a,b,c,d,e=h,g=!1;w(/^not/)&&(g=!0),x(\"(\");if(a=w(this.addition)||w(this.entities.keyword)||w(this.entities.quoted))return(d=w(/^(?:>=|=<|[<=>])/))?(b=w(this.addition)||w(this.entities.keyword)||w(this.entities.quoted))?c=new f.Condition(d,a,b,e,g):y(\"expected expression\"):c=new f.Condition(\"=\",a,new f.Keyword(\"true\"),e,g),x(\")\"),w(/^and/)?new f.Condition(\"and\",c,w(this.condition)):c},operand:function(){var a,b=g.charAt(h+1);g.charAt(h)===\"-\"&&(b===\"@\"||b===\"(\")&&(a=w(\"-\"));var c=w(this.sub)||w(this.entities.dimension)||w(this.entities.color)||w(this.entities.variable)||w(this.entities.call);return a?new f.Operation(\"*\",[new f.Dimension(-1),c]):c},expression:function(){var a,b,c=[],d;while(a=w(this.addition)||w(this.entity))c.push(a);if(c.length>0)return new f.Expression(c)},property:function(){var a;if(a=w(/^(\\*?-?[-a-z_0-9]+)\\s*:/))return a[1]}}}};if(d.mode===\"browser\"||d.mode===\"rhino\")d.Parser.importer=function(a,b,c,d){a.charAt(0)!==\"/\"&&b.length>0&&(a=b[0]+a),o({href:a,title:a,type:d.mime},c,!0)};(function(a){function b(b){return a.functions.hsla(b.h,b.s,b.l,b.a)}function c(b){if(b instanceof a.Dimension)return parseFloat(b.unit==\"%\"?b.value/100:b.value);if(typeof b==\"number\")return b;throw{error:\"RuntimeError\",message:\"color functions take numbers as parameters\"}}function d(a){return Math.min(1,Math.max(0,a))}a.functions={rgb:function(a,b,c){return this.rgba(a,b,c,1)},rgba:function(b,d,e,f){var g=[b,d,e].map(function(a){return c(a)}),f=c(f);return new a.Color(g,f)},hsl:function(a,b,c){return this.hsla(a,b,c,1)},hsla:function(a,b,d,e){function h(a){return a=a<0?a+1:a>1?a-1:a,a*6<1?g+(f-g)*a*6:a*2<1?f:a*3<2?g+(f-g)*(2/3-a)*6:g}a=c(a)%360/360,b=c(b),d=c(d),e=c(e);var f=d<=.5?d*(b+1):d+b-d*b,g=d*2-f;return this.rgba(h(a+1/3)*255,h(a)*255,h(a-1/3)*255,e)},hue:function(b){return new a.Dimension(Math.round(b.toHSL().h))},saturation:function(b){return new a.Dimension(Math.round(b.toHSL().s*100),\"%\")},lightness:function(b){return new a.Dimension(Math.round(b.toHSL().l*100),\"%\")},alpha:function(b){return new a.Dimension(b.toHSL().a)},saturate:function(a,c){var e=a.toHSL();return e.s+=c.value/100,e.s=d(e.s),b(e)},desaturate:function(a,c){var e=a.toHSL();return e.s-=c.value/100,e.s=d(e.s),b(e)},lighten:function(a,c){var e=a.toHSL();return e.l+=c.value/100,e.l=d(e.l),b(e)},darken:function(a,c){var e=a.toHSL();return e.l-=c.value/100,e.l=d(e.l),b(e)},fadein:function(a,c){var e=a.toHSL();return e.a+=c.value/100,e.a=d(e.a),b(e)},fadeout:function(a,c){var e=a.toHSL();return e.a-=c.value/100,e.a=d(e.a),b(e)},fade:function(a,c){var e=a.toHSL();return e.a=c.value/100,e.a=d(e.a),b(e)},spin:function(a,c){var d=a.toHSL(),e=(d.h+c.value)%360;return d.h=e<0?360+e:e,b(d)},mix:function(b,c,d){var e=d.value/100,f=e*2-1,g=b.toHSL().a-c.toHSL().a,h=((f*g==-1?f:(f+g)/(1+f*g))+1)/2,i=1-h,j=[b.rgb[0]*h+c.rgb[0]*i,b.rgb[1]*h+c.rgb[1]*i,b.rgb[2]*h+c.rgb[2]*i],k=b.alpha*e+c.alpha*(1-e);return new a.Color(j,k)},greyscale:function(b){return this.desaturate(b,new a.Dimension(100))},e:function(b){return new a.Anonymous(b instanceof a.JavaScript?b.evaluated:b)},escape:function(b){return new a.Anonymous(encodeURI(b.value).replace(/=/g,\"%3D\").replace(/:/g,\"%3A\").replace(/#/g,\"%23\").replace(/;/g,\"%3B\").replace(/\\(/g,\"%28\").replace(/\\)/g,\"%29\"))},\"%\":function(b){var c=Array.prototype.slice.call(arguments,1),d=b.value;for(var e=0;e<c.length;e++)d=d.replace(/%[sda]/i,function(a){var b=a.match(/s/i)?c[e].value:c[e].toCSS();return a.match(/[A-Z]$/)?encodeURIComponent(b):b});return d=d.replace(/%%/g,\"%\"),new a.Quoted('\"'+d+'\"',d)},round:function(a){return this._math(\"round\",a)},ceil:function(a){return this._math(\"ceil\",a)},floor:function(a){return this._math(\"floor\",a)},_math:function(b,d){if(d instanceof a.Dimension)return new a.Dimension(Math[b](c(d)),d.unit);if(typeof d==\"number\")return Math[b](d);throw{type:\"Argument\",message:\"argument must be a number\"}},argb:function(b){return new a.Anonymous(b.toARGB())},percentage:function(b){return new a.Dimension(b.value*100,\"%\")},color:function(b){if(b instanceof a.Quoted)return new a.Color(b.value.slice(1));throw{type:\"Argument\",message:\"argument must be a string\"}},iscolor:function(b){return this._isa(b,a.Color)},isnumber:function(b){return this._isa(b,a.Dimension)},isstring:function(b){return this._isa(b,a.Quoted)},iskeyword:function(b){return this._isa(b,a.Keyword)},isurl:function(b){return this._isa(b,a.URL)},ispixel:function(b){return b instanceof a.Dimension&&b.unit===\"px\"?a.True:a.False},ispercentage:function(b){return b instanceof a.Dimension&&b.unit===\"%\"?a.True:a.False},isem:function(b){return b instanceof a.Dimension&&b.unit===\"em\"?a.True:a.False},_isa:function(b,c){return b instanceof c?a.True:a.False}}})(c(\"./tree\")),function(a){a.colors={aliceblue:\"#f0f8ff\",antiquewhite:\"#faebd7\",aqua:\"#00ffff\",aquamarine:\"#7fffd4\",azure:\"#f0ffff\",beige:\"#f5f5dc\",bisque:\"#ffe4c4\",black:\"#000000\",blanchedalmond:\"#ffebcd\",blue:\"#0000ff\",blueviolet:\"#8a2be2\",brown:\"#a52a2a\",burlywood:\"#deb887\",cadetblue:\"#5f9ea0\",chartreuse:\"#7fff00\",chocolate:\"#d2691e\",coral:\"#ff7f50\",cornflowerblue:\"#6495ed\",cornsilk:\"#fff8dc\",crimson:\"#dc143c\",cyan:\"#00ffff\",darkblue:\"#00008b\",darkcyan:\"#008b8b\",darkgoldenrod:\"#b8860b\",darkgray:\"#a9a9a9\",darkgrey:\"#a9a9a9\",darkgreen:\"#006400\",darkkhaki:\"#bdb76b\",darkmagenta:\"#8b008b\",darkolivegreen:\"#556b2f\",darkorange:\"#ff8c00\",darkorchid:\"#9932cc\",darkred:\"#8b0000\",darksalmon:\"#e9967a\",darkseagreen:\"#8fbc8f\",darkslateblue:\"#483d8b\",darkslategray:\"#2f4f4f\",darkslategrey:\"#2f4f4f\",darkturquoise:\"#00ced1\",darkviolet:\"#9400d3\",deeppink:\"#ff1493\",deepskyblue:\"#00bfff\",dimgray:\"#696969\",dimgrey:\"#696969\",dodgerblue:\"#1e90ff\",firebrick:\"#b22222\",floralwhite:\"#fffaf0\",forestgreen:\"#228b22\",fuchsia:\"#ff00ff\",gainsboro:\"#dcdcdc\",ghostwhite:\"#f8f8ff\",gold:\"#ffd700\",goldenrod:\"#daa520\",gray:\"#808080\",grey:\"#808080\",green:\"#008000\",greenyellow:\"#adff2f\",honeydew:\"#f0fff0\",hotpink:\"#ff69b4\",indianred:\"#cd5c5c\",indigo:\"#4b0082\",ivory:\"#fffff0\",khaki:\"#f0e68c\",lavender:\"#e6e6fa\",lavenderblush:\"#fff0f5\",lawngreen:\"#7cfc00\",lemonchiffon:\"#fffacd\",lightblue:\"#add8e6\",lightcoral:\"#f08080\",lightcyan:\"#e0ffff\",lightgoldenrodyellow:\"#fafad2\",lightgray:\"#d3d3d3\",lightgrey:\"#d3d3d3\",lightgreen:\"#90ee90\",lightpink:\"#ffb6c1\",lightsalmon:\"#ffa07a\",lightseagreen:\"#20b2aa\",lightskyblue:\"#87cefa\",lightslategray:\"#778899\",lightslategrey:\"#778899\",lightsteelblue:\"#b0c4de\",lightyellow:\"#ffffe0\",lime:\"#00ff00\",limegreen:\"#32cd32\",linen:\"#faf0e6\",magenta:\"#ff00ff\",maroon:\"#800000\",mediumaquamarine:\"#66cdaa\",mediumblue:\"#0000cd\",mediumorchid:\"#ba55d3\",mediumpurple:\"#9370d8\",mediumseagreen:\"#3cb371\",mediumslateblue:\"#7b68ee\",mediumspringgreen:\"#00fa9a\",mediumturquoise:\"#48d1cc\",mediumvioletred:\"#c71585\",midnightblue:\"#191970\",mintcream:\"#f5fffa\",mistyrose:\"#ffe4e1\",moccasin:\"#ffe4b5\",navajowhite:\"#ffdead\",navy:\"#000080\",oldlace:\"#fdf5e6\",olive:\"#808000\",olivedrab:\"#6b8e23\",orange:\"#ffa500\",orangered:\"#ff4500\",orchid:\"#da70d6\",palegoldenrod:\"#eee8aa\",palegreen:\"#98fb98\",paleturquoise:\"#afeeee\",palevioletred:\"#d87093\",papayawhip:\"#ffefd5\",peachpuff:\"#ffdab9\",peru:\"#cd853f\",pink:\"#ffc0cb\",plum:\"#dda0dd\",powderblue:\"#b0e0e6\",purple:\"#800080\",red:\"#ff0000\",rosybrown:\"#bc8f8f\",royalblue:\"#4169e1\",saddlebrown:\"#8b4513\",salmon:\"#fa8072\",sandybrown:\"#f4a460\",seagreen:\"#2e8b57\",seashell:\"#fff5ee\",sienna:\"#a0522d\",silver:\"#c0c0c0\",skyblue:\"#87ceeb\",slateblue:\"#6a5acd\",slategray:\"#708090\",slategrey:\"#708090\",snow:\"#fffafa\",springgreen:\"#00ff7f\",steelblue:\"#4682b4\",tan:\"#d2b48c\",teal:\"#008080\",thistle:\"#d8bfd8\",tomato:\"#ff6347\",turquoise:\"#40e0d0\",violet:\"#ee82ee\",wheat:\"#f5deb3\",white:\"#ffffff\",whitesmoke:\"#f5f5f5\",yellow:\"#ffff00\",yellowgreen:\"#9acd32\"}}(c(\"./tree\")),function(a){a.Alpha=function(a){this.value=a},a.Alpha.prototype={toCSS:function(){return\"alpha(opacity=\"+(this.value.toCSS?this.value.toCSS():this.value)+\")\"},eval:function(a){return this.value.eval&&(this.value=this.value.eval(a)),this}}}(c(\"../tree\")),function(a){a.Anonymous=function(a){this.value=a.value||a},a.Anonymous.prototype={toCSS:function(){return this.value},eval:function(){return this}}}(c(\"../tree\")),function(a){a.Assignment=function(a,b){this.key=a,this.value=b},a.Assignment.prototype={toCSS:function(){return this.key+\"=\"+(this.value.toCSS?this.value.toCSS():this.value)},eval:function(a){return this.value.eval&&(this.value=this.value.eval(a)),this}}}(c(\"../tree\")),function(a){a.Call=function(a,b,c,d){this.name=a,this.args=b,this.index=c,this.filename=d},a.Call.prototype={eval:function(b){var c=this.args.map(function(a){return a.eval(b)});if(!(this.name in a.functions))return new a.Anonymous(this.name+\"(\"+c.map(function(a){return a.toCSS()}).join(\", \")+\")\");try{return a.functions[this.name].apply(a.functions,c)}catch(d){throw{type:d.type||\"Runtime\",message:\"error evaluating function `\"+this.name+\"`\"+(d.message?\": \"+d.message:\"\"),index:this.index,filename:this.filename}}},toCSS:function(a){return this.eval(a).toCSS()}}}(c(\"../tree\")),function(a){a.Color=function(a,b){Array.isArray(a)?this.rgb=a:a.length==6?this.rgb=a.match(/.{2}/g).map(function(a){return parseInt(a,16)}):this.rgb=a.split(\"\").map(function(a){return parseInt(a+a,16)}),this.alpha=typeof b==\"number\"?b:1},a.Color.prototype={eval:function(){return this},toCSS:function(){return this.alpha<1?\"rgba(\"+this.rgb.map(function(a){return Math.round(a)}).concat(this.alpha).join(\", \")+\")\":\"#\"+this.rgb.map(function(a){return a=Math.round(a),a=(a>255?255:a<0?0:a).toString(16),a.length===1?\"0\"+a:a}).join(\"\")},operate:function(b,c){var d=[];c instanceof a.Color||(c=c.toColor());for(var e=0;e<3;e++)d[e]=a.operate(b,this.rgb[e],c.rgb[e]);return new a.Color(d,this.alpha+c.alpha)},toHSL:function(){var a=this.rgb[0]/255,b=this.rgb[1]/255,c=this.rgb[2]/255,d=this.alpha,e=Math.max(a,b,c),f=Math.min(a,b,c),g,h,i=(e+f)/2,j=e-f;if(e===f)g=h=0;else{h=i>.5?j/(2-e-f):j/(e+f);switch(e){case a:g=(b-c)/j+(b<c?6:0);break;case b:g=(c-a)/j+2;break;case c:g=(a-b)/j+4}g/=6}return{h:g*360,s:h,l:i,a:d}},toARGB:function(){var a=[Math.round(this.alpha*255)].concat(this.rgb);return\"#\"+a.map(function(a){return a=Math.round(a),a=(a>255?255:a<0?0:a).toString(16),a.length===1?\"0\"+a:a}).join(\"\")}}}(c(\"../tree\")),function(a){a.Comment=function(a,b){this.value=a,this.silent=!!b},a.Comment.prototype={toCSS:function(a){return a.compress?\"\":this.value},eval:function(){return this}}}(c(\"../tree\")),function(a){a.Condition=function(a,b,c,d,e){this.op=a.trim(),this.lvalue=b,this.rvalue=c,this.index=d,this.negate=e},a.Condition.prototype.eval=function(a){var b=this.lvalue.eval(a),c=this.rvalue.eval(a),d=this.index,e,e=function(a){switch(a){case\"and\":return b&&c;case\"or\":return b||c;default:if(b.compare)e=b.compare(c);else{if(!c.compare)throw{type:\"Type\",message:\"Unable to perform comparison\",index:d};e=c.compare(b)}switch(e){case-1:return a===\"<\"||a===\"=<\";case 0:return a===\"=\"||a===\">=\"||a===\"=<\";case 1:return a===\">\"||a===\">=\"}}}(this.op);return this.negate?!e:e}}(c(\"../tree\")),function(a){a.Dimension=function(a,b){this.value=parseFloat(a),this.unit=b||null},a.Dimension.prototype={eval:function(){return this},toColor:function(){return new a.Color([this.value,this.value,this.value])},toCSS:function(){var a=this.value+this.unit;return a},operate:function(b,c){return new a.Dimension(a.operate(b,this.value,c.value),this.unit||c.unit)},compare:function(b){return b instanceof a.Dimension?b.value>this.value?-1:b.value<this.value?1:0:-1}}}(c(\"../tree\")),function(a){a.Directive=function(b,c,d){this.name=b,this.features=d&&new a.Value(d),Array.isArray(c)?(this.ruleset=new a.Ruleset([],c),this.ruleset.allowImports=!0):this.value=c},a.Directive.prototype={toCSS:function(a,b){var c=this.features?\" \"+this.features.toCSS(b):\"\";return this.ruleset?(this.ruleset.root=!0,this.name+c+(b.compress?\"{\":\" {\\n  \")+this.ruleset.toCSS(a,b).trim().replace(/\\n/g,\"\\n  \")+(b.compress?\"}\":\"\\n}\\n\")):this.name+\" \"+this.value.toCSS()+\";\\n\"},eval:function(a){return this.features=this.features&&this.features.eval(a),a.frames.unshift(this),this.ruleset=this.ruleset&&this.ruleset.eval(a),a.frames.shift(),this},variable:function(b){return a.Ruleset.prototype.variable.call(this.ruleset,b)},find:function(){return a.Ruleset.prototype.find.apply(this.ruleset,arguments)},rulesets:function(){return a.Ruleset.prototype.rulesets.apply(this.ruleset)}}}(c(\"../tree\")),function(a){a.Element=function(b,c,d){this.combinator=b instanceof a.Combinator?b:new a.Combinator(b),typeof c==\"string\"?this.value=c.trim():c?this.value=c:this.value=\"\",this.index=d},a.Element.prototype.eval=function(b){return new a.Element(this.combinator,this.value.eval?this.value.eval(b):this.value,this.index)},a.Element.prototype.toCSS=function(a){return this.combinator.toCSS(a||{})+(this.value.toCSS?this.value.toCSS(a):this.value)},a.Combinator=function(a){a===\" \"?this.value=\" \":a===\"& \"?this.value=\"& \":this.value=a?a.trim():\"\"},a.Combinator.prototype.toCSS=function(a){return{\"\":\"\",\" \":\" \",\"&\":\"\",\"& \":\" \",\":\":\" :\",\"::\":\"::\",\"+\":a.compress?\"+\":\" + \",\"~\":a.compress?\"~\":\" ~ \",\">\":a.compress?\">\":\" > \"}[this.value]}}(c(\"../tree\")),function(a){a.Expression=function(a){this.value=a},a.Expression.prototype={eval:function(b){return this.value.length>1?new a.Expression(this.value.map(function(a){return a.eval(b)})):this.value.length===1?this.value[0].eval(b):this},toCSS:function(a){return this.value.map(function(b){return b.toCSS?b.toCSS(a):\"\"}).join(\" \")}}}(c(\"../tree\")),function(a){a.Import=function(b,c,d,e){var f=this;this.index=e,this._path=b,this.features=d&&new a.Value(d),b instanceof a.Quoted?this.path=/\\.(le?|c)ss(\\?.*)?$/.test(b.value)?b.value:b.value+\".less\":this.path=b.value.value||b.value,this.css=/css(\\?.*)?$/.test(this.path),this.css||c.push(this.path,function(b,c){b&&(b.index=e),f.root=c||new a.Ruleset([],[])})},a.Import.prototype={toCSS:function(a){var b=this.features?\" \"+this.features.toCSS(a):\"\";return this.css?\"@import \"+this._path.toCSS()+b+\";\\n\":\"\"},eval:function(b){var c,d=this.features&&this.features.eval(b);if(this.css)return this;c=new a.Ruleset([],this.root.rules.slice(0));for(var e=0;e<c.rules.length;e++)c.rules[e]instanceof a.Import&&Array.prototype.splice.apply(c.rules,[e,1].concat(c.rules[e].eval(b)));return this.features?new a.Directive(\"@media\",c.rules,this.features.value):c.rules}}}(c(\"../tree\")),function(a){a.JavaScript=function(a,b,c){this.escaped=c,this.expression=a,this.index=b},a.JavaScript.prototype={eval:function(b){var c,d=this,e={},f=this.expression.replace(/@\\{([\\w-]+)\\}/g,function(c,e){return a.jsify((new a.Variable(\"@\"+e,d.index)).eval(b))});try{f=new Function(\"return (\"+f+\")\")}catch(g){throw{message:\"JavaScript evaluation error: `\"+\nf+\"`\",index:this.index}}for(var h in b.frames[0].variables())e[h.slice(1)]={value:b.frames[0].variables()[h].value,toJS:function(){return this.value.eval(b).toCSS()}};try{c=f.call(e)}catch(g){throw{message:\"JavaScript evaluation error: '\"+g.name+\": \"+g.message+\"'\",index:this.index}}return typeof c==\"string\"?new a.Quoted('\"'+c+'\"',c,this.escaped,this.index):Array.isArray(c)?new a.Anonymous(c.join(\", \")):new a.Anonymous(c)}}}(c(\"../tree\")),function(a){a.Keyword=function(a){this.value=a},a.Keyword.prototype={eval:function(){return this},toCSS:function(){return this.value},compare:function(b){return b instanceof a.Keyword?b.value===this.value?0:1:-1}},a.True=new a.Keyword(\"true\"),a.False=new a.Keyword(\"false\")}(c(\"../tree\")),function(a){a.mixin={},a.mixin.Call=function(b,c,d,e,f){this.selector=new a.Selector(b),this.arguments=c,this.index=d,this.filename=e,this.important=f},a.mixin.Call.prototype={eval:function(a){var b,c,d=[],e=!1;for(var f=0;f<a.frames.length;f++)if((b=a.frames[f].find(this.selector)).length>0){c=this.arguments&&this.arguments.map(function(b){return b.eval(a)});for(var g=0;g<b.length;g++)if(b[g].match(c,a))try{Array.prototype.push.apply(d,b[g].eval(a,this.arguments,this.important).rules),e=!0}catch(h){throw{message:h.message,index:h.index,filename:this.filename,stack:h.stack,call:this.index}}if(e)return d;throw{type:\"Runtime\",message:\"No matching definition was found for `\"+this.selector.toCSS().trim()+\"(\"+this.arguments.map(function(a){return a.toCSS()}).join(\", \")+\")`\",index:this.index,filename:this.filename}}throw{type:\"Name\",message:this.selector.toCSS().trim()+\" is undefined\",index:this.index,filename:this.filename}}},a.mixin.Definition=function(b,c,d,e){this.name=b,this.selectors=[new a.Selector([new a.Element(null,b)])],this.params=c,this.condition=e,this.arity=c.length,this.rules=d,this._lookups={},this.required=c.reduce(function(a,b){return!b.name||b.name&&!b.value?a+1:a},0),this.parent=a.Ruleset.prototype,this.frames=[]},a.mixin.Definition.prototype={toCSS:function(){return\"\"},variable:function(a){return this.parent.variable.call(this,a)},variables:function(){return this.parent.variables.call(this)},find:function(){return this.parent.find.apply(this,arguments)},rulesets:function(){return this.parent.rulesets.apply(this)},evalParams:function(b,c){var d=new a.Ruleset(null,[]);for(var e=0,f;e<this.params.length;e++)if(this.params[e].name){if(!(f=c&&c[e]||this.params[e].value))throw{type:\"Runtime\",message:\"wrong number of arguments for \"+this.name+\" (\"+c.length+\" for \"+this.arity+\")\"};d.rules.unshift(new a.Rule(this.params[e].name,f.eval(b)))}return d},eval:function(b,c,d){var e=this.evalParams(b,c),f,g=[],h;for(var i=0;i<Math.max(this.params.length,c&&c.length);i++)g.push(c[i]||this.params[i].value);return e.rules.unshift(new a.Rule(\"@arguments\",(new a.Expression(g)).eval(b))),h=d?this.rules.map(function(b){return new a.Rule(b.name,b.value,\"!important\",b.index)}):this.rules.slice(0),(new a.Ruleset(null,h)).eval({frames:[this,e].concat(this.frames,b.frames)})},match:function(a,b){var c=a&&a.length||0,d,e;if(c<this.required)return!1;if(this.required>0&&c>this.params.length)return!1;if(this.condition&&!this.condition.eval({frames:[this.evalParams(b,a)].concat(b.frames)}))return!1;d=Math.min(c,this.arity);for(var f=0;f<d;f++)if(!this.params[f].name&&a[f].eval(b).toCSS()!=this.params[f].value.eval(b).toCSS())return!1;return!0}}}(c(\"../tree\")),function(a){a.Operation=function(a,b){this.op=a.trim(),this.operands=b},a.Operation.prototype.eval=function(b){var c=this.operands[0].eval(b),d=this.operands[1].eval(b),e;if(c instanceof a.Dimension&&d instanceof a.Color){if(this.op!==\"*\"&&this.op!==\"+\")throw{name:\"OperationError\",message:\"Can't substract or divide a color from a number\"};e=d,d=c,c=e}return c.operate(this.op,d)},a.operate=function(a,b,c){switch(a){case\"+\":return b+c;case\"-\":return b-c;case\"*\":return b*c;case\"/\":return b/c}}}(c(\"../tree\")),function(a){a.Paren=function(a){this.value=a},a.Paren.prototype={toCSS:function(a){return\"(\"+this.value.toCSS(a)+\")\"},eval:function(b){return new a.Paren(this.value.eval(b))}}}(c(\"../tree\")),function(a){a.Quoted=function(a,b,c,d){this.escaped=c,this.value=b||\"\",this.quote=a.charAt(0),this.index=d},a.Quoted.prototype={toCSS:function(){return this.escaped?this.value:this.quote+this.value+this.quote},eval:function(b){var c=this,d=this.value.replace(/`([^`]+)`/g,function(d,e){return(new a.JavaScript(e,c.index,!0)).eval(b).value}).replace(/@\\{([\\w-]+)\\}/g,function(d,e){var f=(new a.Variable(\"@\"+e,c.index)).eval(b);return\"value\"in f?f.value:f.toCSS()});return new a.Quoted(this.quote+d+this.quote,d,this.escaped,this.index)}}}(c(\"../tree\")),function(a){a.Rule=function(b,c,d,e,f){this.name=b,this.value=c instanceof a.Value?c:new a.Value([c]),this.important=d?\" \"+d.trim():\"\",this.index=e,this.inline=f||!1,b.charAt(0)===\"@\"?this.variable=!0:this.variable=!1},a.Rule.prototype.toCSS=function(a){return this.variable?\"\":this.name+(a.compress?\":\":\": \")+this.value.toCSS(a)+this.important+(this.inline?\"\":\";\")},a.Rule.prototype.eval=function(b){return new a.Rule(this.name,this.value.eval(b),this.important,this.index,this.inline)},a.Shorthand=function(a,b){this.a=a,this.b=b},a.Shorthand.prototype={toCSS:function(a){return this.a.toCSS(a)+\"/\"+this.b.toCSS(a)},eval:function(){return this}}}(c(\"../tree\")),function(a){a.Ruleset=function(a,b){this.selectors=a,this.rules=b,this._lookups={}},a.Ruleset.prototype={eval:function(b){var c=this.selectors&&this.selectors.map(function(a){return a.eval(b)}),d=new a.Ruleset(c,this.rules.slice(0));d.root=this.root,d.allowImports=this.allowImports,b.frames.unshift(d);if(d.root||d.allowImports)for(var e=0;e<d.rules.length;e++)d.rules[e]instanceof a.Import&&Array.prototype.splice.apply(d.rules,[e,1].concat(d.rules[e].eval(b)));for(var e=0;e<d.rules.length;e++)d.rules[e]instanceof a.mixin.Definition&&(d.rules[e].frames=b.frames.slice(0));for(var e=0;e<d.rules.length;e++)d.rules[e]instanceof a.mixin.Call&&Array.prototype.splice.apply(d.rules,[e,1].concat(d.rules[e].eval(b)));for(var e=0,f;e<d.rules.length;e++)f=d.rules[e],f instanceof a.mixin.Definition||(d.rules[e]=f.eval?f.eval(b):f);return b.frames.shift(),d},match:function(a){return!a||a.length===0},variables:function(){return this._variables?this._variables:this._variables=this.rules.reduce(function(b,c){return c instanceof a.Rule&&c.variable===!0&&(b[c.name]=c),b},{})},variable:function(a){return this.variables()[a]},rulesets:function(){return this._rulesets?this._rulesets:this._rulesets=this.rules.filter(function(b){return b instanceof a.Ruleset||b instanceof a.mixin.Definition})},find:function(b,c){c=c||this;var d=[],e,f,g=b.toCSS();return g in this._lookups?this._lookups[g]:(this.rulesets().forEach(function(e){if(e!==c)for(var g=0;g<e.selectors.length;g++)if(f=b.match(e.selectors[g])){b.elements.length>e.selectors[g].elements.length?Array.prototype.push.apply(d,e.find(new a.Selector(b.elements.slice(1)),c)):d.push(e);break}}),this._lookups[g]=d)},toCSS:function(b,c){var d=[],e=[],f=[],g=[],h,i;this.root||(b.length===0?g=this.selectors.map(function(a){return[a]}):this.joinSelectors(g,b,this.selectors));for(var j=0;j<this.rules.length;j++)i=this.rules[j],i.rules||i instanceof a.Directive?f.push(i.toCSS(g,c)):i instanceof a.Comment?i.silent||(this.root?f.push(i.toCSS(c)):e.push(i.toCSS(c))):i.toCSS&&!i.variable?e.push(i.toCSS(c)):i.value&&!i.variable&&e.push(i.value.toString());return f=f.join(\"\"),this.root?d.push(e.join(c.compress?\"\":\"\\n\")):e.length>0&&(h=g.map(function(a){return a.map(function(a){return a.toCSS(c)}).join(\"\").trim()}).join(c.compress?\",\":g.length>3?\",\\n\":\", \"),d.push(h,(c.compress?\"{\":\" {\\n  \")+e.join(c.compress?\"\":\"\\n  \")+(c.compress?\"}\":\"\\n}\\n\"))),d.push(f),d.join(\"\")+(c.compress?\"\\n\":\"\")},joinSelectors:function(a,b,c){for(var d=0;d<c.length;d++)this.joinSelector(a,b,c[d])},joinSelector:function(b,c,d){var e=[],f=[],g=[],h=[],i=!1,j;for(var k=0;k<d.elements.length;k++)j=d.elements[k],j.combinator.value.charAt(0)===\"&\"&&(i=!0),i?h.push(j):g.push(j);i||(h=g,g=[]),g.length>0&&e.push(new a.Selector(g)),h.length>0&&f.push(new a.Selector(h));for(var l=0;l<c.length;l++)b.push(e.concat(c[l]).concat(f))}}}(c(\"../tree\")),function(a){a.Selector=function(a){this.elements=a,this.elements[0].combinator.value===\"\"&&(this.elements[0].combinator.value=\" \")},a.Selector.prototype.match=function(a){var b=this.elements.length,c=a.elements.length,d=Math.min(b,c);if(b<c)return!1;for(var e=0;e<d;e++)if(this.elements[e].value!==a.elements[e].value)return!1;return!0},a.Selector.prototype.eval=function(b){return new a.Selector(this.elements.map(function(a){return a.eval(b)}))},a.Selector.prototype.toCSS=function(a){return this._css?this._css:this._css=this.elements.map(function(b){return typeof b==\"string\"?\" \"+b.trim():b.toCSS(a)}).join(\"\")}}(c(\"../tree\")),function(b){b.URL=function(b,c){b.data?this.attrs=b:(typeof a!=\"undefined\"&&!/^(?:https?:\\/\\/|file:\\/\\/|data:|\\/)/.test(b.value)&&c.length>0&&(b.value=c[0]+(b.value.charAt(0)===\"/\"?b.value.slice(1):b.value)),this.value=b,this.paths=c)},b.URL.prototype={toCSS:function(){return\"url(\"+(this.attrs?\"data:\"+this.attrs.mime+this.attrs.charset+this.attrs.base64+this.attrs.data:this.value.toCSS())+\")\"},eval:function(a){return this.attrs?this:new b.URL(this.value.eval(a),this.paths)}}}(c(\"../tree\")),function(a){a.Value=function(a){this.value=a,this.is=\"value\"},a.Value.prototype={eval:function(b){return this.value.length===1?this.value[0].eval(b):new a.Value(this.value.map(function(a){return a.eval(b)}))},toCSS:function(a){return this.value.map(function(b){return b.toCSS(a)}).join(a.compress?\",\":\", \")}}}(c(\"../tree\")),function(a){a.Variable=function(a,b,c){this.name=a,this.index=b,this.file=c},a.Variable.prototype={eval:function(b){var c,d,e=this.name;e.indexOf(\"@@\")==0&&(e=\"@\"+(new a.Variable(e.slice(1))).eval(b).value);if(c=a.find(b.frames,function(a){if(d=a.variable(e))return d.value.eval(b)}))return c;throw{type:\"Name\",message:\"variable \"+e+\" is undefined\",filename:this.file,index:this.index}}}}(c(\"../tree\")),function(a){a.find=function(a,b){for(var c=0,d;c<a.length;c++)if(d=b.call(a,a[c]))return d;return null},a.jsify=function(a){return Array.isArray(a.value)&&a.value.length>1?\"[\"+a.value.map(function(a){return a.toCSS(!1)}).join(\", \")+\"]\":a.toCSS(!1)}}(c(\"./tree\"));var g=location.protocol===\"file:\"||location.protocol===\"chrome:\"||location.protocol===\"chrome-extension:\"||location.protocol===\"resource:\";d.env=d.env||(location.hostname==\"127.0.0.1\"||location.hostname==\"0.0.0.0\"||location.hostname==\"localhost\"||location.port.length>0||g?\"development\":\"production\"),d.async=!1,d.poll=d.poll||(g?1e3:1500),d.watch=function(){return this.watchMode=!0},d.unwatch=function(){return this.watchMode=!1},d.env===\"development\"?(d.optimization=0,/!watch/.test(location.hash)&&d.watch(),d.watchTimer=setInterval(function(){d.watchMode&&n(function(a,b,c,d,e){b&&r(b.toCSS(),d,e.lastModified)})},d.poll)):d.optimization=3;var h;try{h=typeof a.localStorage==\"undefined\"?null:a.localStorage}catch(i){h=null}var j=document.getElementsByTagName(\"link\"),k=/^text\\/(x-)?less$/;d.sheets=[];for(var l=0;l<j.length;l++)(j[l].rel===\"stylesheet/less\"||j[l].rel.match(/stylesheet/)&&j[l].type.match(k))&&d.sheets.push(j[l]);d.refresh=function(a){var b,c;b=c=new Date,n(function(a,d,e,f,g){g.local?v(\"loading \"+f.href+\" from cache.\"):(v(\"parsed \"+f.href+\" successfully.\"),r(d.toCSS(),f,g.lastModified)),v(\"css for \"+f.href+\" generated in \"+(new Date-c)+\"ms\"),g.remaining===0&&v(\"css generated in \"+(new Date-b)+\"ms\"),c=new Date},a),m()},d.refreshStyles=m,d.refresh(d.env===\"development\")})(window);\n","/home/travis/build/npmtest/node-npmtest-kss/node_modules/kss/gh-pages/public/prettify.js":"// Copyright (C) 2006 Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n/**\n * @fileoverview\n * some functions for browser-side pretty printing of code contained in html.\n *\n * <p>\n * For a fairly comprehensive set of languages see the\n * <a href=\"http://google-code-prettify.googlecode.com/svn/trunk/README.html#langs\">README</a>\n * file that came with this source.  At a minimum, the lexer should work on a\n * number of languages including C and friends, Java, Python, Bash, SQL, HTML,\n * XML, CSS, Javascript, and Makefiles.  It works passably on Ruby, PHP and Awk\n * and a subset of Perl, but, because of commenting conventions, doesn't work on\n * Smalltalk, Lisp-like, or CAML-like languages without an explicit lang class.\n * <p>\n * Usage: <ol>\n * <li> include this source file in an html page via\n *   {@code <script type=\"text/javascript\" src=\"/path/to/prettify.js\"></script>}\n * <li> define style rules.  See the example page for examples.\n * <li> mark the {@code <pre>} and {@code <code>} tags in your source with\n *    {@code class=prettyprint.}\n *    You can also use the (html deprecated) {@code <xmp>} tag, but the pretty\n *    printer needs to do more substantial DOM manipulations to support that, so\n *    some css styles may not be preserved.\n * </ol>\n * That's it.  I wanted to keep the API as simple as possible, so there's no\n * need to specify which language the code is in, but if you wish, you can add\n * another class to the {@code <pre>} or {@code <code>} element to specify the\n * language, as in {@code <pre class=\"prettyprint lang-java\">}.  Any class that\n * starts with \"lang-\" followed by a file extension, specifies the file type.\n * See the \"lang-*.js\" files in this directory for code that implements\n * per-language file handlers.\n * <p>\n * Change log:<br>\n * cbeust, 2006/08/22\n * <blockquote>\n *   Java annotations (start with \"@\") are now captured as literals (\"lit\")\n * </blockquote>\n * @requires console\n */\n\n// JSLint declarations\n/*global console, document, navigator, setTimeout, window */\n\n/**\n * Split {@code prettyPrint} into multiple timeouts so as not to interfere with\n * UI events.\n * If set to {@code false}, {@code prettyPrint()} is synchronous.\n */\nwindow['PR_SHOULD_USE_CONTINUATION'] = true;\n\n(function () {\n  // Keyword lists for various languages.\n  // We use things that coerce to strings to make them compact when minified\n  // and to defeat aggressive optimizers that fold large string constants.\n  var FLOW_CONTROL_KEYWORDS = [\"break,continue,do,else,for,if,return,while\"];\n  var C_KEYWORDS = [FLOW_CONTROL_KEYWORDS,\"auto,case,char,const,default,\" + \n      \"double,enum,extern,float,goto,int,long,register,short,signed,sizeof,\" +\n      \"static,struct,switch,typedef,union,unsigned,void,volatile\"];\n  var COMMON_KEYWORDS = [C_KEYWORDS,\"catch,class,delete,false,import,\" +\n      \"new,operator,private,protected,public,this,throw,true,try,typeof\"];\n  var CPP_KEYWORDS = [COMMON_KEYWORDS,\"alignof,align_union,asm,axiom,bool,\" +\n      \"concept,concept_map,const_cast,constexpr,decltype,\" +\n      \"dynamic_cast,explicit,export,friend,inline,late_check,\" +\n      \"mutable,namespace,nullptr,reinterpret_cast,static_assert,static_cast,\" +\n      \"template,typeid,typename,using,virtual,where\"];\n  var JAVA_KEYWORDS = [COMMON_KEYWORDS,\n      \"abstract,boolean,byte,extends,final,finally,implements,import,\" +\n      \"instanceof,null,native,package,strictfp,super,synchronized,throws,\" +\n      \"transient\"];\n  var CSHARP_KEYWORDS = [JAVA_KEYWORDS,\n      \"as,base,by,checked,decimal,delegate,descending,dynamic,event,\" +\n      \"fixed,foreach,from,group,implicit,in,interface,internal,into,is,lock,\" +\n      \"object,out,override,orderby,params,partial,readonly,ref,sbyte,sealed,\" +\n      \"stackalloc,string,select,uint,ulong,unchecked,unsafe,ushort,var\"];\n  var COFFEE_KEYWORDS = \"all,and,by,catch,class,else,extends,false,finally,\" +\n      \"for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,\" +\n      \"true,try,unless,until,when,while,yes\";\n  var JSCRIPT_KEYWORDS = [COMMON_KEYWORDS,\n      \"debugger,eval,export,function,get,null,set,undefined,var,with,\" +\n      \"Infinity,NaN\"];\n  var PERL_KEYWORDS = \"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,\" +\n      \"goto,if,import,last,local,my,next,no,our,print,package,redo,require,\" +\n      \"sub,undef,unless,until,use,wantarray,while,BEGIN,END\";\n  var PYTHON_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"and,as,assert,class,def,del,\" +\n      \"elif,except,exec,finally,from,global,import,in,is,lambda,\" +\n      \"nonlocal,not,or,pass,print,raise,try,with,yield,\" +\n      \"False,True,None\"];\n  var RUBY_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"alias,and,begin,case,class,\" +\n      \"def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,\" +\n      \"rescue,retry,self,super,then,true,undef,unless,until,when,yield,\" +\n      \"BEGIN,END\"];\n  var SH_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"case,done,elif,esac,eval,fi,\" +\n      \"function,in,local,set,then,until\"];\n  var ALL_KEYWORDS = [\n      CPP_KEYWORDS, CSHARP_KEYWORDS, JSCRIPT_KEYWORDS, PERL_KEYWORDS +\n      PYTHON_KEYWORDS, RUBY_KEYWORDS, SH_KEYWORDS];\n  var C_TYPES = /^(DIR|FILE|vector|(de|priority_)?queue|list|stack|(const_)?iterator|(multi)?(set|map)|bitset|u?(int|float)\\d*)/;\n\n  // token style names.  correspond to css classes\n  /**\n   * token style for a string literal\n   * @const\n   */\n  var PR_STRING = 'str';\n  /**\n   * token style for a keyword\n   * @const\n   */\n  var PR_KEYWORD = 'kwd';\n  /**\n   * token style for a comment\n   * @const\n   */\n  var PR_COMMENT = 'com';\n  /**\n   * token style for a type\n   * @const\n   */\n  var PR_TYPE = 'typ';\n  /**\n   * token style for a literal value.  e.g. 1, null, true.\n   * @const\n   */\n  var PR_LITERAL = 'lit';\n  /**\n   * token style for a punctuation string.\n   * @const\n   */\n  var PR_PUNCTUATION = 'pun';\n  /**\n   * token style for a punctuation string.\n   * @const\n   */\n  var PR_PLAIN = 'pln';\n\n  /**\n   * token style for an sgml tag.\n   * @const\n   */\n  var PR_TAG = 'tag';\n  /**\n   * token style for a markup declaration such as a DOCTYPE.\n   * @const\n   */\n  var PR_DECLARATION = 'dec';\n  /**\n   * token style for embedded source.\n   * @const\n   */\n  var PR_SOURCE = 'src';\n  /**\n   * token style for an sgml attribute name.\n   * @const\n   */\n  var PR_ATTRIB_NAME = 'atn';\n  /**\n   * token style for an sgml attribute value.\n   * @const\n   */\n  var PR_ATTRIB_VALUE = 'atv';\n\n  /**\n   * A class that indicates a section of markup that is not code, e.g. to allow\n   * embedding of line numbers within code listings.\n   * @const\n   */\n  var PR_NOCODE = 'nocode';\n\n\n\n/**\n * A set of tokens that can precede a regular expression literal in\n * javascript\n * http://web.archive.org/web/20070717142515/http://www.mozilla.org/js/language/js20/rationale/syntax.html\n * has the full list, but I've removed ones that might be problematic when\n * seen in languages that don't support regular expression literals.\n *\n * <p>Specifically, I've removed any keywords that can't precede a regexp\n * literal in a syntactically legal javascript program, and I've removed the\n * \"in\" keyword since it's not a keyword in many languages, and might be used\n * as a count of inches.\n *\n * <p>The link a above does not accurately describe EcmaScript rules since\n * it fails to distinguish between (a=++/b/i) and (a++/b/i) but it works\n * very well in practice.\n *\n * @private\n * @const\n */\nvar REGEXP_PRECEDER_PATTERN = '(?:^^\\\\.?|[+-]|\\\\!|\\\\!=|\\\\!==|\\\\#|\\\\%|\\\\%=|&|&&|&&=|&=|\\\\(|\\\\*|\\\\*=|\\\\+=|\\\\,|\\\\-=|\\\\->|\\\\/|\\\\/=|:|::|\\\\;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\\\?|\\\\@|\\\\[|\\\\^|\\\\^=|\\\\^\\\\^|\\\\^\\\\^=|\\\\{|\\\\||\\\\|=|\\\\|\\\\||\\\\|\\\\|=|\\\\~|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\\\s*';\n\n// CAVEAT: this does not properly handle the case where a regular\n// expression immediately follows another since a regular expression may\n// have flags for case-sensitivity and the like.  Having regexp tokens\n// adjacent is not valid in any language I'm aware of, so I'm punting.\n// TODO: maybe style special characters inside a regexp as punctuation.\n\n\n  /**\n   * Given a group of {@link RegExp}s, returns a {@code RegExp} that globally\n   * matches the union of the sets of strings matched by the input RegExp.\n   * Since it matches globally, if the input strings have a start-of-input\n   * anchor (/^.../), it is ignored for the purposes of unioning.\n   * @param {Array.<RegExp>} regexs non multiline, non-global regexs.\n   * @return {RegExp} a global regex.\n   */\n  function combinePrefixPatterns(regexs) {\n    var capturedGroupIndex = 0;\n  \n    var needToFoldCase = false;\n    var ignoreCase = false;\n    for (var i = 0, n = regexs.length; i < n; ++i) {\n      var regex = regexs[i];\n      if (regex.ignoreCase) {\n        ignoreCase = true;\n      } else if (/[a-z]/i.test(regex.source.replace(\n                     /\\\\u[0-9a-f]{4}|\\\\x[0-9a-f]{2}|\\\\[^ux]/gi, ''))) {\n        needToFoldCase = true;\n        ignoreCase = false;\n        break;\n      }\n    }\n  \n    var escapeCharToCodeUnit = {\n      'b': 8,\n      't': 9,\n      'n': 0xa,\n      'v': 0xb,\n      'f': 0xc,\n      'r': 0xd\n    };\n  \n    function decodeEscape(charsetPart) {\n      var cc0 = charsetPart.charCodeAt(0);\n      if (cc0 !== 92 /* \\\\ */) {\n        return cc0;\n      }\n      var c1 = charsetPart.charAt(1);\n      cc0 = escapeCharToCodeUnit[c1];\n      if (cc0) {\n        return cc0;\n      } else if ('0' <= c1 && c1 <= '7') {\n        return parseInt(charsetPart.substring(1), 8);\n      } else if (c1 === 'u' || c1 === 'x') {\n        return parseInt(charsetPart.substring(2), 16);\n      } else {\n        return charsetPart.charCodeAt(1);\n      }\n    }\n  \n    function encodeEscape(charCode) {\n      if (charCode < 0x20) {\n        return (charCode < 0x10 ? '\\\\x0' : '\\\\x') + charCode.toString(16);\n      }\n      var ch = String.fromCharCode(charCode);\n      if (ch === '\\\\' || ch === '-' || ch === '[' || ch === ']') {\n        ch = '\\\\' + ch;\n      }\n      return ch;\n    }\n  \n    function caseFoldCharset(charSet) {\n      var charsetParts = charSet.substring(1, charSet.length - 1).match(\n          new RegExp(\n              '\\\\\\\\u[0-9A-Fa-f]{4}'\n              + '|\\\\\\\\x[0-9A-Fa-f]{2}'\n              + '|\\\\\\\\[0-3][0-7]{0,2}'\n              + '|\\\\\\\\[0-7]{1,2}'\n              + '|\\\\\\\\[\\\\s\\\\S]'\n              + '|-'\n              + '|[^-\\\\\\\\]',\n              'g'));\n      var groups = [];\n      var ranges = [];\n      var inverse = charsetParts[0] === '^';\n      for (var i = inverse ? 1 : 0, n = charsetParts.length; i < n; ++i) {\n        var p = charsetParts[i];\n        if (/\\\\[bdsw]/i.test(p)) {  // Don't muck with named groups.\n          groups.push(p);\n        } else {\n          var start = decodeEscape(p);\n          var end;\n          if (i + 2 < n && '-' === charsetParts[i + 1]) {\n            end = decodeEscape(charsetParts[i + 2]);\n            i += 2;\n          } else {\n            end = start;\n          }\n          ranges.push([start, end]);\n          // If the range might intersect letters, then expand it.\n          // This case handling is too simplistic.\n          // It does not deal with non-latin case folding.\n          // It works for latin source code identifiers though.\n          if (!(end < 65 || start > 122)) {\n            if (!(end < 65 || start > 90)) {\n              ranges.push([Math.max(65, start) | 32, Math.min(end, 90) | 32]);\n            }\n            if (!(end < 97 || start > 122)) {\n              ranges.push([Math.max(97, start) & ~32, Math.min(end, 122) & ~32]);\n            }\n          }\n        }\n      }\n  \n      // [[1, 10], [3, 4], [8, 12], [14, 14], [16, 16], [17, 17]]\n      // -> [[1, 12], [14, 14], [16, 17]]\n      ranges.sort(function (a, b) { return (a[0] - b[0]) || (b[1]  - a[1]); });\n      var consolidatedRanges = [];\n      var lastRange = [NaN, NaN];\n      for (var i = 0; i < ranges.length; ++i) {\n        var range = ranges[i];\n        if (range[0] <= lastRange[1] + 1) {\n          lastRange[1] = Math.max(lastRange[1], range[1]);\n        } else {\n          consolidatedRanges.push(lastRange = range);\n        }\n      }\n  \n      var out = ['['];\n      if (inverse) { out.push('^'); }\n      out.push.apply(out, groups);\n      for (var i = 0; i < consolidatedRanges.length; ++i) {\n        var range = consolidatedRanges[i];\n        out.push(encodeEscape(range[0]));\n        if (range[1] > range[0]) {\n          if (range[1] + 1 > range[0]) { out.push('-'); }\n          out.push(encodeEscape(range[1]));\n        }\n      }\n      out.push(']');\n      return out.join('');\n    }\n  \n    function allowAnywhereFoldCaseAndRenumberGroups(regex) {\n      // Split into character sets, escape sequences, punctuation strings\n      // like ('(', '(?:', ')', '^'), and runs of characters that do not\n      // include any of the above.\n      var parts = regex.source.match(\n          new RegExp(\n              '(?:'\n              + '\\\\[(?:[^\\\\x5C\\\\x5D]|\\\\\\\\[\\\\s\\\\S])*\\\\]'  // a character set\n              + '|\\\\\\\\u[A-Fa-f0-9]{4}'  // a unicode escape\n              + '|\\\\\\\\x[A-Fa-f0-9]{2}'  // a hex escape\n              + '|\\\\\\\\[0-9]+'  // a back-reference or octal escape\n              + '|\\\\\\\\[^ux0-9]'  // other escape sequence\n              + '|\\\\(\\\\?[:!=]'  // start of a non-capturing group\n              + '|[\\\\(\\\\)\\\\^]'  // start/emd of a group, or line start\n              + '|[^\\\\x5B\\\\x5C\\\\(\\\\)\\\\^]+'  // run of other characters\n              + ')',\n              'g'));\n      var n = parts.length;\n  \n      // Maps captured group numbers to the number they will occupy in\n      // the output or to -1 if that has not been determined, or to\n      // undefined if they need not be capturing in the output.\n      var capturedGroups = [];\n  \n      // Walk over and identify back references to build the capturedGroups\n      // mapping.\n      for (var i = 0, groupIndex = 0; i < n; ++i) {\n        var p = parts[i];\n        if (p === '(') {\n          // groups are 1-indexed, so max group index is count of '('\n          ++groupIndex;\n        } else if ('\\\\' === p.charAt(0)) {\n          var decimalValue = +p.substring(1);\n          if (decimalValue && decimalValue <= groupIndex) {\n            capturedGroups[decimalValue] = -1;\n          }\n        }\n      }\n  \n      // Renumber groups and reduce capturing groups to non-capturing groups\n      // where possible.\n      for (var i = 1; i < capturedGroups.length; ++i) {\n        if (-1 === capturedGroups[i]) {\n          capturedGroups[i] = ++capturedGroupIndex;\n        }\n      }\n      for (var i = 0, groupIndex = 0; i < n; ++i) {\n        var p = parts[i];\n        if (p === '(') {\n          ++groupIndex;\n          if (capturedGroups[groupIndex] === undefined) {\n            parts[i] = '(?:';\n          }\n        } else if ('\\\\' === p.charAt(0)) {\n          var decimalValue = +p.substring(1);\n          if (decimalValue && decimalValue <= groupIndex) {\n            parts[i] = '\\\\' + capturedGroups[groupIndex];\n          }\n        }\n      }\n  \n      // Remove any prefix anchors so that the output will match anywhere.\n      // ^^ really does mean an anchored match though.\n      for (var i = 0, groupIndex = 0; i < n; ++i) {\n        if ('^' === parts[i] && '^' !== parts[i + 1]) { parts[i] = ''; }\n      }\n  \n      // Expand letters to groups to handle mixing of case-sensitive and\n      // case-insensitive patterns if necessary.\n      if (regex.ignoreCase && needToFoldCase) {\n        for (var i = 0; i < n; ++i) {\n          var p = parts[i];\n          var ch0 = p.charAt(0);\n          if (p.length >= 2 && ch0 === '[') {\n            parts[i] = caseFoldCharset(p);\n          } else if (ch0 !== '\\\\') {\n            // TODO: handle letters in numeric escapes.\n            parts[i] = p.replace(\n                /[a-zA-Z]/g,\n                function (ch) {\n                  var cc = ch.charCodeAt(0);\n                  return '[' + String.fromCharCode(cc & ~32, cc | 32) + ']';\n                });\n          }\n        }\n      }\n  \n      return parts.join('');\n    }\n  \n    var rewritten = [];\n    for (var i = 0, n = regexs.length; i < n; ++i) {\n      var regex = regexs[i];\n      if (regex.global || regex.multiline) { throw new Error('' + regex); }\n      rewritten.push(\n          '(?:' + allowAnywhereFoldCaseAndRenumberGroups(regex) + ')');\n    }\n  \n    return new RegExp(rewritten.join('|'), ignoreCase ? 'gi' : 'g');\n  }\n\n\n  /**\n   * Split markup into a string of source code and an array mapping ranges in\n   * that string to the text nodes in which they appear.\n   *\n   * <p>\n   * The HTML DOM structure:</p>\n   * <pre>\n   * (Element   \"p\"\n   *   (Element \"b\"\n   *     (Text  \"print \"))       ; #1\n   *   (Text    \"'Hello '\")      ; #2\n   *   (Element \"br\")            ; #3\n   *   (Text    \"  + 'World';\")) ; #4\n   * </pre>\n   * <p>\n   * corresponds to the HTML\n   * {@code <p><b>print </b>'Hello '<br>  + 'World';</p>}.</p>\n   *\n   * <p>\n   * It will produce the output:</p>\n   * <pre>\n   * {\n   *   sourceCode: \"print 'Hello '\\n  + 'World';\",\n   *   //                 1         2\n   *   //       012345678901234 5678901234567\n   *   spans: [0, #1, 6, #2, 14, #3, 15, #4]\n   * }\n   * </pre>\n   * <p>\n   * where #1 is a reference to the {@code \"print \"} text node above, and so\n   * on for the other text nodes.\n   * </p>\n   *\n   * <p>\n   * The {@code} spans array is an array of pairs.  Even elements are the start\n   * indices of substrings, and odd elements are the text nodes (or BR elements)\n   * that contain the text for those substrings.\n   * Substrings continue until the next index or the end of the source.\n   * </p>\n   *\n   * @param {Node} node an HTML DOM subtree containing source-code.\n   * @return {Object} source code and the text nodes in which they occur.\n   */\n  function extractSourceSpans(node) {\n    var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\n  \n    var chunks = [];\n    var length = 0;\n    var spans = [];\n    var k = 0;\n  \n    var whitespace;\n    if (node.currentStyle) {\n      whitespace = node.currentStyle.whiteSpace;\n    } else if (window.getComputedStyle) {\n      whitespace = document.defaultView.getComputedStyle(node, null)\n          .getPropertyValue('white-space');\n    }\n    var isPreformatted = whitespace && 'pre' === whitespace.substring(0, 3);\n  \n    function walk(node) {\n      switch (node.nodeType) {\n        case 1:  // Element\n          if (nocode.test(node.className)) { return; }\n          for (var child = node.firstChild; child; child = child.nextSibling) {\n            walk(child);\n          }\n          var nodeName = node.nodeName;\n          if ('BR' === nodeName || 'LI' === nodeName) {\n            chunks[k] = '\\n';\n            spans[k << 1] = length++;\n            spans[(k++ << 1) | 1] = node;\n          }\n          break;\n        case 3: case 4:  // Text\n          var text = node.nodeValue;\n          if (text.length) {\n            if (!isPreformatted) {\n              text = text.replace(/[ \\t\\r\\n]+/g, ' ');\n            } else {\n              text = text.replace(/\\r\\n?/g, '\\n');  // Normalize newlines.\n            }\n            // TODO: handle tabs here?\n            chunks[k] = text;\n            spans[k << 1] = length;\n            length += text.length;\n            spans[(k++ << 1) | 1] = node;\n          }\n          break;\n      }\n    }\n  \n    walk(node);\n  \n    return {\n      sourceCode: chunks.join('').replace(/\\n$/, ''),\n      spans: spans\n    };\n  }\n\n\n  /**\n   * Apply the given language handler to sourceCode and add the resulting\n   * decorations to out.\n   * @param {number} basePos the index of sourceCode within the chunk of source\n   *    whose decorations are already present on out.\n   */\n  function appendDecorations(basePos, sourceCode, langHandler, out) {\n    if (!sourceCode) { return; }\n    var job = {\n      sourceCode: sourceCode,\n      basePos: basePos\n    };\n    langHandler(job);\n    out.push.apply(out, job.decorations);\n  }\n\n  var notWs = /\\S/;\n\n  /**\n   * Given an element, if it contains only one child element and any text nodes\n   * it contains contain only space characters, return the sole child element.\n   * Otherwise returns undefined.\n   * <p>\n   * This is meant to return the CODE element in {@code <pre><code ...>} when\n   * there is a single child element that contains all the non-space textual\n   * content, but not to return anything where there are multiple child elements\n   * as in {@code <pre><code>...</code><code>...</code></pre>} or when there\n   * is textual content.\n   */\n  function childContentWrapper(element) {\n    var wrapper = undefined;\n    for (var c = element.firstChild; c; c = c.nextSibling) {\n      var type = c.nodeType;\n      wrapper = (type === 1)  // Element Node\n          ? (wrapper ? element : c)\n          : (type === 3)  // Text Node\n          ? (notWs.test(c.nodeValue) ? element : wrapper)\n          : wrapper;\n    }\n    return wrapper === element ? undefined : wrapper;\n  }\n\n  /** Given triples of [style, pattern, context] returns a lexing function,\n    * The lexing function interprets the patterns to find token boundaries and\n    * returns a decoration list of the form\n    * [index_0, style_0, index_1, style_1, ..., index_n, style_n]\n    * where index_n is an index into the sourceCode, and style_n is a style\n    * constant like PR_PLAIN.  index_n-1 <= index_n, and style_n-1 applies to\n    * all characters in sourceCode[index_n-1:index_n].\n    *\n    * The stylePatterns is a list whose elements have the form\n    * [style : string, pattern : RegExp, DEPRECATED, shortcut : string].\n    *\n    * Style is a style constant like PR_PLAIN, or can be a string of the\n    * form 'lang-FOO', where FOO is a language extension describing the\n    * language of the portion of the token in $1 after pattern executes.\n    * E.g., if style is 'lang-lisp', and group 1 contains the text\n    * '(hello (world))', then that portion of the token will be passed to the\n    * registered lisp handler for formatting.\n    * The text before and after group 1 will be restyled using this decorator\n    * so decorators should take care that this doesn't result in infinite\n    * recursion.  For example, the HTML lexer rule for SCRIPT elements looks\n    * something like ['lang-js', /<[s]cript>(.+?)<\\/script>/].  This may match\n    * '<script>foo()<\\/script>', which would cause the current decorator to\n    * be called with '<script>' which would not match the same rule since\n    * group 1 must not be empty, so it would be instead styled as PR_TAG by\n    * the generic tag rule.  The handler registered for the 'js' extension would\n    * then be called with 'foo()', and finally, the current decorator would\n    * be called with '<\\/script>' which would not match the original rule and\n    * so the generic tag rule would identify it as a tag.\n    *\n    * Pattern must only match prefixes, and if it matches a prefix, then that\n    * match is considered a token with the same style.\n    *\n    * Context is applied to the last non-whitespace, non-comment token\n    * recognized.\n    *\n    * Shortcut is an optional string of characters, any of which, if the first\n    * character, gurantee that this pattern and only this pattern matches.\n    *\n    * @param {Array} shortcutStylePatterns patterns that always start with\n    *   a known character.  Must have a shortcut string.\n    * @param {Array} fallthroughStylePatterns patterns that will be tried in\n    *   order if the shortcut ones fail.  May have shortcuts.\n    *\n    * @return {function (Object)} a\n    *   function that takes source code and returns a list of decorations.\n    */\n  function createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns) {\n    var shortcuts = {};\n    var tokenizer;\n    (function () {\n      var allPatterns = shortcutStylePatterns.concat(fallthroughStylePatterns);\n      var allRegexs = [];\n      var regexKeys = {};\n      for (var i = 0, n = allPatterns.length; i < n; ++i) {\n        var patternParts = allPatterns[i];\n        var shortcutChars = patternParts[3];\n        if (shortcutChars) {\n          for (var c = shortcutChars.length; --c >= 0;) {\n            shortcuts[shortcutChars.charAt(c)] = patternParts;\n          }\n        }\n        var regex = patternParts[1];\n        var k = '' + regex;\n        if (!regexKeys.hasOwnProperty(k)) {\n          allRegexs.push(regex);\n          regexKeys[k] = null;\n        }\n      }\n      allRegexs.push(/[\\0-\\uffff]/);\n      tokenizer = combinePrefixPatterns(allRegexs);\n    })();\n\n    var nPatterns = fallthroughStylePatterns.length;\n\n    /**\n     * Lexes job.sourceCode and produces an output array job.decorations of\n     * style classes preceded by the position at which they start in\n     * job.sourceCode in order.\n     *\n     * @param {Object} job an object like <pre>{\n     *    sourceCode: {string} sourceText plain text,\n     *    basePos: {int} position of job.sourceCode in the larger chunk of\n     *        sourceCode.\n     * }</pre>\n     */\n    var decorate = function (job) {\n      var sourceCode = job.sourceCode, basePos = job.basePos;\n      /** Even entries are positions in source in ascending order.  Odd enties\n        * are style markers (e.g., PR_COMMENT) that run from that position until\n        * the end.\n        * @type {Array.<number|string>}\n        */\n      var decorations = [basePos, PR_PLAIN];\n      var pos = 0;  // index into sourceCode\n      var tokens = sourceCode.match(tokenizer) || [];\n      var styleCache = {};\n\n      for (var ti = 0, nTokens = tokens.length; ti < nTokens; ++ti) {\n        var token = tokens[ti];\n        var style = styleCache[token];\n        var match = void 0;\n\n        var isEmbedded;\n        if (typeof style === 'string') {\n          isEmbedded = false;\n        } else {\n          var patternParts = shortcuts[token.charAt(0)];\n          if (patternParts) {\n            match = token.match(patternParts[1]);\n            style = patternParts[0];\n          } else {\n            for (var i = 0; i < nPatterns; ++i) {\n              patternParts = fallthroughStylePatterns[i];\n              match = token.match(patternParts[1]);\n              if (match) {\n                style = patternParts[0];\n                break;\n              }\n            }\n\n            if (!match) {  // make sure that we make progress\n              style = PR_PLAIN;\n            }\n          }\n\n          isEmbedded = style.length >= 5 && 'lang-' === style.substring(0, 5);\n          if (isEmbedded && !(match && typeof match[1] === 'string')) {\n            isEmbedded = false;\n            style = PR_SOURCE;\n          }\n\n          if (!isEmbedded) { styleCache[token] = style; }\n        }\n\n        var tokenStart = pos;\n        pos += token.length;\n\n        if (!isEmbedded) {\n          decorations.push(basePos + tokenStart, style);\n        } else {  // Treat group 1 as an embedded block of source code.\n          var embeddedSource = match[1];\n          var embeddedSourceStart = token.indexOf(embeddedSource);\n          var embeddedSourceEnd = embeddedSourceStart + embeddedSource.length;\n          if (match[2]) {\n            // If embeddedSource can be blank, then it would match at the\n            // beginning which would cause us to infinitely recurse on the\n            // entire token, so we catch the right context in match[2].\n            embeddedSourceEnd = token.length - match[2].length;\n            embeddedSourceStart = embeddedSourceEnd - embeddedSource.length;\n          }\n          var lang = style.substring(5);\n          // Decorate the left of the embedded source\n          appendDecorations(\n              basePos + tokenStart,\n              token.substring(0, embeddedSourceStart),\n              decorate, decorations);\n          // Decorate the embedded source\n          appendDecorations(\n              basePos + tokenStart + embeddedSourceStart,\n              embeddedSource,\n              langHandlerForExtension(lang, embeddedSource),\n              decorations);\n          // Decorate the right of the embedded section\n          appendDecorations(\n              basePos + tokenStart + embeddedSourceEnd,\n              token.substring(embeddedSourceEnd),\n              decorate, decorations);\n        }\n      }\n      job.decorations = decorations;\n    };\n    return decorate;\n  }\n\n  /** returns a function that produces a list of decorations from source text.\n    *\n    * This code treats \", ', and ` as string delimiters, and \\ as a string\n    * escape.  It does not recognize perl's qq() style strings.\n    * It has no special handling for double delimiter escapes as in basic, or\n    * the tripled delimiters used in python, but should work on those regardless\n    * although in those cases a single string literal may be broken up into\n    * multiple adjacent string literals.\n    *\n    * It recognizes C, C++, and shell style comments.\n    *\n    * @param {Object} options a set of optional parameters.\n    * @return {function (Object)} a function that examines the source code\n    *     in the input job and builds the decoration list.\n    */\n  function sourceDecorator(options) {\n    var shortcutStylePatterns = [], fallthroughStylePatterns = [];\n    if (options['tripleQuotedStrings']) {\n      // '''multi-line-string''', 'single-line-string', and double-quoted\n      shortcutStylePatterns.push(\n          [PR_STRING,  /^(?:\\'\\'\\'(?:[^\\'\\\\]|\\\\[\\s\\S]|\\'{1,2}(?=[^\\']))*(?:\\'\\'\\'|$)|\\\"\\\"\\\"(?:[^\\\"\\\\]|\\\\[\\s\\S]|\\\"{1,2}(?=[^\\\"]))*(?:\\\"\\\"\\\"|$)|\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$))/,\n           null, '\\'\"']);\n    } else if (options['multiLineStrings']) {\n      // 'multi-line-string', \"multi-line-string\"\n      shortcutStylePatterns.push(\n          [PR_STRING,  /^(?:\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$)|\\`(?:[^\\\\\\`]|\\\\[\\s\\S])*(?:\\`|$))/,\n           null, '\\'\"`']);\n    } else {\n      // 'single-line-string', \"single-line-string\"\n      shortcutStylePatterns.push(\n          [PR_STRING,\n           /^(?:\\'(?:[^\\\\\\'\\r\\n]|\\\\.)*(?:\\'|$)|\\\"(?:[^\\\\\\\"\\r\\n]|\\\\.)*(?:\\\"|$))/,\n           null, '\"\\'']);\n    }\n    if (options['verbatimStrings']) {\n      // verbatim-string-literal production from the C# grammar.  See issue 93.\n      fallthroughStylePatterns.push(\n          [PR_STRING, /^@\\\"(?:[^\\\"]|\\\"\\\")*(?:\\\"|$)/, null]);\n    }\n    var hc = options['hashComments'];\n    if (hc) {\n      if (options['cStyleComments']) {\n        if (hc > 1) {  // multiline hash comments\n          shortcutStylePatterns.push(\n              [PR_COMMENT, /^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/, null, '#']);\n        } else {\n          // Stop C preprocessor declarations at an unclosed open comment\n          shortcutStylePatterns.push(\n              [PR_COMMENT, /^#(?:(?:define|elif|else|endif|error|ifdef|include|ifndef|line|pragma|undef|warning)\\b|[^\\r\\n]*)/,\n               null, '#']);\n        }\n        fallthroughStylePatterns.push(\n            [PR_STRING,\n             /^<(?:(?:(?:\\.\\.\\/)*|\\/?)(?:[\\w-]+(?:\\/[\\w-]+)+)?[\\w-]+\\.h|[a-z]\\w*)>/,\n             null]);\n      } else {\n        shortcutStylePatterns.push([PR_COMMENT, /^#[^\\r\\n]*/, null, '#']);\n      }\n    }\n    if (options['cStyleComments']) {\n      fallthroughStylePatterns.push([PR_COMMENT, /^\\/\\/[^\\r\\n]*/, null]);\n      fallthroughStylePatterns.push(\n          [PR_COMMENT, /^\\/\\*[\\s\\S]*?(?:\\*\\/|$)/, null]);\n    }\n    if (options['regexLiterals']) {\n      /**\n       * @const\n       */\n      var REGEX_LITERAL = (\n          // A regular expression literal starts with a slash that is\n          // not followed by * or / so that it is not confused with\n          // comments.\n          '/(?=[^/*])'\n          // and then contains any number of raw characters,\n          + '(?:[^/\\\\x5B\\\\x5C]'\n          // escape sequences (\\x5C),\n          +    '|\\\\x5C[\\\\s\\\\S]'\n          // or non-nesting character sets (\\x5B\\x5D);\n          +    '|\\\\x5B(?:[^\\\\x5C\\\\x5D]|\\\\x5C[\\\\s\\\\S])*(?:\\\\x5D|$))+'\n          // finally closed by a /.\n          + '/');\n      fallthroughStylePatterns.push(\n          ['lang-regex',\n           new RegExp('^' + REGEXP_PRECEDER_PATTERN + '(' + REGEX_LITERAL + ')')\n           ]);\n    }\n\n    var types = options['types'];\n    if (types) {\n      fallthroughStylePatterns.push([PR_TYPE, types]);\n    }\n\n    var keywords = (\"\" + options['keywords']).replace(/^ | $/g, '');\n    if (keywords.length) {\n      fallthroughStylePatterns.push(\n          [PR_KEYWORD,\n           new RegExp('^(?:' + keywords.replace(/[\\s,]+/g, '|') + ')\\\\b'),\n           null]);\n    }\n\n    shortcutStylePatterns.push([PR_PLAIN,       /^\\s+/, null, ' \\r\\n\\t\\xA0']);\n    fallthroughStylePatterns.push(\n        // TODO(mikesamuel): recognize non-latin letters and numerals in idents\n        [PR_LITERAL,     /^@[a-z_$][a-z_$@0-9]*/i, null],\n        [PR_TYPE,        /^(?:[@_]?[A-Z]+[a-z][A-Za-z_$@0-9]*|\\w+_t\\b)/, null],\n        [PR_PLAIN,       /^[a-z_$][a-z_$@0-9]*/i, null],\n        [PR_LITERAL,\n         new RegExp(\n             '^(?:'\n             // A hex number\n             + '0x[a-f0-9]+'\n             // or an octal or decimal number,\n             + '|(?:\\\\d(?:_\\\\d+)*\\\\d*(?:\\\\.\\\\d*)?|\\\\.\\\\d\\\\+)'\n             // possibly in scientific notation\n             + '(?:e[+\\\\-]?\\\\d+)?'\n             + ')'\n             // with an optional modifier like UL for unsigned long\n             + '[a-z]*', 'i'),\n         null, '0123456789'],\n        // Don't treat escaped quotes in bash as starting strings.  See issue 144.\n        [PR_PLAIN,       /^\\\\[\\s\\S]?/, null],\n        [PR_PUNCTUATION, /^.[^\\s\\w\\.$@\\'\\\"\\`\\/\\#\\\\]*/, null]);\n\n    return createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns);\n  }\n\n  var decorateSource = sourceDecorator({\n        'keywords': ALL_KEYWORDS,\n        'hashComments': true,\n        'cStyleComments': true,\n        'multiLineStrings': true,\n        'regexLiterals': true\n      });\n\n  /**\n   * Given a DOM subtree, wraps it in a list, and puts each line into its own\n   * list item.\n   *\n   * @param {Node} node modified in place.  Its content is pulled into an\n   *     HTMLOListElement, and each line is moved into a separate list item.\n   *     This requires cloning elements, so the input might not have unique\n   *     IDs after numbering.\n   */\n  function numberLines(node, opt_startLineNum) {\n    var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\n    var lineBreak = /\\r\\n?|\\n/;\n  \n    var document = node.ownerDocument;\n  \n    var whitespace;\n    if (node.currentStyle) {\n      whitespace = node.currentStyle.whiteSpace;\n    } else if (window.getComputedStyle) {\n      whitespace = document.defaultView.getComputedStyle(node, null)\n          .getPropertyValue('white-space');\n    }\n    // If it's preformatted, then we need to split lines on line breaks\n    // in addition to <BR>s.\n    var isPreformatted = whitespace && 'pre' === whitespace.substring(0, 3);\n  \n    var li = document.createElement('LI');\n    while (node.firstChild) {\n      li.appendChild(node.firstChild);\n    }\n    // An array of lines.  We split below, so this is initialized to one\n    // un-split line.\n    var listItems = [li];\n  \n    function walk(node) {\n      switch (node.nodeType) {\n        case 1:  // Element\n          if (nocode.test(node.className)) { break; }\n          if ('BR' === node.nodeName) {\n            breakAfter(node);\n            // Discard the <BR> since it is now flush against a </LI>.\n            if (node.parentNode) {\n              node.parentNode.removeChild(node);\n            }\n          } else {\n            for (var child = node.firstChild; child; child = child.nextSibling) {\n              walk(child);\n            }\n          }\n          break;\n        case 3: case 4:  // Text\n          if (isPreformatted) {\n            var text = node.nodeValue;\n            var match = text.match(lineBreak);\n            if (match) {\n              var firstLine = text.substring(0, match.index);\n              node.nodeValue = firstLine;\n              var tail = text.substring(match.index + match[0].length);\n              if (tail) {\n                var parent = node.parentNode;\n                parent.insertBefore(\n                    document.createTextNode(tail), node.nextSibling);\n              }\n              breakAfter(node);\n              if (!firstLine) {\n                // Don't leave blank text nodes in the DOM.\n                node.parentNode.removeChild(node);\n              }\n            }\n          }\n          break;\n      }\n    }\n  \n    // Split a line after the given node.\n    function breakAfter(lineEndNode) {\n      // If there's nothing to the right, then we can skip ending the line\n      // here, and move root-wards since splitting just before an end-tag\n      // would require us to create a bunch of empty copies.\n      while (!lineEndNode.nextSibling) {\n        lineEndNode = lineEndNode.parentNode;\n        if (!lineEndNode) { return; }\n      }\n  \n      function breakLeftOf(limit, copy) {\n        // Clone shallowly if this node needs to be on both sides of the break.\n        var rightSide = copy ? limit.cloneNode(false) : limit;\n        var parent = limit.parentNode;\n        if (parent) {\n          // We clone the parent chain.\n          // This helps us resurrect important styling elements that cross lines.\n          // E.g. in <i>Foo<br>Bar</i>\n          // should be rewritten to <li><i>Foo</i></li><li><i>Bar</i></li>.\n          var parentClone = breakLeftOf(parent, 1);\n          // Move the clone and everything to the right of the original\n          // onto the cloned parent.\n          var next = limit.nextSibling;\n          parentClone.appendChild(rightSide);\n          for (var sibling = next; sibling; sibling = next) {\n            next = sibling.nextSibling;\n            parentClone.appendChild(sibling);\n          }\n        }\n        return rightSide;\n      }\n  \n      var copiedListItem = breakLeftOf(lineEndNode.nextSibling, 0);\n  \n      // Walk the parent chain until we reach an unattached LI.\n      for (var parent;\n           // Check nodeType since IE invents document fragments.\n           (parent = copiedListItem.parentNode) && parent.nodeType === 1;) {\n        copiedListItem = parent;\n      }\n      // Put it on the list of lines for later processing.\n      listItems.push(copiedListItem);\n    }\n  \n    // Split lines while there are lines left to split.\n    for (var i = 0;  // Number of lines that have been split so far.\n         i < listItems.length;  // length updated by breakAfter calls.\n         ++i) {\n      walk(listItems[i]);\n    }\n  \n    // Make sure numeric indices show correctly.\n    if (opt_startLineNum === (opt_startLineNum|0)) {\n      listItems[0].setAttribute('value', opt_startLineNum);\n    }\n  \n    var ol = document.createElement('OL');\n    ol.className = 'linenums';\n    var offset = Math.max(0, ((opt_startLineNum - 1 /* zero index */)) | 0) || 0;\n    for (var i = 0, n = listItems.length; i < n; ++i) {\n      li = listItems[i];\n      // Stick a class on the LIs so that stylesheets can\n      // color odd/even rows, or any other row pattern that\n      // is co-prime with 10.\n      li.className = 'L' + ((i + offset) % 10);\n      if (!li.firstChild) {\n        li.appendChild(document.createTextNode('\\xA0'));\n      }\n      ol.appendChild(li);\n    }\n  \n    node.appendChild(ol);\n  }\n\n  /**\n   * Breaks {@code job.sourceCode} around style boundaries in\n   * {@code job.decorations} and modifies {@code job.sourceNode} in place.\n   * @param {Object} job like <pre>{\n   *    sourceCode: {string} source as plain text,\n   *    spans: {Array.<number|Node>} alternating span start indices into source\n   *       and the text node or element (e.g. {@code <BR>}) corresponding to that\n   *       span.\n   *    decorations: {Array.<number|string} an array of style classes preceded\n   *       by the position at which they start in job.sourceCode in order\n   * }</pre>\n   * @private\n   */\n  function recombineTagsAndDecorations(job) {\n    var isIE = /\\bMSIE\\b/.test(navigator.userAgent);\n    var newlineRe = /\\n/g;\n  \n    var source = job.sourceCode;\n    var sourceLength = source.length;\n    // Index into source after the last code-unit recombined.\n    var sourceIndex = 0;\n  \n    var spans = job.spans;\n    var nSpans = spans.length;\n    // Index into spans after the last span which ends at or before sourceIndex.\n    var spanIndex = 0;\n  \n    var decorations = job.decorations;\n    var nDecorations = decorations.length;\n    // Index into decorations after the last decoration which ends at or before\n    // sourceIndex.\n    var decorationIndex = 0;\n  \n    // Remove all zero-length decorations.\n    decorations[nDecorations] = sourceLength;\n    var decPos, i;\n    for (i = decPos = 0; i < nDecorations;) {\n      if (decorations[i] !== decorations[i + 2]) {\n        decorations[decPos++] = decorations[i++];\n        decorations[decPos++] = decorations[i++];\n      } else {\n        i += 2;\n      }\n    }\n    nDecorations = decPos;\n  \n    // Simplify decorations.\n    for (i = decPos = 0; i < nDecorations;) {\n      var startPos = decorations[i];\n      // Conflate all adjacent decorations that use the same style.\n      var startDec = decorations[i + 1];\n      var end = i + 2;\n      while (end + 2 <= nDecorations && decorations[end + 1] === startDec) {\n        end += 2;\n      }\n      decorations[decPos++] = startPos;\n      decorations[decPos++] = startDec;\n      i = end;\n    }\n  \n    nDecorations = decorations.length = decPos;\n  \n    var decoration = null;\n    while (spanIndex < nSpans) {\n      var spanStart = spans[spanIndex];\n      var spanEnd = spans[spanIndex + 2] || sourceLength;\n  \n      var decStart = decorations[decorationIndex];\n      var decEnd = decorations[decorationIndex + 2] || sourceLength;\n  \n      var end = Math.min(spanEnd, decEnd);\n  \n      var textNode = spans[spanIndex + 1];\n      var styledText;\n      if (textNode.nodeType !== 1  // Don't muck with <BR>s or <LI>s\n          // Don't introduce spans around empty text nodes.\n          && (styledText = source.substring(sourceIndex, end))) {\n        // This may seem bizarre, and it is.  Emitting LF on IE causes the\n        // code to display with spaces instead of line breaks.\n        // Emitting Windows standard issue linebreaks (CRLF) causes a blank\n        // space to appear at the beginning of every line but the first.\n        // Emitting an old Mac OS 9 line separator makes everything spiffy.\n        if (isIE) { styledText = styledText.replace(newlineRe, '\\r'); }\n        textNode.nodeValue = styledText;\n        var document = textNode.ownerDocument;\n        var span = document.createElement('SPAN');\n        span.className = decorations[decorationIndex + 1];\n        var parentNode = textNode.parentNode;\n        parentNode.replaceChild(span, textNode);\n        span.appendChild(textNode);\n        if (sourceIndex < spanEnd) {  // Split off a text node.\n          spans[spanIndex + 1] = textNode\n              // TODO: Possibly optimize by using '' if there's no flicker.\n              = document.createTextNode(source.substring(end, spanEnd));\n          parentNode.insertBefore(textNode, span.nextSibling);\n        }\n      }\n  \n      sourceIndex = end;\n  \n      if (sourceIndex >= spanEnd) {\n        spanIndex += 2;\n      }\n      if (sourceIndex >= decEnd) {\n        decorationIndex += 2;\n      }\n    }\n  }\n\n\n  /** Maps language-specific file extensions to handlers. */\n  var langHandlerRegistry = {};\n  /** Register a language handler for the given file extensions.\n    * @param {function (Object)} handler a function from source code to a list\n    *      of decorations.  Takes a single argument job which describes the\n    *      state of the computation.   The single parameter has the form\n    *      {@code {\n    *        sourceCode: {string} as plain text.\n    *        decorations: {Array.<number|string>} an array of style classes\n    *                     preceded by the position at which they start in\n    *                     job.sourceCode in order.\n    *                     The language handler should assigned this field.\n    *        basePos: {int} the position of source in the larger source chunk.\n    *                 All positions in the output decorations array are relative\n    *                 to the larger source chunk.\n    *      } }\n    * @param {Array.<string>} fileExtensions\n    */\n  function registerLangHandler(handler, fileExtensions) {\n    for (var i = fileExtensions.length; --i >= 0;) {\n      var ext = fileExtensions[i];\n      if (!langHandlerRegistry.hasOwnProperty(ext)) {\n        langHandlerRegistry[ext] = handler;\n      } else if (window['console']) {\n        console['warn']('cannot override language handler %s', ext);\n      }\n    }\n  }\n  function langHandlerForExtension(extension, source) {\n    if (!(extension && langHandlerRegistry.hasOwnProperty(extension))) {\n      // Treat it as markup if the first non whitespace character is a < and\n      // the last non-whitespace character is a >.\n      extension = /^\\s*</.test(source)\n          ? 'default-markup'\n          : 'default-code';\n    }\n    return langHandlerRegistry[extension];\n  }\n  registerLangHandler(decorateSource, ['default-code']);\n  registerLangHandler(\n      createSimpleLexer(\n          [],\n          [\n           [PR_PLAIN,       /^[^<?]+/],\n           [PR_DECLARATION, /^<!\\w[^>]*(?:>|$)/],\n           [PR_COMMENT,     /^<\\!--[\\s\\S]*?(?:-\\->|$)/],\n           // Unescaped content in an unknown language\n           ['lang-',        /^<\\?([\\s\\S]+?)(?:\\?>|$)/],\n           ['lang-',        /^<%([\\s\\S]+?)(?:%>|$)/],\n           [PR_PUNCTUATION, /^(?:<[%?]|[%?]>)/],\n           ['lang-',        /^<xmp\\b[^>]*>([\\s\\S]+?)<\\/xmp\\b[^>]*>/i],\n           // Unescaped content in javascript.  (Or possibly vbscript).\n           ['lang-js',      /^<script\\b[^>]*>([\\s\\S]*?)(<\\/script\\b[^>]*>)/i],\n           // Contains unescaped stylesheet content\n           ['lang-css',     /^<style\\b[^>]*>([\\s\\S]*?)(<\\/style\\b[^>]*>)/i],\n           ['lang-in.tag',  /^(<\\/?[a-z][^<>]*>)/i]\n          ]),\n      ['default-markup', 'htm', 'html', 'mxml', 'xhtml', 'xml', 'xsl']);\n  registerLangHandler(\n      createSimpleLexer(\n          [\n           [PR_PLAIN,        /^[\\s]+/, null, ' \\t\\r\\n'],\n           [PR_ATTRIB_VALUE, /^(?:\\\"[^\\\"]*\\\"?|\\'[^\\']*\\'?)/, null, '\\\"\\'']\n           ],\n          [\n           [PR_TAG,          /^^<\\/?[a-z](?:[\\w.:-]*\\w)?|\\/?>$/i],\n           [PR_ATTRIB_NAME,  /^(?!style[\\s=]|on)[a-z](?:[\\w:-]*\\w)?/i],\n           ['lang-uq.val',   /^=\\s*([^>\\'\\\"\\s]*(?:[^>\\'\\\"\\s\\/]|\\/(?=\\s)))/],\n           [PR_PUNCTUATION,  /^[=<>\\/]+/],\n           ['lang-js',       /^on\\w+\\s*=\\s*\\\"([^\\\"]+)\\\"/i],\n           ['lang-js',       /^on\\w+\\s*=\\s*\\'([^\\']+)\\'/i],\n           ['lang-js',       /^on\\w+\\s*=\\s*([^\\\"\\'>\\s]+)/i],\n           ['lang-css',      /^style\\s*=\\s*\\\"([^\\\"]+)\\\"/i],\n           ['lang-css',      /^style\\s*=\\s*\\'([^\\']+)\\'/i],\n           ['lang-css',      /^style\\s*=\\s*([^\\\"\\'>\\s]+)/i]\n           ]),\n      ['in.tag']);\n  registerLangHandler(\n      createSimpleLexer([], [[PR_ATTRIB_VALUE, /^[\\s\\S]+/]]), ['uq.val']);\n  registerLangHandler(sourceDecorator({\n          'keywords': CPP_KEYWORDS,\n          'hashComments': true,\n          'cStyleComments': true,\n          'types': C_TYPES\n        }), ['c', 'cc', 'cpp', 'cxx', 'cyc', 'm']);\n  registerLangHandler(sourceDecorator({\n          'keywords': 'null,true,false'\n        }), ['json']);\n  registerLangHandler(sourceDecorator({\n          'keywords': CSHARP_KEYWORDS,\n          'hashComments': true,\n          'cStyleComments': true,\n          'verbatimStrings': true,\n          'types': C_TYPES\n        }), ['cs']);\n  registerLangHandler(sourceDecorator({\n          'keywords': JAVA_KEYWORDS,\n          'cStyleComments': true\n        }), ['java']);\n  registerLangHandler(sourceDecorator({\n          'keywords': SH_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true\n        }), ['bsh', 'csh', 'sh']);\n  registerLangHandler(sourceDecorator({\n          'keywords': PYTHON_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true,\n          'tripleQuotedStrings': true\n        }), ['cv', 'py']);\n  registerLangHandler(sourceDecorator({\n          'keywords': PERL_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true,\n          'regexLiterals': true\n        }), ['perl', 'pl', 'pm']);\n  registerLangHandler(sourceDecorator({\n          'keywords': RUBY_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true,\n          'regexLiterals': true\n        }), ['rb']);\n  registerLangHandler(sourceDecorator({\n          'keywords': JSCRIPT_KEYWORDS,\n          'cStyleComments': true,\n          'regexLiterals': true\n        }), ['js']);\n  registerLangHandler(sourceDecorator({\n          'keywords': COFFEE_KEYWORDS,\n          'hashComments': 3,  // ### style block comments\n          'cStyleComments': true,\n          'multilineStrings': true,\n          'tripleQuotedStrings': true,\n          'regexLiterals': true\n        }), ['coffee']);\n  registerLangHandler(createSimpleLexer([], [[PR_STRING, /^[\\s\\S]+/]]), ['regex']);\n\n  function applyDecorator(job) {\n    var opt_langExtension = job.langExtension;\n\n    try {\n      // Extract tags, and convert the source code to plain text.\n      var sourceAndSpans = extractSourceSpans(job.sourceNode);\n      /** Plain text. @type {string} */\n      var source = sourceAndSpans.sourceCode;\n      job.sourceCode = source;\n      job.spans = sourceAndSpans.spans;\n      job.basePos = 0;\n\n      // Apply the appropriate language handler\n      langHandlerForExtension(opt_langExtension, source)(job);\n\n      // Integrate the decorations and tags back into the source code,\n      // modifying the sourceNode in place.\n      recombineTagsAndDecorations(job);\n    } catch (e) {\n      if ('console' in window) {\n        console['log'](e && e['stack'] ? e['stack'] : e);\n      }\n    }\n  }\n\n  /**\n   * @param sourceCodeHtml {string} The HTML to pretty print.\n   * @param opt_langExtension {string} The language name to use.\n   *     Typically, a filename extension like 'cpp' or 'java'.\n   * @param opt_numberLines {number|boolean} True to number lines,\n   *     or the 1-indexed number of the first line in sourceCodeHtml.\n   */\n  function prettyPrintOne(sourceCodeHtml, opt_langExtension, opt_numberLines) {\n    var container = document.createElement('PRE');\n    // This could cause images to load and onload listeners to fire.\n    // E.g. <img onerror=\"alert(1337)\" src=\"nosuchimage.png\">.\n    // We assume that the inner HTML is from a trusted source.\n    container.innerHTML = sourceCodeHtml;\n    if (opt_numberLines) {\n      numberLines(container, opt_numberLines);\n    }\n\n    var job = {\n      langExtension: opt_langExtension,\n      numberLines: opt_numberLines,\n      sourceNode: container\n    };\n    applyDecorator(job);\n    return container.innerHTML;\n  }\n\n  function prettyPrint(opt_whenDone) {\n    function byTagName(tn) { return document.getElementsByTagName(tn); }\n    // fetch a list of nodes to rewrite\n    var codeSegments = [byTagName('pre'), byTagName('code'), byTagName('xmp')];\n    var elements = [];\n    for (var i = 0; i < codeSegments.length; ++i) {\n      for (var j = 0, n = codeSegments[i].length; j < n; ++j) {\n        elements.push(codeSegments[i][j]);\n      }\n    }\n    codeSegments = null;\n\n    var clock = Date;\n    if (!clock['now']) {\n      clock = { 'now': function () { return +(new Date); } };\n    }\n\n    // The loop is broken into a series of continuations to make sure that we\n    // don't make the browser unresponsive when rewriting a large page.\n    var k = 0;\n    var prettyPrintingJob;\n\n    var langExtensionRe = /\\blang(?:uage)?-([\\w.]+)(?!\\S)/;\n    var prettyPrintRe = /\\bprettyprint\\b/;\n\n    function doWork() {\n      var endTime = (window['PR_SHOULD_USE_CONTINUATION'] ?\n                     clock['now']() + 250 /* ms */ :\n                     Infinity);\n      for (; k < elements.length && clock['now']() < endTime; k++) {\n        var cs = elements[k];\n        var className = cs.className;\n        if (className.indexOf('prettyprint') >= 0) {\n          // If the classes includes a language extensions, use it.\n          // Language extensions can be specified like\n          //     <pre class=\"prettyprint lang-cpp\">\n          // the language extension \"cpp\" is used to find a language handler as\n          // passed to PR.registerLangHandler.\n          // HTML5 recommends that a language be specified using \"language-\"\n          // as the prefix instead.  Google Code Prettify supports both.\n          // http://dev.w3.org/html5/spec-author-view/the-code-element.html\n          var langExtension = className.match(langExtensionRe);\n          // Support <pre class=\"prettyprint\"><code class=\"language-c\">\n          var wrapper;\n          if (!langExtension && (wrapper = childContentWrapper(cs))\n              && \"CODE\" === wrapper.tagName) {\n            langExtension = wrapper.className.match(langExtensionRe);\n          }\n\n          if (langExtension) {\n            langExtension = langExtension[1];\n          }\n\n          // make sure this is not nested in an already prettified element\n          var nested = false;\n          for (var p = cs.parentNode; p; p = p.parentNode) {\n            if ((p.tagName === 'pre' || p.tagName === 'code' ||\n                 p.tagName === 'xmp') &&\n                p.className && p.className.indexOf('prettyprint') >= 0) {\n              nested = true;\n              break;\n            }\n          }\n          if (!nested) {\n            // Look for a class like linenums or linenums:<n> where <n> is the\n            // 1-indexed number of the first line.\n            var lineNums = cs.className.match(/\\blinenums\\b(?::(\\d+))?/);\n            lineNums = lineNums\n                  ? lineNums[1] && lineNums[1].length ? +lineNums[1] : true\n                  : false;\n            if (lineNums) { numberLines(cs, lineNums); }\n\n            // do the pretty printing\n            prettyPrintingJob = {\n              langExtension: langExtension,\n              sourceNode: cs,\n              numberLines: lineNums\n            };\n            applyDecorator(prettyPrintingJob);\n          }\n        }\n      }\n      if (k < elements.length) {\n        // finish up in a continuation\n        setTimeout(doWork, 250);\n      } else if (opt_whenDone) {\n        opt_whenDone();\n      }\n    }\n\n    doWork();\n  }\n\n   /**\n    * Find all the {@code <pre>} and {@code <code>} tags in the DOM with\n    * {@code class=prettyprint} and prettify them.\n    *\n    * @param {Function?} opt_whenDone if specified, called when the last entry\n    *     has been finished.\n    */\n  window['prettyPrintOne'] = prettyPrintOne;\n   /**\n    * Pretty print a chunk of code.\n    *\n    * @param {string} sourceCodeHtml code as html\n    * @return {string} code as html, but prettier\n    */\n  window['prettyPrint'] = prettyPrint;\n   /**\n    * Contains functions for creating and registering new language handlers.\n    * @type {Object}\n    */\n  window['PR'] = {\n        'createSimpleLexer': createSimpleLexer,\n        'registerLangHandler': registerLangHandler,\n        'sourceDecorator': sourceDecorator,\n        'PR_ATTRIB_NAME': PR_ATTRIB_NAME,\n        'PR_ATTRIB_VALUE': PR_ATTRIB_VALUE,\n        'PR_COMMENT': PR_COMMENT,\n        'PR_DECLARATION': PR_DECLARATION,\n        'PR_KEYWORD': PR_KEYWORD,\n        'PR_LITERAL': PR_LITERAL,\n        'PR_NOCODE': PR_NOCODE,\n        'PR_PLAIN': PR_PLAIN,\n        'PR_PUNCTUATION': PR_PUNCTUATION,\n        'PR_SOURCE': PR_SOURCE,\n        'PR_STRING': PR_STRING,\n        'PR_TAG': PR_TAG,\n        'PR_TYPE': PR_TYPE\n      };\n})();\n","/home/travis/build/npmtest/node-npmtest-kss/node_modules/kss/node5/abbrev/abbrev.js":"\nmodule.exports = exports = abbrev.abbrev = abbrev\n\nabbrev.monkeyPatch = monkeyPatch\n\nfunction monkeyPatch () {\n  Object.defineProperty(Array.prototype, 'abbrev', {\n    value: function () { return abbrev(this) },\n    enumerable: false, configurable: true, writable: true\n  })\n\n  Object.defineProperty(Object.prototype, 'abbrev', {\n    value: function () { return abbrev(Object.keys(this)) },\n    enumerable: false, configurable: true, writable: true\n  })\n}\n\nfunction abbrev (list) {\n  if (arguments.length !== 1 || !Array.isArray(list)) {\n    list = Array.prototype.slice.call(arguments, 0)\n  }\n  for (var i = 0, l = list.length, args = [] ; i < l ; i ++) {\n    args[i] = typeof list[i] === \"string\" ? list[i] : String(list[i])\n  }\n\n  // sort them lexicographically, so that they're next to their nearest kin\n  args = args.sort(lexSort)\n\n  // walk through each, seeing how much it has in common with the next and previous\n  var abbrevs = {}\n    , prev = \"\"\n  for (var i = 0, l = args.length ; i < l ; i ++) {\n    var current = args[i]\n      , next = args[i + 1] || \"\"\n      , nextMatches = true\n      , prevMatches = true\n    if (current === next) continue\n    for (var j = 0, cl = current.length ; j < cl ; j ++) {\n      var curChar = current.charAt(j)\n      nextMatches = nextMatches && curChar === next.charAt(j)\n      prevMatches = prevMatches && curChar === prev.charAt(j)\n      if (!nextMatches && !prevMatches) {\n        j ++\n        break\n      }\n    }\n    prev = current\n    if (j === cl) {\n      abbrevs[current] = current\n      continue\n    }\n    for (var a = current.substr(0, j) ; j <= cl ; j ++) {\n      abbrevs[a] = current\n      a += current.charAt(j)\n    }\n  }\n  return abbrevs\n}\n\nfunction lexSort (a, b) {\n  return a === b ? 0 : a > b ? 1 : -1\n}\n","/home/travis/build/npmtest/node-npmtest-kss/node_modules/kss/node5/amdefine/amdefine.js":"/** vim: et:ts=4:sw=4:sts=4\n * @license amdefine 1.0.0 Copyright (c) 2011-2015, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/amdefine for details\n */\n\n/*jslint node: true */\n/*global module, process */\n'use strict';\n\n/**\n * Creates a define for node.\n * @param {Object} module the \"module\" object that is defined by Node for the\n * current module.\n * @param {Function} [requireFn]. Node's require function for the current module.\n * It only needs to be passed in Node versions before 0.5, when module.require\n * did not exist.\n * @returns {Function} a define function that is usable for the current node\n * module.\n */\nfunction amdefine(module, requireFn) {\n    'use strict';\n    var defineCache = {},\n        loaderCache = {},\n        alreadyCalled = false,\n        path = require('path'),\n        makeRequire, stringRequire;\n\n    /**\n     * Trims the . and .. from an array of path segments.\n     * It will keep a leading path segment if a .. will become\n     * the first path segment, to help with module name lookups,\n     * which act like paths, but can be remapped. But the end result,\n     * all paths that use this function should look normalized.\n     * NOTE: this method MODIFIES the input array.\n     * @param {Array} ary the array of path segments.\n     */\n    function trimDots(ary) {\n        var i, part;\n        for (i = 0; ary[i]; i+= 1) {\n            part = ary[i];\n            if (part === '.') {\n                ary.splice(i, 1);\n                i -= 1;\n            } else if (part === '..') {\n                if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {\n                    //End of the line. Keep at least one non-dot\n                    //path segment at the front so it can be mapped\n                    //correctly to disk. Otherwise, there is likely\n                    //no path mapping for a path starting with '..'.\n                    //This can still fail, but catches the most reasonable\n                    //uses of ..\n                    break;\n                } else if (i > 0) {\n                    ary.splice(i - 1, 2);\n                    i -= 2;\n                }\n            }\n        }\n    }\n\n    function normalize(name, baseName) {\n        var baseParts;\n\n        //Adjust any relative paths.\n        if (name && name.charAt(0) === '.') {\n            //If have a base name, try to normalize against it,\n            //otherwise, assume it is a top-level require that will\n            //be relative to baseUrl in the end.\n            if (baseName) {\n                baseParts = baseName.split('/');\n                baseParts = baseParts.slice(0, baseParts.length - 1);\n                baseParts = baseParts.concat(name.split('/'));\n                trimDots(baseParts);\n                name = baseParts.join('/');\n            }\n        }\n\n        return name;\n    }\n\n    /**\n     * Create the normalize() function passed to a loader plugin's\n     * normalize method.\n     */\n    function makeNormalize(relName) {\n        return function (name) {\n            return normalize(name, relName);\n        };\n    }\n\n    function makeLoad(id) {\n        function load(value) {\n            loaderCache[id] = value;\n        }\n\n        load.fromText = function (id, text) {\n            //This one is difficult because the text can/probably uses\n            //define, and any relative paths and requires should be relative\n            //to that id was it would be found on disk. But this would require\n            //bootstrapping a module/require fairly deeply from node core.\n            //Not sure how best to go about that yet.\n            throw new Error('amdefine does not implement load.fromText');\n        };\n\n        return load;\n    }\n\n    makeRequire = function (systemRequire, exports, module, relId) {\n        function amdRequire(deps, callback) {\n            if (typeof deps === 'string') {\n                //Synchronous, single module require('')\n                return stringRequire(systemRequire, exports, module, deps, relId);\n            } else {\n                //Array of dependencies with a callback.\n\n                //Convert the dependencies to modules.\n                deps = deps.map(function (depName) {\n                    return stringRequire(systemRequire, exports, module, depName, relId);\n                });\n\n                //Wait for next tick to call back the require call.\n                if (callback) {\n                    process.nextTick(function () {\n                        callback.apply(null, deps);\n                    });\n                }\n            }\n        }\n\n        amdRequire.toUrl = function (filePath) {\n            if (filePath.indexOf('.') === 0) {\n                return normalize(filePath, path.dirname(module.filename));\n            } else {\n                return filePath;\n            }\n        };\n\n        return amdRequire;\n    };\n\n    //Favor explicit value, passed in if the module wants to support Node 0.4.\n    requireFn = requireFn || function req() {\n        return module.require.apply(module, arguments);\n    };\n\n    function runFactory(id, deps, factory) {\n        var r, e, m, result;\n\n        if (id) {\n            e = loaderCache[id] = {};\n            m = {\n                id: id,\n                uri: __filename,\n                exports: e\n            };\n            r = makeRequire(requireFn, e, m, id);\n        } else {\n            //Only support one define call per file\n            if (alreadyCalled) {\n                throw new Error('amdefine with no module ID cannot be called more than once per file.');\n            }\n            alreadyCalled = true;\n\n            //Use the real variables from node\n            //Use module.exports for exports, since\n            //the exports in here is amdefine exports.\n            e = module.exports;\n            m = module;\n            r = makeRequire(requireFn, e, m, module.id);\n        }\n\n        //If there are dependencies, they are strings, so need\n        //to convert them to dependency values.\n        if (deps) {\n            deps = deps.map(function (depName) {\n                return r(depName);\n            });\n        }\n\n        //Call the factory with the right dependencies.\n        if (typeof factory === 'function') {\n            result = factory.apply(m.exports, deps);\n        } else {\n            result = factory;\n        }\n\n        if (result !== undefined) {\n            m.exports = result;\n            if (id) {\n                loaderCache[id] = m.exports;\n            }\n        }\n    }\n\n    stringRequire = function (systemRequire, exports, module, id, relId) {\n        //Split the ID by a ! so that\n        var index = id.indexOf('!'),\n            originalId = id,\n            prefix, plugin;\n\n        if (index === -1) {\n            id = normalize(id, relId);\n\n            //Straight module lookup. If it is one of the special dependencies,\n            //deal with it, otherwise, delegate to node.\n            if (id === 'require') {\n                return makeRequire(systemRequire, exports, module, relId);\n            } else if (id === 'exports') {\n                return exports;\n            } else if (id === 'module') {\n                return module;\n            } else if (loaderCache.hasOwnProperty(id)) {\n                return loaderCache[id];\n            } else if (defineCache[id]) {\n                runFactory.apply(null, defineCache[id]);\n                return loaderCache[id];\n            } else {\n                if(systemRequire) {\n                    return systemRequire(originalId);\n                } else {\n                    throw new Error('No module with ID: ' + id);\n                }\n            }\n        } else {\n            //There is a plugin in play.\n            prefix = id.substring(0, index);\n            id = id.substring(index + 1, id.length);\n\n            plugin = stringRequire(systemRequire, exports, module, prefix, relId);\n\n            if (plugin.normalize) {\n                id = plugin.normalize(id, makeNormalize(relId));\n            } else {\n                //Normalize the ID normally.\n                id = normalize(id, relId);\n            }\n\n            if (loaderCache[id]) {\n                return loaderCache[id];\n            } else {\n                plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});\n\n                return loaderCache[id];\n            }\n        }\n    };\n\n    //Create a define function specific to the module asking for amdefine.\n    function define(id, deps, factory) {\n        if (Array.isArray(id)) {\n            factory = deps;\n            deps = id;\n            id = undefined;\n        } else if (typeof id !== 'string') {\n            factory = id;\n            id = deps = undefined;\n        }\n\n        if (deps && !Array.isArray(deps)) {\n            factory = deps;\n            deps = undefined;\n        }\n\n        if (!deps) {\n            deps = ['require', 'exports', 'module'];\n        }\n\n        //Set up properties for this module. If an ID, then use\n        //internal cache. If no ID, then use the external variables\n        //for this node module.\n        if (id) {\n            //Put the module in deep freeze until there is a\n            //require call for it.\n            defineCache[id] = [id, deps, factory];\n        } else {\n            runFactory(id, deps, factory);\n        }\n    }\n\n    //define.require, which has access to all the values in the\n    //cache. Useful for AMD modules that all have IDs in the file,\n    //but need to finally export a value to node based on one of those\n    //IDs.\n    define.require = function (id) {\n        if (loaderCache[id]) {\n            return loaderCache[id];\n        }\n\n        if (defineCache[id]) {\n            runFactory.apply(null, defineCache[id]);\n            return loaderCache[id];\n        }\n    };\n\n    define.amd = {};\n\n    return define;\n}\n\nmodule.exports = amdefine;\n","/home/travis/build/npmtest/node-npmtest-kss/node_modules/kss/node5/amdefine/intercept.js":"/*jshint node: true */\nvar inserted,\n    Module = require('module'),\n    fs = require('fs'),\n    existingExtFn = Module._extensions['.js'],\n    amdefineRegExp = /amdefine\\.js/;\n\ninserted  = \"if (typeof define !== 'function') {var define = require('amdefine')(module)}\";\n\n//From the node/lib/module.js source:\nfunction stripBOM(content) {\n    // Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n    // because the buffer-to-string conversion in `fs.readFileSync()`\n    // translates it to FEFF, the UTF-16 BOM.\n    if (content.charCodeAt(0) === 0xFEFF) {\n        content = content.slice(1);\n    }\n    return content;\n}\n\n//Also adapted from the node/lib/module.js source:\nfunction intercept(module, filename) {\n    var content = stripBOM(fs.readFileSync(filename, 'utf8'));\n\n    if (!amdefineRegExp.test(module.id)) {\n        content = inserted + content;\n    }\n\n    module._compile(content, filename);\n}\n\nintercept._id = 'amdefine/intercept';\n\nif (!existingExtFn._id || existingExtFn._id !== intercept._id) {\n    Module._extensions['.js'] = intercept;\n}\n"}