{"/home/travis/build/npmtest/node-npmtest-kss/test.js":"/* istanbul instrument in package npmtest_kss */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-kss/lib.npmtest_kss.js":"/* istanbul instrument in package npmtest_kss */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_kss = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_kss = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-kss/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-kss && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_kss */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_kss\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_kss.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_kss.rollup.js'] =\n            local.assetsDict['/assets.npmtest_kss.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_kss.__dirname +\n                    '/lib.npmtest_kss.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-kss/node_modules/kss/index.js":"'use strict';\n\nmodule.exports = require('./lib/kss.js');\n","/home/travis/build/npmtest/node-npmtest-kss/node_modules/kss/lib/kss.js":"/* eslint-disable key-spacing */\n\n'use strict';\n\n/**\n * The core kss API can be imported with:\n * ```\n * var kss = require('kss');\n * ```\n *\n * The main object is a function that will generate a style guide given the\n * correct options.\n * ```\n * kss(opts, callback);\n * ```\n * The various constructors and methods can then be accessed with:\n * ```\n * var kssStyleguide = new kss.KssStyleguide();\n * var kssSection    = new kss.KssSection();\n * var kssModifier   = new kss.KssModifier();\n * var kssParameter  = new kss.KssParameter();\n * var kssConfig     = new kss.KssConfig();\n * kss.parse();\n * kss.traverse();\n * ```\n * @module kss\n */\n\nvar cli = require('./cli.js');\n\n/**\n * Generates a style guide given the proper options.\n *\n * @param {object} options A collection of configuration options.\n * @param {Function} done Callback function\n * @returns {*} null\n */\nvar kss = function(options, done) {\n  var stdout, stderr, argv,\n    flag, values, i;\n\n  // Allow options to provide an alternative to the process' stdout/stderr.\n  stdout = (options.pipes && options.pipes.stdout) ? options.pipes.stdout : process.stdout;\n  stderr = (options.pipes && options.pipes.stderr) ? options.pipes.stderr : process.stderr;\n\n  // Create an argv-like Array from the options.\n  argv = ['node', 'bin/kss-node'];\n  for (flag in options) {\n    if (options.hasOwnProperty(flag)) {\n      values = options[flag];\n      if (!Array.isArray(values)) {\n        values = [values];\n      }\n      for (i = 0; i < values.length; i++) {\n        if (values[i] === null\n          || typeof values[i] === 'boolean'\n          || typeof values[i] === 'undefined'\n        ) {\n          argv.push('--' + flag);\n        } else {\n          argv.push('--' + flag, values[i]);\n        }\n      }\n    }\n  }\n\n  // @TODO: This is a bit backwards, but our CLI came first. So now our \"pure\"\n  // JavaScript API is calling the cli module. In 3.x, swap this around.\n  return cli({\n    stdout: stdout,\n    stderr: stderr,\n    argv: argv\n  }, done);\n};\n\nmodule.exports = kss;\nmodule.exports.KssConfig = require('./kss_config.js');\nmodule.exports.KssStyleguide = require('./kss_styleguide.js');\nmodule.exports.KssSection = require('./kss_section.js');\nmodule.exports.KssModifier = require('./kss_modifier.js');\nmodule.exports.KssParameter = require('./kss_parameter.js');\nmodule.exports.parse = require('./parse.js');\nmodule.exports.traverse = require('./traverse.js');\n","/home/travis/build/npmtest/node-npmtest-kss/node_modules/kss/lib/cli.js":"'use strict';\n\n// var Promise = require('bluebird'),\nvar fs = require('fs-extra'),\n  KssConfig = require('./kss_config.js'),\n  path = require('path'),\n  version = require('../package.json').version,\n  yargs = require('yargs');\n\nvar cli;\n\ncli = function(opts, done) {\n  var generator,\n    kssConfig = new KssConfig(),\n    logError,\n    positionalParams,\n    stdout,\n    stderr,\n    argv;\n\n  stdout = opts.stdout;\n  stderr = opts.stderr;\n  argv = opts.argv || [];\n\n  // Add options only needed by the CLI or yargs.\n  kssConfig.addOptions({\n    // @TODO: Add stdin option.\n    // 'stdin': {\n    //   group: 'File locations:',\n    //   multiple: false,\n    //   boolean: true,\n    //   describe: 'Reads the source from standard input',\n    //  default: false\n    // },\n    'xdemo': {\n      multiple: false,\n      boolean: true,\n      describe: 'Builds a KSS demo.',\n      default: false\n    },\n    // Prevent yargs from complaining about JSON comments in the config file.\n    '//': {\n      describe: 'JSON configurations will ignore comments.'\n    }\n  });\n\n  // The interaction between Yargs and KssConfig is persnickety, so we extend\n  // both objects to add convenience methods to handle the details.\n  yargs.parseKssOptions = function() {\n    // First 2 args are \"node\" and path to kss-node script; we don't need them.\n    return yargs(argv.slice(2))\n      // Yargs needs the options that kssConfig has collected.\n      .options(kssConfig.options);\n  };\n  kssConfig.setFromYargs = function() {\n    this.set(yargs.parseKssOptions().argv);\n  };\n\n  // Get the config passed from CLI's argv.\n  kssConfig.setFromYargs();\n\n  // If the demo is requested, load the settings from its config file.\n  if (kssConfig.get('xdemo')) {\n    // Add the configuration file to the raw arguments list; otherwise, Yargs\n    // won't read the config from the JSON file.\n    argv.push('--config', path.join(__dirname, '../demo/kss-config.json'));\n    kssConfig.setFromYargs();\n    stdout.write('WELCOME to the kss-node demo! We\\'ve turned on the --verbose flag so you can see what kss-node is doing.' + '\\n');\n\n  } else {\n    // Check if there are unnamed parameters.\n    positionalParams = kssConfig.get('_');\n    if (positionalParams.length > 0) {\n      // Check if the destination is the second unnamed parameter.\n      if (positionalParams.length > 1) {\n        argv.push('--destination', positionalParams[1]);\n      }\n\n      // The source directory is the first unnamed parameter.\n      argv.push('--source', positionalParams[0]);\n\n      kssConfig.setFromYargs();\n    }\n  }\n\n  // Based on the template location specified in the kssConfig, load the\n  // requested template's generator.\n  generator = kssConfig.loadGenerator();\n\n  // Set the logging function of the generator.\n  generator.setLogFunction(function() {\n    var message = '';\n    for (var i = 0; i < arguments.length; i++) {\n      message += arguments[i];\n    }\n    stdout.write(message + '\\n');\n  });\n\n  // Set up an error handling function.\n  logError = function(error) {\n    // Show the full error stack if the verbose flag is used.\n    if (kssConfig.get('verbose')) {\n      stderr.write(error + '\\n');\n    } else {\n      stderr.write('Error: ' + error.message + '\\n');\n    }\n    return done(error);\n  };\n\n  // After the generator is loaded, kssConfig finally knows all the options, so\n  // we tell yargs to ensure strictness (i.e. complain if the user tries to\n  // configure a non-existant option.\n  kssConfig.set(yargs\n    .parseKssOptions()\n    // And make a help option available.\n    .usage('Usage: kss-node [options]')\n    .help('help')\n      .alias('help', 'h')\n      .alias('help', '?')\n    .version(version, 'version')\n    .strict()\n    .wrap(yargs.terminalWidth())\n    .argv\n  );\n\n  // If no settings given, display help and exit.\n  if (argv.slice(2).length === 0) {\n    generator.log(yargs.help());\n    return done(null);\n  }\n\n  // Clean up paths and massage settings to expected types.\n  kssConfig.normalize();\n\n  // If we are building the demo, copy the styles.css file to the destination.\n  if (kssConfig.get('xdemo')) {\n    fs.copy(path.resolve(__dirname, '../demo/styles.css'), path.resolve(kssConfig.get('destination'), 'styles.css'), {clobber: true}, function(error) {\n      if (error) {\n        return logError(error);\n      }\n    });\n  }\n\n  // If requested, clone a template and exit.\n  if (kssConfig.get('clone')) {\n    generator.log('Creating a new style guide template...');\n\n    generator.clone(kssConfig.get('template'), kssConfig.get('clone'), function(error) {\n      if (error) {\n        return logError(error);\n      }\n\n      generator.log('You can change it as you like, and use it with your style guide like so:');\n      generator.log('kss-node [sourcedir] --template ' + kssConfig.get('clone'));\n\n      // We're done early!\n      return done(null);\n    });\n\n    // generator.clone() is async and we don't want cli() to continue.\n    return;\n  }\n\n  // If no source is specified, display help and exit.\n  if (!kssConfig.get('source').length) {\n    return logError(new Error('No --source specified. Use --help for instructions on proper usage.'));\n  }\n\n  // Initialize the generator.\n  /* eslint-disable max-nested-callbacks */\n  generator.init(kssConfig.config, function(error) {\n    if (error) {\n      return logError(error);\n    }\n\n    // Then traverse the source and parse the files found.\n    generator.parse(function(error, styleguide) {\n      if (error) {\n        return logError(error);\n      }\n\n      // Then allow the template to prepare itself and the KssStyleguide object.\n      generator.prepare(styleguide, function(error, styleguide) {\n        if (error) {\n          return logError(error);\n        }\n\n        // Then generate the style guide.\n        generator.generate(styleguide, function(error) {\n          if (error) {\n            return logError(error);\n          }\n          if (kssConfig.get('verbose')) {\n            generator.log('');\n          }\n          generator.log('Style guide generation completed successfully!');\n\n          return done(null);\n        });\n      });\n    });\n  });\n};\n\nmodule.exports = cli;\n","/home/travis/build/npmtest/node-npmtest-kss/node_modules/kss/lib/kss_config.js":"'use strict';\n\n/**\n * The `kss/lib/kss_config` module is normally accessed via the\n * [`KssConfig()`]{@link module:kss.KssConfig} constructor of the `kss`\n * module:\n * ```\n * var kss = require('kss');\n * var kssConfig = new kss.KssConfig(data);\n * ```\n * @private\n * @module kss/lib/kss_config\n */\n\nvar path = require('path');\n\nvar KssConfig,\n  coreOptions,\n  resolveArray;\n\n/* eslint-disable key-spacing */\ncoreOptions = {\n  source: {\n    group:    'File locations:',\n    string:   true,\n    path:     true,\n    describe: 'Source directory to parse for KSS comments'\n  },\n  destination: {\n    group:    'File locations:',\n    string:   true,\n    path:     true,\n    multiple: false,\n    describe: 'Destination directory of generated style guide',\n    default:  'styleguide'\n  },\n  mask: {\n    group:    'File locations:',\n    alias:    'm',\n    string:   true,\n    multiple: false,\n    describe: 'Use a mask for detecting files containing KSS comments',\n    default:  '*.css|*.less|*.sass|*.scss|*.styl|*.stylus'\n  },\n  config: {\n    group:    'File locations:',\n    alias:    'c',\n    config:   true,\n    multiple: false,\n    describe: 'Load the kss-node configuration from a json file'\n  },\n\n  clone: {\n    group:    'Template:',\n    alias:    ['init', 'i'],\n    string:   true,\n    path:     true,\n    multiple: false,\n    describe: 'Clone a style guide template to customize'\n  },\n  template: {\n    group:    'Template:',\n    alias:    't',\n    string:   true,\n    path:     true,\n    multiple: false,\n    describe: 'Use a custom template to build your style guide',\n    default:  path.relative(process.cwd(), path.join(__dirname, '../generator/handlebars/template'))\n  },\n  css: {\n    group:    'Style guide:',\n    string:   true,\n    describe: 'URL of a CSS file to include in the style guide'\n  },\n  js: {\n    group:    'Style guide:',\n    string:   true,\n    describe: 'URL of a JavaScript file to include in the style guide'\n  },\n  custom: {\n    group:    'Style guide:',\n    string:   true,\n    describe: 'Process a custom property name when parsing KSS comments'\n  },\n\n  verbose: {\n    count:    true,\n    multiple: false,\n    describe: 'Display verbose details while generating'\n  }\n};\n/* eslint-enable key-spacing */\n\n/**\n * A KssConfig object stores configuration settings needed when generating a KSS\n * style guide.\n *\n * It also validates the settings against the known set of options for the\n * configured template and its generator. And makes it easy to load the template\n * and its generator.\n *\n * @constructor\n * @alias module:kss.KssConfig\n * @param {Object} config An object of config settings to store.\n */\nKssConfig = function(config) {\n  if (!(this instanceof KssConfig)) {\n    return new KssConfig();\n  }\n  this.options = coreOptions;\n  this.config = {};\n  if (config) {\n    this.set(config);\n  }\n};\n\n/**\n * Stores the given config settings.\n *\n * @param {Object} config An object of config settings to store.\n */\nKssConfig.prototype.set = function(config) {\n  var key;\n  for (key in config) {\n    // istanbul ignore else\n    if (config.hasOwnProperty(key)) {\n      this.config[key] = config[key];\n    }\n  }\n};\n\n/**\n * Returns the requested configuration setting or, if no key is specified, an\n * object containing all settings.\n *\n * @param {string} key Optional name of config setting to return.\n * @returns {string|Object} The specified setting or an object of all settings.\n */\nKssConfig.prototype.get = function(key) {\n  return key ? this.config[key] : this.config;\n};\n\n/**\n * Adds additional configuration options to the core kss-node options.\n *\n * Since kss-node is extendable, generators and templates can provide their own\n * options for configuration.\n *\n * @param {object} options An object of configuration options.\n */\nKssConfig.prototype.addOptions = function(options) {\n  var key;\n  for (key in options) {\n    // istanbul ignore else\n    if (options.hasOwnProperty(key)) {\n      this.options[key] = options[key];\n    }\n  }\n};\n\n/**\n * Adds the configuration settings from the given JSON file.\n *\n * @param {string} filename The path to the JSON file.\n */\nKssConfig.prototype.loadJSON = function(filename) {\n  filename = path.resolve(filename);\n  var config = require(filename);\n\n  this.set({\n    // Save the full path to the config file.\n    config: filename,\n    // Store the list of config file keys for later.\n    configFileKeys: Object.keys(config)\n  });\n  this.set(config);\n};\n\n/**\n * Normalizes the configuration object so that it is easy to use inside KSS.\n *\n * The options specified in the KssConfig object will determine how its\n * configuration will be normalized.\n *\n * If an option object has a:\n * - `multiple` property: if set to `false`, the corresponding configuration\n *   will be normalized to a single value. Otherwise, it will be normalized to\n *   an array of values.\n * - `path` property: if set to `true`, the corresponding configuration will be\n *   normalized to a path, relative to the current working directory or, if\n *   given, the location of the JSON config file.\n */\nKssConfig.prototype.normalize = function() {\n  var key;\n\n  // If some of the options were specified in a JSON config file, determine\n  // which ones by loading the keys from the config file.\n  if (typeof this.config.configFileKeys === 'undefined') {\n    if (this.config.config) {\n      // Save the full path to the config file.\n      this.config.config = path.resolve(this.config.config);\n      // Store the list of config file keys for later.\n      this.config.configFileKeys = Object.keys(require(this.config.config));\n    } else {\n      this.config.configFileKeys = [];\n    }\n  }\n\n  // Allow --clone to be used without a path. We can't specify this default path\n  // in coreOptions or the clone flag would always be \"on\".\n  if (this.config['clone'] === '') {\n    this.config['clone'] = 'custom-template';\n  }\n\n  // Normalize all the configuration settings.\n  for (key in this.config) {\n    if (typeof this.options[key] !== 'undefined') {\n      // \"multiple\" defaults to true.\n      if (typeof this.options[key].multiple === 'undefined') {\n        this.options[key].multiple = true;\n      }\n      // \"path\" defaults to false.\n      if (typeof this.options[key].path === 'undefined') {\n        this.options[key].path = false;\n      }\n      // If an option is specified multiple times, yargs will convert it into an\n      // array, but leave it as a string otherwise. This makes accessing the\n      // values of options inconsistent, so make all other options an array.\n      if (this.options[key].multiple) {\n        if (!(this.config[key] instanceof Array)) {\n          if (typeof this.config[key] === 'undefined') {\n            this.config[key] = [];\n          } else {\n            this.config[key] = [this.config[key]];\n          }\n        }\n      } else {\n        // For options marked as \"multiple: false\", use the last value\n        // specified, ignoring the others.\n        if (this.config[key] instanceof Array) {\n          this.config[key] = this.config[key].pop();\n        }\n      }\n      // Resolve any paths relative to the config file or to the working\n      // directory.\n      if (this.options[key].path && (typeof this.config[key] === 'string' || this.config[key] instanceof Array)) {\n        if (this.config.configFileKeys.indexOf(key) > -1) {\n          this.config[key] = resolveArray(path.dirname(this.config.config), this.config[key]);\n        } else {\n          this.config[key] = resolveArray(this.config[key]);\n        }\n      }\n    }\n  }\n};\n\n/**\n * Loads a generator object based on the previously-set configuration.\n *\n * @returns {object} The generator object\n */\nKssConfig.prototype.loadGenerator = function() {\n  var template,\n    generator,\n    self = this;\n\n  // Clean up paths and massage options to expected types.\n  this.normalize();\n\n  // Load the template's generator.\n  try {\n    template = require(this.config.template);\n    generator = template.generator;\n  } catch (e) {\n    // Templates don't have to load their own generator. If the template fails\n    // to load a generator, we assume it wanted the default generator.\n    generator = require('../generator/handlebars');\n  }\n\n  // Confirm this is a compatible generator.\n  return generator.checkGenerator(function(error) {\n    if (error) {\n      return error;\n    }\n\n    // Load the generator's and the template's CLI options.\n    // istanbul ignore else\n    if (Object.keys(generator.options).length) {\n      self.addOptions(generator.options);\n    }\n    if (template && template.options && Object.keys(template.options).length) {\n      self.addOptions(template.options);\n    }\n\n    return generator;\n  });\n};\n\n/**\n * Applies path.resolve() to the given path or array of paths.\n *\n * Helper function for KssConfig.normalize().\n *\n * @private\n * @param {string}        from  Optional path to resolve the \"to\" path\n * @param {string|array}  to    Relative path(s) to resolve.\n * @returns {string|array} The absolute path(s).\n */\nresolveArray = function(from, to) {\n  var paths = [];\n  // \"from\" is optional.\n  if (typeof to === 'undefined') {\n    to = from;\n    from = '';\n  }\n  if (to instanceof Array) {\n    to.forEach(function(value, index) {\n      paths[index] = path.resolve(from, value);\n    });\n  } else {\n    paths = path.resolve(from, to);\n  }\n  return paths;\n};\n\nmodule.exports = KssConfig;\n","/home/travis/build/npmtest/node-npmtest-kss/node_modules/kss/lib/kss_styleguide.js":"'use strict';\n\n/**\n * The `kss/lib/kss_styleguide` module is normally accessed via the\n * [`KssStyleguide()`]{@link module:kss.KssStyleguide} constructor of the `kss`\n * module:\n * ```\n * var kss = require('kss');\n * var styleGuide = new kss.KssStyleguide(data);\n * ```\n * @private\n * @module kss/lib/kss_styleguide\n */\n\nvar KssStyleguide;\n\n/**\n * An instance of this class is returned on finishing `kss.traverse`. It has a\n * few convenience methods for interpreting data, the most important of which is\n * section() for searching for specific sections of the style guide.\n *\n * @constructor\n * @alias module:kss.KssStyleguide\n * @param {Object} data The data object generated by traverse.\n */\nKssStyleguide = function(data) {\n  if (!(this instanceof KssStyleguide)) {\n    return new KssStyleguide();\n  }\n  this.data = data || {};\n  this.init();\n};\n\n/**\n * Initializes the object and data passed to the constructor. Called\n * automatically from the KssStyleguide() constructor; should not be called\n * directly.\n * @private\n */\nKssStyleguide.prototype.init = function() {\n  var i, l, incrementIndex, autoIncrement = [0], ref, previousRef = [], index;\n\n  // The map of section weights is created on the fly in getWeight().\n  this.data.weightMap = false;\n\n  this.referenceDelimiter = '.';\n\n  if (!this.data.sections) {\n    this.data.sections = [];\n  }\n\n  if (this.data.sections.length) {\n    // Determine the separator used in references; e.g. 'a - b' or 'a.b'.\n    l = this.data.sections.length;\n    for (i = 0; i < l; i += 1) {\n      if (this.data.sections[i].reference().indexOf(' - ') > -1) {\n        this.referenceDelimiter = ' - ';\n        break;\n      }\n    }\n\n    // Set the depth of each section's reference.\n    for (i = 0; i < l; i += 1) {\n      this.data.sections[i].data.depth = this.data.sections[i].data.reference.split(this.referenceDelimiter).length;\n    }\n\n    // Sort all the sections.\n    this.sortSections();\n\n    // Loop through all the sections to initialize some computed values.\n    for (i = 0; i < l; i += 1) {\n      // Set the styleguide property on each KssSection object.\n      this.data.sections[i].styleguide = this;\n\n      ref = this.data.sections[i].reference();\n      // Set the referenceURI value.\n      this.data.sections[i].data.referenceURI = this.data.sections[i].encodeReferenceURI(ref);\n\n      // Compare the previous Ref to the new Ref.\n      ref = ref.split(this.referenceDelimiter);\n      // If they are already equal, we don't need to increment the section number.\n      if (previousRef.join(this.referenceDelimiter) !== ref.join(this.referenceDelimiter)) {\n        incrementIndex = 0;\n        for (index = 0; index < previousRef.length; index += 1) {\n          // Find the index where the refs differ.\n          if (index >= ref.length || previousRef[index] !== ref[index]) {\n            break;\n          }\n          incrementIndex = index + 1;\n        }\n        if (incrementIndex < autoIncrement.length) {\n          // Increment the part where the refs started to differ.\n          autoIncrement[incrementIndex]++;\n          // Trim off the extra parts of the autoincrement where the refs differed.\n          autoIncrement = autoIncrement.slice(0, incrementIndex + 1);\n        }\n        // Add parts to the autoincrement to ensure it is the same length as the new ref.\n        for (index = autoIncrement.length; index < ref.length; index += 1) {\n          autoIncrement[index] = 1;\n        }\n      }\n      this.data.sections[i].data.autoincrement = autoIncrement.join('.');\n      previousRef = ref;\n    }\n  }\n};\n\n/**\n * Search for sections within the style guide.\n *\n * There's a few ways to use this method:\n * - `section()` returns all of the sections.\n *\n * Using strings:\n * - `section('2')` returns Section 2.\n * - `section('2.*')` returns Section 2 and all of its descendants.\n * - `section('2.x')` returns Section 2's children only.\n * - `section('2.x.x')` returns Section 2's children, and their children too.\n *\n * Or Regular Expressions:\n * - `section(/2\\.[1-5]/)` returns Sections 2.1 through to 2.5.\n *\n * @param {string|Regexp} query A string or Regexp object to match a KssSection's style guide reference.\n * @returns {false|KssSection|Array} The exact KssSection requested, an array of KssSection objects matching the query, or false.\n */\nKssStyleguide.prototype.section = function(query) {\n  var i, l = this.data.sections.length,\n    current, isRegexSearch, delim,\n    sections = [],\n    match;\n\n  query = query || /.+/;\n\n  // Exact queries.\n  if (typeof query === 'string') {\n    // If the query is '*', 'x', or ends with '.*', ' - *', '.x', or ' - x',\n    // then it is not an exact query.\n    isRegexSearch = query.match(/(^[x\\*]$|\\s\\-\\s[x\\*]$|\\.[x\\*]$)/);\n    if (!isRegexSearch) {\n      if (this.data.section_refs && this.data.section_refs[query]) {\n        return this.data.section_refs[query];\n      } else {\n        return false;\n      }\n    }\n  }\n\n  // Convert regex strings into proper JavaScript RegExp objects.\n  if (!(query instanceof RegExp)) {\n    delim = this.referenceDelimiter === '.' ? '\\\\.' : '\\\\ \\\\-\\\\ ';\n    query = new RegExp(\n      query\n        // Convert '*' to a simple .+ regex.\n        .replace(/^\\*$/, '.+')\n        // Convert 'x' to a regex matching one level of reference.\n        .replace(/^x$/, '^.+?(?=($|' + delim + '))')\n        // Convert '.*' or ' - *' to a ([delim].+){0,1} regex.\n        .replace(/(\\.|\\s+\\-\\s+)\\*$/g, '(' + delim + '.+){0,1}')\n        // Convert the first '.x' or ' - x' to a regex matching one sub-level\n        // of a reference.\n        .replace(/(\\.|\\s+\\-\\s+)x\\b/, delim + '.+?(?=($|' + delim + '))')\n        // Convert any remaining '.x' or ' - x' to a regex matching zero or one\n        // sub-levels of a reference.\n        .replace(/(\\.|\\s+\\-\\s+)x\\b/g, '(' + delim + '.+?(?=($|' + delim + '))){0,1}')\n        // Convert any remaining '-' into '\\-'\n        .replace(/([^\\\\])\\-/g, '$1\\\\-')\n    );\n  }\n\n  // General (regex) search\n  for (i = 0; i < l; i += 1) {\n    current = this.data.sections[i];\n    match = current.data.reference.match(query);\n    if (match && match[0] === current.data.reference) {\n      sections.push(current);\n    }\n  }\n\n  /* @TODO An empty array is always true, so this code is never run.\n    Do we want to add it back (properly) in 3.x?\n  if (!sections) {\n    return false;\n  }\n  */\n\n  return sections;\n};\n\n/**\n * Sorts the sections of the style guide.\n *\n * This is called automatically when the {@link KssStyleguide} object is\n * created, but is publicly accessible as well.\n */\nKssStyleguide.prototype.sortSections = function() {\n  var self = this;\n\n  // Sort sections based on reference number.\n  this.data.sections.sort(function(a, b) {\n    // Split the 2 references into chunks by their period or dash seperators.\n    var refsA = a.data.reference.toLowerCase().split(self.referenceDelimiter),\n      refsB = b.data.reference.toLowerCase().split(self.referenceDelimiter),\n      weightA, weightB,\n      i, l = Math.max(refsA.length, refsB.length);\n\n    // Compare each set of chunks until we know which reference should be listed first.\n    for (i = 0; i < l; i += 1) {\n      if (refsA[i] && refsB[i]) {\n        // If the 2 chunks are unequal, compare them.\n        if (refsA[i] !== refsB[i]) {\n          // If the chunks have different weights, sort by weight.\n          weightA = self.getWeight(a.reference(), i);\n          weightB = self.getWeight(b.reference(), i);\n          if (weightA !== weightB) {\n            return weightA - weightB;\n          } else if (refsA[i].match(/^\\d+$/) && refsB[i].match(/^\\d+$/)) {\n            // If both chunks are digits, use numeric sorting.\n            return refsA[i] - refsB[i];\n          } else {\n            // Otherwise, use alphabetical string sorting.\n            return (refsA[i] > refsB[i]) ? 1 : -1;\n          }\n        }\n      } else {\n        // If 1 of the chunks is empty, it goes first.\n        return refsA[i] ? 1 : -1;\n      }\n    }\n\n    return 0;\n  });\n};\n\n/**\n * Helper function for `KssStyleguide.sortSections()` that gets the weight of\n * the given reference at the given depth.\n *\n * For example, `styleguide.getWeight('4.3.2.2', 2)` will return the weight for\n * section 4.3.\n *\n * @param {string} reference A section reference.\n * @param {int} depth The requested depth (optional).\n * @returns {int} The requested weight.\n */\nKssStyleguide.prototype.getWeight = function(reference, depth) {\n  // Initialize the map of weights.\n  if (this.data.weightMap === false) {\n    this.data.weightMap = {};\n    for (var key in this.data.sections) {\n      /* istanbul ignore else */\n      if (this.data.sections.hasOwnProperty(key)) {\n        this.data.weightMap[this.data.sections[key].reference().toLowerCase()] = this.data.sections[key].weight();\n      }\n    }\n  }\n\n  reference = reference.toLowerCase();\n  if (typeof depth !== 'undefined') {\n    reference = reference.split(this.referenceDelimiter, depth + 1).join(this.referenceDelimiter);\n  }\n\n  return this.data.weightMap[reference] ? this.data.weightMap[reference] : 0;\n};\n\nmodule.exports = KssStyleguide;\n","/home/travis/build/npmtest/node-npmtest-kss/node_modules/kss/lib/kss_section.js":"'use strict';\n\n/**\n * The `kss/lib/kss_section` module is normally accessed via the\n * [`KssSection()`]{@link module:kss.KssSection} constructor of the `kss`\n * module:\n * ```\n * var kss = require('kss');\n * var section = new kss.KssSection(data);\n * ```\n * @private\n * @module kss/lib/kss_section\n */\n\nvar KssSection;\n\n/**\n * An instance of this class is returned on calling `KssStyleguide.section`.\n * Exposes convenience methods for interpreting data.\n *\n * @constructor\n * @alias module:kss.KssSection\n * @param {Object} data A part of the data object passed on by `KssStyleguide`.\n */\nKssSection = function(data) {\n  if (!(this instanceof KssSection)) {\n    return new KssSection();\n  }\n  this.data = data || {};\n  this.init();\n};\n\n/**\n * Initializes the object and data passed to the constructor. Called\n * automatically from the KssSection() constructor; should not be called\n * directly.\n * @private\n */\nKssSection.prototype.init = function() {\n  var self = this;\n\n  this.styleguide = this.data.styleguide || null;\n\n  this.data.header = this.data.header || '';\n  this.data.description = this.data.description || '';\n  this.data.deprecated = this.data.deprecated || false;\n  this.data.experimental = this.data.experimental || false;\n  this.data.reference = this.data.reference || '';\n  this.data.depth = this.data.depth || 0;\n  this.data.weight = this.data.weight || 0;\n  this.data.referenceURI = this.data.referenceURI || '';\n  this.data.markup = this.data.markup || '';\n\n  if (this.data.modifiers) {\n    this.data.modifiers = this.data.modifiers.map(function(modifier) {\n      modifier.data.section = self;\n      return modifier;\n    });\n  } else {\n    this.data.modifiers = [];\n  }\n\n  if (this.data.parameters) {\n    this.data.parameters = this.data.parameters.map(function(parameter) {\n      parameter.data.section = self;\n      return parameter;\n    });\n  } else {\n    this.data.parameters = [];\n  }\n};\n\n/**\n * Return `KssSection` as a JSON object.\n *\n * @param {Array} customProperties A list of custom properties to include in the JSON.\n * @returns {Object} A JSON object representation of the KssSection.\n */\nKssSection.prototype.toJSON = function(customProperties) {\n  var returnObject;\n\n  customProperties = customProperties || [];\n\n  /* eslint-disable key-spacing */\n  returnObject = {\n    header:       this.header(),\n    description:  this.description(),\n    deprecated:   this.deprecated(),\n    experimental: this.experimental(),\n    reference:    this.reference(),\n    depth:        this.depth(),\n    weight:       this.weight(),\n    referenceURI: this.referenceURI(),\n    markup:       this.markup()\n  };\n  /* eslint-enable key-spacing */\n\n  returnObject.modifiers = this.data.modifiers.map(function(modifier) {\n    return {\n      name: modifier.name(),\n      description: modifier.description(),\n      className: modifier.className()\n    };\n  });\n  returnObject.parameters = this.data.parameters.map(function(modifier) {\n    return {\n      name: modifier.name(),\n      description: modifier.description()\n    };\n  });\n\n  // Add custom properties to the JSON object.\n  for (var i = 0; i < customProperties.length; i++) {\n    if (this.data[customProperties[i]]) {\n      returnObject[customProperties[i]] = this.data[customProperties[i]];\n    }\n  }\n\n  return returnObject;\n};\n\n// DEPRECATED; use toJSON() instead.\n/* istanbul ignore next */\nKssSection.prototype.JSON = function(customProperties) {\n  return this.toJSON(customProperties);\n};\n\n/**\n * Returns the header of the section, i.e. the first line in the description.\n * @returns {string} The header of the section.\n */\nKssSection.prototype.header = function() {\n  return this.data.header;\n};\n\n/**\n * Returns the description of the section.\n *\n * Note: If the multiline option is disabled this will include the header also.\n *\n * @returns {string} The description of the section.\n */\nKssSection.prototype.description = function() {\n  return this.data.description;\n};\n\n/**\n * Returns whether the section is deprecated or not.\n * @returns {Boolean} Whether the section is deprecated or not.\n */\nKssSection.prototype.deprecated = function() {\n  return this.data.deprecated;\n};\n\n/**\n * Returns whether the section is experimental or not.\n * @returns {Boolean} Whether the section is experimental or not.\n */\nKssSection.prototype.experimental = function() {\n  return this.data.experimental;\n};\n\n/**\n * Returns the reference of the section.\n * @returns {string} The reference of the section.\n */\nKssSection.prototype.reference = function() {\n  return this.data.reference;\n};\n\n/**\n * Returns the depth of the section.\n * @returns {string} The depth of the section.\n */\nKssSection.prototype.depth = function() {\n  return this.data.depth;\n};\n\n/**\n * Returns the weight of the section.\n * @returns {string} The weight of the section.\n */\nKssSection.prototype.weight = function() {\n  return this.data.weight ? this.data.weight : 0;\n};\n\n/**\n * Encodes the given reference as a valid URI fragment.\n * @param {string} reference A style guide section reference.\n * @returns {string} The reference encoded as a URI.\n */\nKssSection.prototype.encodeReferenceURI = function(reference) {\n  return encodeURI(\n    reference\n      .replace(/ \\- /g, '-')\n      .replace(/[^\\w-]+/g, '-')\n      .toLowerCase()\n  );\n};\n\n/**\n * Returns the reference of the section, encoded as a valid URI fragment.\n * @returns {string} The description of the section.\n */\nKssSection.prototype.referenceURI = function() {\n  return this.data.referenceURI;\n};\n\n/**\n * Returns the markup of the section.\n * @returns {false|string} The markup of the section, or `false` if none.\n */\nKssSection.prototype.markup = function() {\n  return this.data.markup || false;\n};\n\n/**\n * Returns the requested modifier of the section.\n *\n * Different arguments will yield different results:\n *\n * - `modifiers()`: Pass nothing to return all of the section's modifiers in an\n *   array.\n * - `modifiers(n)`: Use a number to return the section's Nth modifier.\n * - `modifiers('name')`: Use a string to return a specific modifer by name.\n *\n * @param {string|int} query The name (string) or 0-based index (int) of the requested modifier.\n * @returns {false|Array} An Array of KssModifier objects, or `false` if none.\n */\nKssSection.prototype.modifiers = function(query) {\n  var number, i, l;\n\n  if (typeof query === 'string') {\n    number = parseFloat(query);\n\n    // If can be converted to a number, convert and search\n    // for the query by index (see below).\n    if (number.toString() === query) {\n      query = number;\n    } else {\n      // Otherwise, search for the modifier by name:\n      l = this.data.modifiers.length;\n      for (i = 0; i < l; i += 1) {\n        if (this.data.modifiers[i].data.name === query) {\n          return this.data.modifiers[i];\n        }\n      }\n      return false;\n    }\n  }\n\n  if (typeof query === 'number') {\n    return this.data.modifiers.length > query ? this.data.modifiers[query] : false;\n  }\n\n  return this.data.modifiers;\n};\n\n/**\n * Returns the first modifier of the section.\n * @returns {false|string} The first modifier of the section, or `false` if none.\n */\nKssSection.prototype.firstModifier = function() {\n  if (this.data.modifiers.length) {\n    return this.data.modifiers[0];\n  } else {\n    return false;\n  }\n};\n\n/**\n * Returns the parameters if the section is a CSS preprocessor function/mixin.\n * @returns {Array} The parameters of the section.\n */\nKssSection.prototype.parameters = function() {\n  return this.data.parameters;\n};\n\nmodule.exports = KssSection;\n","/home/travis/build/npmtest/node-npmtest-kss/node_modules/kss/lib/kss_modifier.js":"'use strict';\n\n/**\n * The `kss/lib/kss_modifier` module is normally accessed via the\n * [`KssModifier()`]{@link module:kss.KssModifier} constructor of the `kss`\n * module:\n * ```\n * var kss = require('kss');\n * var modifier = new kss.KssModifier(data);\n * ```\n * @private\n * @module kss/lib/kss_modifier\n */\n\nvar KssModifier;\n\n/**\n * An instance of this class is returned on calling `KssSection.modifier`.\n * Exposes convenience methods for interpreting data.\n *\n * @constructor\n * @alias module:kss.KssModifier\n * @param {Object} data A part of the data object passed on by `KssSection`.\n */\nKssModifier = function(data) {\n  if (!(this instanceof KssModifier)) {\n    return new KssModifier();\n  }\n  this.data = data || {};\n  this.init();\n};\n\n/**\n * Initializes the object and data passed to the constructor. Called\n * automatically from the KssModifier() constructor; should not be called\n * directly.\n * @private\n */\nKssModifier.prototype.init = function() {\n  this.data.section = this.data.section || null;\n  this.data.name = this.data.name || '';\n  this.data.description = this.data.description || '';\n  this.data.className = this.data.className || false;\n};\n\n/**\n * Returns the `KssSection` object this modifier is associated with.\n * @returns {KssSection} The style guide section the modifier belongs to.\n */\nKssModifier.prototype.section = function() {\n  return this.data.section;\n};\n\n/**\n * Returns the name of the modifier, e.g. `:hover`, `.primary`, etc.\n * @returns {string} The name of the modifier.\n */\nKssModifier.prototype.name = function() {\n  return this.data.name;\n};\n\n/**\n * Returns the description of the modifier.\n * @returns {string} The description of the modifier.\n */\nKssModifier.prototype.description = function() {\n  return this.data.description;\n};\n\n/**\n * Returns the class name of the modifier.\n * @returns {string} The class name of the modifier.\n */\nKssModifier.prototype.className = function() {\n  var className = this.data.className;\n\n  if (!className) {\n    return false;\n  }\n\n  // Only get the first class combination -\n  // Markup should not be multiple elements deep at this stage.\n  className = className.split(/\\s/);\n\n  // Split into space-separated classes for inclusion\n  // in templates etc.\n  className = className[0]\n    .replace(/\\./g, ' ')\n    .replace(/^\\s*/g, '');\n\n  return className;\n};\n\n/**\n * Returns the HTML markup used to render this modifier.\n * @returns {string} The markup of the modifier.\n */\nKssModifier.prototype.markup = function() {\n  if (!this.data.section) {\n    return '';\n  }\n\n  return (this.data.section.markup() || '');\n};\n\nmodule.exports = KssModifier;\n","/home/travis/build/npmtest/node-npmtest-kss/node_modules/kss/lib/kss_parameter.js":"'use strict';\n\n/**\n * The `kss/lib/kss_parameter` module is normally accessed via the\n * [`KssParameter()`]{@link module:kss.KssParameter} constructor of the `kss`\n * module:\n * ```\n * var kss = require('kss');\n * var parameter = new kss.KssParameter(data);\n * ```\n * @private\n * @module kss/lib/kss_parameter\n */\n\nvar KssParameter;\n\n/**\n * An instance of this class is returned on calling `KssSection.parameter`.\n * Exposes convenience methods for interpreting data.\n *\n * @constructor\n * @alias module:kss.KssParameter\n * @param {Object} data A part of the data object passed on by `KssSection`.\n */\nKssParameter = function(data) {\n  if (!(this instanceof KssParameter)) {\n    return new KssParameter();\n  }\n  this.data = data || {};\n  this.init();\n};\n\n/**\n * Initializes the object and data passed to the constructor. Called\n * automatically from the KssParameter() constructor; should not be called\n * directly.\n * @private\n */\nKssParameter.prototype.init = function() {\n  this.data.section = this.data.section || null;\n  this.data.name = this.data.name || '';\n  this.data.description = this.data.description || '';\n};\n\n/**\n * Returns the KssSection object this parameter is associated with.\n * @returns {KssSection} The style guide section the parameter belongs to.\n */\nKssParameter.prototype.section = function() {\n  return this.data.section;\n};\n\n/**\n * Returns the name of the parameter.\n * @returns {string} The name of the parameter.\n */\nKssParameter.prototype.name = function() {\n  return this.data.name;\n};\n\n/**\n * Returns the description of the parameter.\n * @returns {string} The description of the parameter.\n */\nKssParameter.prototype.description = function() {\n  return this.data.description;\n};\n\nmodule.exports = KssParameter;\n","/home/travis/build/npmtest/node-npmtest-kss/node_modules/kss/lib/parse.js":"/* eslint-disable camelcase */\n\n'use strict';\n\n/**\n * The `kss/lib/parse` module is normally accessed via the\n * [`parse()`]{@link module:kss.parse} method of the `kss` module:\n * ```\n * var kss = require('kss');\n * kss.parse(input, options, callback);\n * ```\n * @private\n * @module kss/lib/parse\n */\n\nvar KssStyleguide = require('./kss_styleguide.js'),\n  KssSection = require('./kss_section.js'),\n  KssModifier = require('./kss_modifier.js'),\n  KssParameter = require('./kss_parameter.js'),\n  marked = require('marked'),\n  natural = require('natural');\n\nvar inlineRenderer,\n  parse, parseChunk, createModifiers, createParameters, checkReference, findBlocks, processProperty,\n  isDeprecated, isExperimental, hasPrefix;\n\n// Create a MarkDown renderer that does not output a wrapping paragraph.\ninlineRenderer = new marked.Renderer();\ninlineRenderer.paragraph = function(text) {\n  return text;\n};\n\n/**\n * Parse an array/string of documented CSS, or an object of files\n * and their content.\n *\n * File object formatted as `{ \"absolute filename\": content, ... }`.\n *\n * This is called automatically as part of `traverse` but is publicly\n * accessible as well.\n *\n * @alias module:kss.parse\n * @param  {Mixed}    input    The input to parse\n * @param  {Object}   options  Options to alter the output content. Same as the options in [`traverse()`]{@link module:kss.traverse}.\n * @param  {Function} callback Called when parsing is complete\n */\nparse = function(input, options, callback) {\n  var data = {}, fileName, files,\n    i, l;\n\n  // If supplied a string, just make it an Array.\n  if (typeof input === 'string') {\n    input = [input];\n  }\n\n  // Otherwise assume the input supplied is a JSON object, as specified above.\n  if (!Array.isArray(input)) {\n    files = input;\n    input = [];\n    data.files = [];\n    for (fileName in files) {\n      // istanbul ignore else\n      if (files.hasOwnProperty(fileName)) {\n        input.push(files[fileName]);\n        data.files.push(fileName);\n      }\n    }\n    data.files.sort();\n  }\n\n  // Default parsing options\n  if (typeof options.markdown === 'undefined') {\n    options.markdown = true;\n  }\n  if (typeof options.multiline === 'undefined') {\n    options.multiline = true;\n  }\n  options.typos = options.typos || false;\n  options.custom = options.custom || [];\n\n  // Actually parse the input (parseChunk is the key function here.)\n  l = input.length;\n  data.sections = [];\n  data.section_refs = {};\n\n  for (i = 0; i < l; i += 1) {\n    data = parseChunk(data, input[i], options);\n  }\n\n  callback(null, new KssStyleguide(data));\n};\n\n/**\n * Take a chunk of text and parse the comments. This is the primary parsing\n * function, and eventually returns a `data` variable to use to create a new\n * instance of `KssStyleguide`.\n *\n * @private\n * @param  {Object} data    JSON object containing all of the style guide data.\n * @param  {String} input   Text to be parsed, i.e. a single CSS/LESS/etc. file's content.\n * @param  {Object} options The options passed on from `traverse` or `parse`\n * @returns {Object} The raw style guide data from the newly parsed text.\n */\nparseChunk = function(data, input, options) {\n  /* jshint loopfunc: true */\n\n  var currSection, i, l, blocks = [], paragraphs, j, m, hasModifiers, lastModifier;\n\n  // Append the raw text to the body string.\n  data.body = data.body || '';\n  data.body += '\\n\\n';\n  data.body += input;\n\n  // Retrieve an array of \"comment block\" strings, and then evaluate each one.\n  blocks = findBlocks(input);\n  l = blocks.length;\n\n  for (i = 0; i < l; i += 1) {\n    // Create a new, temporary section object with some default values.\n    // \"raw\" is a comment block from the array above.\n    currSection = {\n      raw: blocks[i],\n      header: '',\n      description: '',\n      modifiers: [],\n      parameters: [],\n      markup: false\n    };\n\n    // Split the comment block into paragraphs.\n    paragraphs = currSection.raw\n      .replace(/\\r\\n/g, '\\n')      // Convert Windows CRLF linebreaks.\n      .replace(/\\r/g, '\\n')        // Convert Classic Mac CR linebreaks too.\n      .replace(/\\n\\s+\\n/g, '\\n\\n') // Trim whitespace-only lines.\n      .replace(/^\\s+|\\s+$/g, '')   // Trim the string of white space.\n      .split('\\n\\n');\n\n    // Before anything else, process the properties that are clearly labeled and\n    // can be found right away and then removed.\n    currSection = processProperty('Markup', paragraphs, options, currSection);\n    /* eslint-disable no-loop-func */\n    currSection = processProperty('Weight', paragraphs, options, currSection, function(value) {\n      return isNaN(value) ? 0 : parseFloat(value);\n    });\n    // Process custom properties.\n    options.custom.forEach(function(name) {\n      currSection = processProperty(name, paragraphs, options, currSection);\n    });\n    /* eslint-enable no-loop-func */\n\n    // Ignore this block if a styleguide reference number is not listed.\n    currSection.reference = checkReference(paragraphs, options) || '';\n    if (!currSection.reference) {\n      continue;\n    }\n\n    // If the block is 1 paragraph long, copy the reference into the header.\n    if (paragraphs.length === 1) {\n      currSection.header = currSection.reference;\n    // If the block is 2 paragraphs long, it is just a header and a reference.\n    } else if (paragraphs.length === 2) {\n      currSection.header = currSection.description = paragraphs[0];\n    // If it's 3+ paragraphs long, search for modifiers.\n    } else {\n\n      // Extract the approximate header, description and modifiers paragraphs.\n      // The modifiers will be split into an array of lines.\n      currSection.header = paragraphs[0];\n      currSection.description = paragraphs.slice(0, paragraphs.length - 2).join('\\n\\n');\n      currSection.modifiers = paragraphs[paragraphs.length - 2]\n        .split('\\n');\n\n      // Check the modifiers paragraph. Does it look like it's a list of\n      // modifiers, or just another paragraph of the description?\n      m = currSection.modifiers.length;\n      hasModifiers = true;\n      for (j = 0; j < m; j += 1) {\n        if (currSection.modifiers[j].match(/^\\s*.+?\\s+\\-\\s/g)) {\n          lastModifier = j;\n        } else if (j === 0) {\n          // The paragraph doesn't start with a modifier, so bail out.\n          hasModifiers = false;\n          j = m;\n        } else {\n          // If the current line doesn't match a modifier, it must be a\n          // multi-line modifier description.\n          currSection.modifiers[lastModifier] += ' ' + currSection.modifiers[j].replace(/^\\s+|\\s+$/g, '');\n          // We will strip this blank line later.\n          currSection.modifiers[j] = '';\n        }\n      }\n      // Remove any blank lines added.\n      /* eslint-disable no-loop-func */\n      currSection.modifiers = currSection.modifiers.filter(function(line) { return line !== ''; });\n      /* eslint-enable no-loop-func */\n\n      // If it's a modifiers paragraph, turn each one into a modifiers object.\n      // Otherwise, add it back to the description.\n      if (hasModifiers) {\n        // If the current section has markup, create proper KssModifier objects.\n        if (currSection.markup) {\n          currSection.modifiers = createModifiers(currSection.modifiers, options);\n        } else {\n          // If the current section has no markup, create KssParameter objects.\n          currSection.parameters = createParameters(currSection.modifiers, options);\n          currSection.modifiers = [];\n        }\n      } else {\n        currSection.description += '\\n\\n' + paragraphs[paragraphs.length - 2];\n        currSection.modifiers = [];\n      }\n    }\n\n    // Squash the header into a single line.\n    currSection.header = currSection.header.replace(/\\n/g, ' ');\n\n    // Check the section's status.\n    currSection.deprecated = isDeprecated(currSection.description, options);\n    currSection.experimental = isExperimental(currSection.description, options);\n\n    // If multi-line descriptions are allowed, remove the first paragraph (the\n    // header) from the description.\n    if (options.multiline) {\n      if (currSection.description.match(/\\n{2,}/)) {\n        currSection.description = currSection.description.replace(/^.*?\\n{2,}/, '');\n      } else {\n        currSection.description = '';\n      }\n    }\n\n    // Markdown Parsing.\n    if (options.markdown) {\n      currSection.description = marked(currSection.description);\n    }\n\n    // Add the new section instance to the sections array.\n    currSection = new KssSection(currSection);\n    data.sections.push(currSection);\n\n    // Store the reference for quick searching later.\n    data.section_refs[currSection.reference()] = currSection;\n  }\n\n  return data;\n};\n\n/**\n * Takes an array of modifier lines, and turns it into instances of KssModifier.\n *\n * @private\n * @param  {Array}  lines   Modifier lines, which should all be strings.\n * @param  {Object} options Any options passed on by the functions above.\n * @returns {Array} The modifier instances created.\n */\ncreateModifiers = function(lines, options) {\n  return lines.map(function(entry) {\n    var modifier, description, className;\n\n    // Split modifier name and the description.\n    modifier = entry.split(/\\s+\\-\\s+/, 1)[0];\n    description = entry.replace(modifier, '', 1).replace(/^\\s+\\-\\s+/, '');\n\n    className = modifier.replace(/\\:/g, '.pseudo-class-');\n\n    // Markdown parsing.\n    if (options.markdown) {\n      description = marked(description, {renderer: inlineRenderer});\n    }\n\n    return new KssModifier({\n      name: modifier,\n      description: description,\n      className: className\n    });\n  });\n};\n\n/**\n * Takes an array of parameter lines, and turns it into instances of KssParameter.\n *\n * @private\n * @param  {Array}  lines   Parameter lines, which should all be strings.\n * @param  {Object} options Any options passed on by the functions above.\n * @returns {Array} The parameter instances created.\n */\ncreateParameters = function(lines, options) {\n  return lines.map(function(entry) {\n    var parameter, description;\n\n    // Split parameter name and the description.\n    parameter = entry.split(/\\s+\\-\\s+/, 1)[0];\n    description = entry.replace(parameter, '', 1).replace(/^\\s+\\-\\s+/, '');\n\n    // Markdown parsing.\n    if (options.markdown) {\n      description = marked(description, {renderer: inlineRenderer});\n    }\n\n    return new KssParameter({\n      name: parameter,\n      description: description\n    });\n  });\n};\n\n/**\n * Returns an array of comment blocks found within a string.\n *\n * @private\n * @param  {String} input   The string to search.\n * @returns {Array} The blocks found.\n */\nfindBlocks = function(input) {\n  /* eslint-disable key-spacing */\n  var currentBlock = '',\n    insideSingleBlock = false, insideMultiBlock = false, insideDocblock = false,\n    indentAmount = false,\n    blocks = [],\n    lines, line, i, l,\n    commentExpressions = {\n      single:         /^\\s*\\/\\/.*$/,\n      docblockStart:  /^\\s*\\/\\*\\*\\s*$/,\n      multiStart:     /^\\s*\\/\\*+\\s*$/,\n      multiFinish:    /^\\s*\\*\\/\\s*$/\n    };\n  /* eslint-enable key-spacing */\n\n  input = input.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n  lines = input.split(/\\n|$/g);\n\n  l = lines.length;\n  for (i = 0; i < l; i += 1) {\n    line = lines[i];\n\n    // Remove trailing space.\n    line = line.replace(/\\s*$/, '');\n\n    // Single-line parsing.\n    if (!insideMultiBlock && !insideDocblock && line.match(commentExpressions.single)) {\n      if (insideSingleBlock && currentBlock !== '') {\n        currentBlock += '\\n';\n      }\n      currentBlock += line.replace(/^\\s*\\/\\/\\s?/, '');\n      insideSingleBlock = true;\n      continue;\n    }\n\n    // Since the current line is not a single line comment, save the current\n    // block and continue parsing the current line.\n    if (insideSingleBlock) {\n      blocks.push(currentBlock.replace(/^\\n+/, '').replace(/\\n+$/, ''));\n      insideSingleBlock = false;\n      currentBlock = '';\n    }\n\n    // Save the current multi-/docblock if we have reached the end of the block.\n    if ((insideMultiBlock || insideDocblock) && line.match(commentExpressions.multiFinish)) {\n      blocks.push(currentBlock.replace(/^\\n+/, '').replace(/\\n+$/, ''));\n      insideMultiBlock = insideDocblock = false;\n      currentBlock = '';\n      indentAmount = false;\n      continue;\n    }\n\n    // Docblock parsing.\n    if (line.match(commentExpressions.docblockStart)) {\n      insideDocblock = true;\n      currentBlock = '';\n      continue;\n    }\n    if (insideDocblock) {\n      currentBlock += '\\n';\n      currentBlock += line.replace(/^\\s*\\*\\s?/, '');\n      continue;\n    }\n\n    // Multi-line parsing.\n    if (line.match(commentExpressions.multiStart)) {\n      insideMultiBlock = true;\n      currentBlock = '';\n      continue;\n    }\n    if (insideMultiBlock) {\n      // If this is the first interior line, determine the indentation amount.\n      if (indentAmount === false) {\n        // Skip initial blank lines.\n        if (line === '') {\n          continue;\n        }\n        indentAmount = line.match(/^\\s*/)[0];\n      }\n      currentBlock += '\\n';\n      // Always strip same indentation amount from each line.\n      currentBlock += line.replace(new RegExp('^' + indentAmount), '', 1);\n      continue;\n    }\n  }\n\n  // Add the last comment block to our list of blocks.\n  if (currentBlock) {\n    blocks.push(currentBlock.replace(/^\\n+/, '').replace(/\\n+$/, ''));\n  }\n\n  return blocks;\n};\n\n/**\n * Check a section for the reference number it may or may not have.\n *\n * @private\n * @param  {Array}  paragraphs An array of the paragraphs in a single block.\n * @param  {Object} options    The options object passed on from the initial functions\n * @returns {Boolean|String} False if not found, otherwise returns the reference number as a string.\n */\ncheckReference = function(paragraphs, options) {\n  var lastParagraph = paragraphs[paragraphs.length - 1].trim(),\n    words = lastParagraph.split(/\\s+/),\n    keyword = false,\n    reference = false;\n\n  // If is only one word in the last paragraph, it can't be a styleguide ref.\n  if (words.length < 2) {\n    return false;\n  }\n\n  // Search for the \"styleguide\" (or \"style guide\") keyword at the start of the paragraph.\n  [words[0], words[0] + words[1]].forEach(function(value, index) {\n    if (!keyword) {\n      value = value.replace(/[-\\:]?$/, '');\n      if (value.toLowerCase() === 'styleguide' || options.typos && natural.Metaphone.compare('Styleguide', value.replace('-', ''))) {\n        keyword = words.shift();\n        if (index === 1) {\n          keyword += ' ' + words.shift();\n        }\n      }\n    }\n  });\n\n  if (keyword) {\n    reference = words.join(' ');\n\n    // Normalize any \" - \" delimeters.\n    reference = reference.replace(/\\s+\\-\\s+/g, ' - ');\n\n    // Remove trailing dot-zeros and periods.\n    reference = reference.replace(/\\.$|(\\.0){1,}$/g, '');\n  }\n\n  return reference;\n};\n\n/**\n * Checks if there is a specific property in the comment block and removes it from the original array.\n *\n * @private\n * @param  {String}   propertyName The name of the property to search for\n * @param  {Array}    paragraphs   An array of the paragraphs in a single block\n * @param  {Object}   options      The options object passed on from the initial functions\n * @param  {Object}   sectionData  The original data object of a section.\n * @param  {Function} processValue A function to massage the value before it is inserted into the sectionData.\n * @returns {Object} A new data object for the section.\n */\nprocessProperty = function(propertyName, paragraphs, options, sectionData, processValue) {\n  var indexToRemove = 'not found';\n\n  propertyName = propertyName.toLowerCase();\n\n  paragraphs.map(function(paragraph, index) {\n    if (hasPrefix(paragraph, options, propertyName)) {\n      sectionData[propertyName] = paragraph.replace(new RegExp('^\\\\s*' + propertyName + '\\\\:\\\\s+?', 'gmi'), '');\n      if (typeof processValue === 'function') {\n        sectionData[propertyName] = processValue(sectionData[propertyName]);\n      }\n      paragraph = '';\n      indexToRemove = index;\n    }\n    return paragraph;\n  });\n\n  if (indexToRemove !== 'not found') {\n    paragraphs.splice(indexToRemove, 1);\n  }\n\n  return sectionData;\n};\n\n/**\n * Check if the description indicates that a section is deprecated.\n *\n * @private\n * @param  {String}  description The description of that section\n * @param  {Object}  options     The options passed on from previous functions\n * @returns {Boolean} Whether the description indicates the section is deprecated.\n */\nisDeprecated = function(description, options) {\n  return hasPrefix(description, options, 'Deprecated');\n};\n\n/**\n * Check if the description indicates that a section is experimental.\n *\n * @private\n * @param  {String}  description The description of that section\n * @param  {Object}  options     The options passed on from previous functions\n * @returns {Boolean} Whether the description indicates the section is experimental.\n */\nisExperimental = function(description, options) {\n  return hasPrefix(description, options, 'Experimental');\n};\n\n/**\n * Essentially this function checks if a string is prefixed by a particular attribute,\n * e.g. 'Deprecated:' and 'Markup:'\n *\n * If `options.typos` is enabled it'll try check if the first word at least sounds like\n * the word we're checking for.\n *\n * @private\n * @param  {String}  description The string to check\n * @param  {Object}  options     The options passed on from previous functions\n * @param  {String}  prefix      The prefix to search for\n * @returns {Boolean} Whether the description contains the specified prefix.\n */\nhasPrefix = function(description, options, prefix) {\n  var words;\n  if (!options.typos) {\n    return !!description.match(new RegExp('^\\\\s*' + prefix + '\\\\:', 'gmi'));\n  }\n\n  words = description.replace(/^\\s*/, '').match(/^\\s*([a-z ]*)\\:/gmi);\n  if (!words) {\n    return false;\n  }\n\n  return natural.Metaphone.compare(words[0].replace(':', ''), prefix);\n};\n\nmodule.exports = parse;\n","/home/travis/build/npmtest/node-npmtest-kss/node_modules/kss/lib/traverse.js":"/* eslint-disable max-nested-callbacks */\n\n'use strict';\n\n/**\n * The `kss/lib/traverse` module is normally accessed via the\n * [`traverse()`]{@link module:kss.traverse} method of the `kss` module:\n * ```\n * var kss = require('kss');\n * kss.traverse(directory, options, callback);\n * ```\n * @private\n * @module kss/lib/traverse\n */\n\nvar parse = require('./parse.js'),\n  path = require('path'),\n  fs = require('fs');\n\nvar traverse;\n\n/**\n * Traverse a directory, parse its contents, and create a KssStyleguide.\n *\n * Callbacks receive an instance of `KssStyleguide`.\n *\n * If you want to parse anything other than css, less, sass, or stylus files\n * then you'll want to use options.mask to target a different set of file\n * extensions.\n *\n * ```\n * kss.traverse('./stylesheets', { mask: '*.css' }, function(err, styleguide) {\n *     if (err) throw err;\n *\n *     styleguide.section('2.1.1') // <KssSection>\n * });\n * ```\n *\n * There a few extra `options` you can pass to `kss.traverse` which will effect\n * the output generated:\n *\n * - mask: Use a regex or string (e.g. `*.less|*.css`) to only parse files\n *   matching this value. Defaults to:\n *   `*.css|*.less|*.sass|*.scss|*.styl|*.stylus`\n * - markdown: kss-node supports built-in Markdown formatting of its\n *   documentation, thanks to [marked](https://github.com/chjj/marked). It's\n *   enabled by default, but you can disable it by adding `markdown: false` to\n *   the `options` object.\n * - multiline: kss-node makes the header available separately from the\n *   description. To make kss-node behave like the Ruby KSS, disable this option\n *   and the title will remain a part of the description. This setting is\n *   enabled by default, but you can disable it by adding `multiline: false` to\n *   your options.\n * - typos: Thanks to [natural](https://github.com/NaturalNode/natural),\n *   kss-node can parse keywords phonetically rather then by their string value.\n *   In short: make a typo and the library will do its best to read it anyway.\n *   Enabled by default.\n *\n * @alias module:kss.traverse\n * @param {String|Array} directory The directory(s) to traverse\n * @param {Object}       options   Options to alter the output content (optional)\n * @param {Function}     callback  Called when traversal AND parsing is complete\n */\ntraverse = function(directory, options, callback) {\n  var fileNames = [],\n    fileCounter = 0,\n    filesRemaining = 0,\n    loopsRemaining = 0,\n    walkFinished,\n    walk;\n\n  options = options || {};\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  if (typeof callback !== 'function') {\n    throw new Error('No callback supplied for kss.traverse()!');\n  }\n\n  // Mask to search for particular file types - defaults to common precompilers.\n  options.mask = options.mask || /\\.css|\\.less|\\.sass|\\.scss|\\.styl|\\.stylus/;\n\n  // If the mask is a string, convert it into a RegExp.\n  if (!(options.mask instanceof RegExp)) {\n    options.mask = new RegExp(\n      '(?:' + options.mask.replace(/\\./g, '\\\\.').replace(/\\*/g, '.*') + ')$'\n    );\n  }\n\n  // Normalize all the directory paths.\n  if (!Array.isArray(directory)) {\n    directory = [directory];\n  }\n  for (var key in directory) {\n    // istanbul ignore else\n    if (directory.hasOwnProperty(key)) {\n      directory[key] = path.normalize(directory[key]);\n    }\n  }\n\n  // Callback for walk() when it has finished traversing all directories.\n  walkFinished = function() {\n    /* eslint-disable no-loop-func */\n    var i, l = fileNames.length, files = [], orderedObject = {};\n\n    fileNames.sort();\n    for (i = 0; i < l; i += 1) {\n      (function(j) {\n        fs.readFile(fileNames[j], 'utf8', function(err, contents) {\n          // istanbul ignore if\n          if (err) { callback(err); return; }\n\n          files[j] = contents;\n          fileCounter -= 1;\n\n          if (fileCounter === 0) {\n            files.map(function(fileContent, index) {\n              var filename = fileNames[index];\n              orderedObject[filename] = fileContent;\n              return '';\n            });\n            parse(orderedObject, options, callback);\n          }\n        });\n      }(i));\n    }\n  };\n\n  // Courtesy of [stygstra](https://gist.github.com/514983)\n  // istanbul ignore next\n  walk = function(directories, opts, cb) {\n    opts = opts || {};\n    if (typeof cb !== 'function') { cb = function() {}; }\n\n    if (!Array.isArray(directories)) {\n      directories = [directories];\n    }\n\n    // Loop through all the given directories.\n    loopsRemaining += directories.length;\n    directories.forEach(function(dir) {\n      loopsRemaining -= 1;\n\n      // Start an asynchronous search of the file system.\n      filesRemaining += 1;\n      fs.readdir(dir, function(err, relnames) {\n        if (err) {\n          cb(err);\n          return;\n        }\n\n        // About to start looping through the directory contents.\n        loopsRemaining += relnames.length;\n        // The fs.readdir() callback has returned.\n        filesRemaining -= 1;\n\n        // If there is no more file system to search, call .finished().\n        if (filesRemaining === 0 && loopsRemaining === 0) {\n          cb(null);\n        }\n\n        // Otherwise, if readdir() has results, loop through them.\n        relnames.forEach(function(relname) {\n          loopsRemaining -= 1;\n          var name = path.join(dir, relname);\n\n          // Start an asynchronous stat of this file system item.\n          filesRemaining += 1;\n          fs.stat(name, function(error, stat) {\n            if (error) {\n              cb(error);\n              return;\n            }\n\n            if (stat.isDirectory()) {\n              if (name !== '.svn' && name !== '.git') {\n                walk(name, opts, cb);\n              }\n            } else if (!opts.mask || name.match(opts.mask)) {\n              name = name.replace(/\\\\/g, '/');\n              fileNames.push(name);\n              fileCounter += 1;\n            }\n\n            // The fs.stat() callback has returned.\n            filesRemaining -= 1;\n\n            // If there is no more file system to search, call .finished().\n            if (filesRemaining === 0 && loopsRemaining === 0) {\n              cb(null);\n              return;\n            }\n          });\n        });\n      });\n    });\n  };\n\n  // Get each file in the target directory, order them alphabetically and then\n  // parse their output.\n  walk(directory, options, walkFinished);\n};\n\nmodule.exports = traverse;\n","/home/travis/build/npmtest/node-npmtest-kss/node_modules/kss/generator/kss_generator.js":"'use strict';\n\n/**\n * The `kss/generator` module loads the {@link KssGenerator} class constructor.\n * ```\n * var KssGenerator = require('kss/generator');\n * ```\n * @module kss/generator\n */\n\n/* **************************************************************\n   See kss_example_generator.js for how to implement a generator.\n   ************************************************************** */\n\nvar Kss = require('../lib/kss.js'),\n  wrench = require('wrench');\n\nvar KssGenerator;\n\n/**\n * Create a KssGenerator object.\n *\n * This is the base object used by all kss-node generators. Implementations of\n * KssGenerator MUST pass the version parameter. kss-node will use this to\n * ensure that only compatible generators are used.\n *\n * ```\n * var KssGenerator = require('kss/generator');\n * var customGenerator = new KssGenerator('2.1');\n * ```\n *\n * @constructor\n * @alias KssGenerator\n * @param {string} version The generator API version implemented.\n * @param {object} options The Yargs-like options this generator has.\n *   See https://github.com/bcoe/yargs/blob/master/README.md#optionskey-opt\n */\nmodule.exports = KssGenerator = function(version, options) {\n  if (!(this instanceof KssGenerator)) {\n    return new KssGenerator();\n  }\n\n  // Tell generators which generator API version is currently running.\n  this.API = '2.1';\n\n  // Store the version of the generator API that the generator instance is\n  // expecting; we will verify this in checkGenerator().\n  this.implementsAPI = typeof version === 'undefined' ? 'undefined' : version;\n\n  // Tell kss-node which Yargs-like options this generator has.\n  this.options = options || {};\n\n  // The log function defaults to console.log.\n  this.setLogFunction(console.log);\n};\n\n/**\n * Logs a message to be reported to the user.\n *\n * Since a generator can be used in places other than the console, using\n * console.log() is inappropriate. The log() method should be used to pass\n * messages to the KSS system so it can report them to the user.\n *\n * @param {string} message The message to log.\n */\nKssGenerator.prototype.log = function() {\n  this.logFunction.apply(null, arguments);\n};\n\n/**\n * The log() method logs a message for the user. This method allows the system\n * to define the underlying function used by the log method to report the\n * message to the user. The default log function is a wrapper around\n * console.log().\n *\n * @param {Function} logFunction Function to log a message to the user.\n */\nKssGenerator.prototype.setLogFunction = function(logFunction) {\n  this.logFunction = logFunction;\n};\n\n/**\n * Checks the generator configuration.\n *\n * An instance of KssGenerator MUST NOT override this method. A process\n * controlling the generator should call this method to verify the\n * specified generator has been configured correctly.\n *\n * @alias KssGenerator.prototype.checkGenerator\n * @param {Function} cb Callback that will be given an Error as its first\n *                      parameter, if one occurs.\n * @returns {*} The callback's return value.\n */\nKssGenerator.prototype.checkGenerator = function(cb) {\n  var isCompatible = true,\n    version,\n    apiMajor,\n    apiMinor,\n    thisMajor,\n    thisMinor,\n    error;\n\n  cb = cb || /* istanbul ignore next */ function() {};\n\n  if (!(this instanceof KssGenerator)) {\n    error = new Error('The loaded generator is not a KssGenerator object.');\n    // istanbul ignore if: API 2.0 is deprecated; remove in 3.x\n    if (this.implementsAPI === '2.0') {\n      throw error;\n    } else {\n      return cb(error);\n    }\n  }\n\n  if (this.implementsAPI === 'undefined') {\n    isCompatible = false;\n  } else {\n    version = this.API.split('.');\n    apiMajor = parseInt(version[0]);\n    apiMinor = parseInt(version[1]);\n\n    version = this.implementsAPI.split('.');\n    thisMajor = parseInt(version[0]);\n    thisMinor = parseInt(version[1]);\n\n    if (thisMajor !== apiMajor || thisMinor > apiMinor) {\n      isCompatible = false;\n    }\n  }\n\n  if (!isCompatible) {\n    error = new Error('kss-node expected the template\\'s generator to implement KssGenerator API version ' + this.API + '; version \"' + this.implementsAPI + '\" is being used instead.');\n    // istanbul ignore if: API 2.0 is deprecated; remove in 3.x\n    if (this.implementsAPI === '2.0') {\n      throw error;\n    } else {\n      return cb(error);\n    }\n  }\n\n  return cb(null);\n};\n\n/**\n * Clone a template's files.\n *\n * This method is fairly simple; it copies one directory to the specified\n * location. An instance of KssGenerator does not need to override this method,\n * but it can if it needs to do something more complicated.\n *\n * @alias KssGenerator.prototype.clone\n * @param {string} templatePath    Path to the template to clone.\n * @param {string} destinationPath Path to the destination of the newly cloned\n *                                 template.\n * @param {Function} cb Callback that will be given an Error as its first\n *                      parameter, if one occurs.\n * @returns {*} The callback's return value.\n */\nKssGenerator.prototype.clone = function(templatePath, destinationPath, cb) {\n  var self = this;\n\n  cb = cb || /* istanbul ignore next */ function() {};\n\n  return wrench.copyDirRecursive(\n    templatePath,\n    destinationPath,\n    {\n      forceDelete: false,\n      excludeHiddenUnix: true\n    },\n    function(error) {\n      if (error) {\n        // istanbul ignore else\n        if (error.message === 'You are trying to delete a directory that already exists. Specify forceDelete in an options object to override this.') {\n          error = new Error('This folder already exists: ' + destinationPath);\n        }\n        // istanbul ignore if: API 2.0 is deprecated; remove in 3.x\n        if (self.implementsAPI === '2.0') {\n          // istanbul ignore next: API 2.0 is deprecated; remove in 3.x\n          throw error;\n        } else {\n          return cb(error);\n        }\n      }\n      return cb(null);\n    }\n  );\n};\n\n/**\n * Initialize the style guide creation process.\n *\n * This method is given a configuration JSON object with the details of the\n * requested style guide generation. The generator can use this information for\n * any necessary tasks before the KSS parsing of the source files.\n *\n * @alias KssGenerator.prototype.init\n * @param {Object} config Configuration object for the requested generation.\n * @param {Function} cb Callback that will be given an Error as its first\n *                      parameter, if one occurs.\n * @returns {*} The callback's return value.\n */\nKssGenerator.prototype.init = function(config, cb) {\n  cb = cb || /* istanbul ignore next */ function() {};\n\n  // At the very least, generators MUST save the configuration parameters.\n  this.config = config;\n\n  return cb(null);\n};\n\n/**\n * Parse the source files for KSS comments and create a KssStyleguide object.\n *\n * When finished, it passes the completed KssStyleguide to the given callback.\n *\n * @alias KssGenerator.prototype.parse\n * @param {Function} cb Callback that will be given an Error as its first\n *                      parameter, if one occurs, and a fully-populated\n *                      KssStyleguide as its second parameter.\n * @returns {*} The callback's return value.\n */\nKssGenerator.prototype.parse = function(cb) {\n  var traverseCallback;\n\n  // istanbul ignore if: API 2.0 is deprecated; remove in 3.x\n  if (this.implementsAPI === '2.0') {\n    // For API 2.0, the callback did pass errors to the callback.\n    traverseCallback = function(err, styleguide) {\n      if (err) {\n        throw err;\n      }\n      return cb(styleguide);\n    };\n  } else {\n    traverseCallback = cb;\n  }\n\n  if (this.config.verbose) {\n    this.log('...Parsing your style guide:');\n  }\n\n  // The default parse() method looks at the paths to the source folders and\n  // uses KSS' traverse method to load, read and parse the source files. Other\n  // generators may want to use KSS' parse method if they have already loaded\n  // the source files through some other mechanism.\n  return Kss.traverse(this.config.source, {\n    multiline: true,\n    markdown: true,\n    markup: true,\n    mask: this.config.mask,\n    custom: this.config.custom\n  }, traverseCallback);\n};\n\n/**\n * Allow the template to prepare itself or modify the KssStyleguide object.\n *\n * @alias KssGenerator.prototype.prepare\n * @param {KssStyleguide} styleguide The KSS style guide in object format.\n * @param {Function} cb Callback that will be given an Error as its first\n *                      parameter, if one occurs, and a fully-populated\n *                      KssStyleguide as its second parameter.\n * @returns {*} The callback's return value.\n */\nKssGenerator.prototype.prepare = function(styleguide, cb) {\n  return cb(null, styleguide);\n};\n\n/**\n * Generate the HTML files of the style guide given a KssStyleguide object.\n *\n * @alias KssGenerator.prototype.generate\n * @param {KssStyleguide} styleguide The KSS style guide in object format.\n * @param {Function} cb Callback that will be given an Error as its first\n *                      parameter, if one occurs.\n * @returns {*} The callback's return value.\n */\nKssGenerator.prototype.generate = function(styleguide, cb) {\n  cb = cb || /* istanbul ignore next */ function() {};\n\n  return cb(null);\n};\n"}